<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fomalhaut🥝</title>
  
  
  <link href="https://www.fomal.cc/atom.xml" rel="self"/>
  
  <link href="https://www.fomal.cc/"/>
  <updated>2024-11-15T10:53:29.317Z</updated>
  <id>https://www.fomal.cc/</id>
  
  <author>
    <name>Fomalhaut🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>myself</title>
    <link href="https://www.fomal.cc/posts/ab65d9e6.html"/>
    <id>https://www.fomal.cc/posts/ab65d9e6.html</id>
    <published>2024-11-06T01:08:16.000Z</published>
    <updated>2024-11-15T10:53:29.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/image-20241106090950823.png" alt="image-20241106090950823"></p><p><img src="../assets/image-20241106091011068.png" alt="image-20241106091011068"></p><p><img src="../assets/image-20241107131412823.png" alt="image-20241107131412823"></p><p><img src="../assets/image-20241113210233456.png" alt="image-20241113210233456"></p><p>面试官您好，想跟您确定一下，我们这次是技术面试   因为之前hr提到要转换到C#语言，但自己可能对于C#了解不太多。</p><p>所以想问下您是做什么语言方向？这次面试主要考察关于 语言相关呢？还是计算机基础呢  这样我后边在展开介绍自己的时候，更加有侧重点的来针对自己来进行介绍。</p><blockquote><p>参与公司 MySQL 数据库的日常运维</p><p>REDIS 数据类型  应用   缓存机制  </p><p>redis  做点赞排行    / 商品排行榜  </p><p>看你做过数据库管理和优化，你简单介绍一下你在实习中做的工作吧</p><p><strong>数据监控和问题排查</strong></p><ul><li>数据库监控系统，实时跟踪数据库性能、查询速度和错误日志，及时发现并解决问题。</li></ul><p><strong>跨部门协作</strong></p><ul><li>与其他团队（如开发、产品等）紧密合作，共同维护 K12课程商城、讲师排课、 上课系统的后台</li><li>提供数据支持，帮助解决业务中遇到的数据问题。</li></ul><p>“我在学而思科技教育公司担任数据工程师实习生，主要负责管理和优化讲师后台的数据库。这个数据库支持公司K12教育业务中的上课、排班、和购课等核心功能。”</p><p>我的日常工作包括对数据库进行维护和监控，确保数据的一致性和完整性。具体而言，还参与了数据库的性能优化工作，通过分析查询瓶颈、优化SQL语句和调整数据库配置，有效提高了系统的响应速度和处理能力。”</p><p>学习技术文档+了解数据库后台的工作运行状态</p><p>在优化方面，我使用了MySQL的索引优化功能，分析了慢查询日志，并针对业务需求调整了数据库表结构。</p><p>通过这些优化措施，数据库的查询速度提升了约30%，系统的稳定性也得到了显著增强，减少了因数据库性能问题而导致的业务中断时间。</p></blockquote><h4 id="Mysql调优"><a href="#Mysql调优" class="headerlink" title="Mysql调优"></a>Mysql调优</h4><p>数据库优化是我工作中的重点之一。我参与的优化工作主要集中在提高数据库的查询性能和系统响应速度。具体的优化工作包括：</p><ul><li><strong>查询优化</strong>：分析慢查询日志，识别性能瓶颈。通过优化 SQL 查询语句，避免不必要的全表扫描，使用合适的索引来加速查询。</li><li><strong>索引优化</strong>：我分析了数据库中使用最频繁的查询，创建了合适的索引（如复合索引、唯一索引等），以减少查询时的数据扫描量。</li><li><strong>表结构优化</strong>：对部分数据表进行结构调整，减少冗余数据，提高存储效率。通过拆分大表、归档过期数据等方式，降低了数据库的负载。</li><li><strong>数据库配置优化</strong>：调整数据库的配置参数（如缓存大小、连接池设置等）来提高性能，保证系统在高并发时的稳定运行。</li></ul><p>你的任务是为落地页的管理端新增一个页面列表的功能。这通常涉及到在后台系统中显示一个包含多个页面的列表，便于管理员查看、管理这些页面。</p><p>给一个商品页  新的活动上的 课程商品页 增加page分页查询</p><p>在测试的时候 发现有个接口超时了，结果发现是因为优化器逆向优化的原因</p><p>自己找了很久的原因，因为是刚接触到数据库一段时间，纯粹自学，没学这么深。</p><p>业务上是这样：</p><p>落地页 模板 template表和page表</p><p>背景：落地页这边有 template 表和 page 表，两张表根据 template_id 字段关联，其中 template 表中有 template_name 字段，跟 template_id 是 1 对多的关系，template_id 与 page 是 1 对多的关系。落地页的管理端需要根据 template_name 字段查 page list，需要分页，所以需要查 count 总数。</p><blockquote><p>先根据 template_name 查 template id 列表，然后根据 where template_id in (template_id…) 查 page list</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="built_in">count</span>(page_id) <span class="keyword">FROM</span> <span class="symbol">`page`</span>  <span class="keyword">WHERE</span> (template_id <span class="keyword">IN</span> ( <span class="comment">/* many ids*/</span> ) ) <span class="keyword">AND</span> (is_del = <span class="string">&#x27;0&#x27;</span> ) </span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``<span class="keyword">SELECT</span> SQL_NO_CACHE <span class="built_in">count</span>(page_id) <span class="keyword">FROM</span> <span class="symbol">`page`</span>  <span class="keyword">WHERE</span> (template_id <span class="keyword">IN</span> ( <span class="comment">/* many ids but less than SQL A*/</span> ) ) <span class="keyword">AND</span> (is_del = <span class="string">&#x27;0&#x27;</span> )</span><br></pre></td></tr></table></figure><p>两个 SQL 结构、字段一致，只有 IN 语句中限定的值范围不一样，就导致一个正常应用了索引(type 为 range)，一个没有(type 为 all)，仔细观察 explain 的结果可以看到 SQL A 中没有用到索引，而且 explain 还告诉我们一个信息：对于 SQL A possible_keys 跟 SQL B 一样，都是 idx_template_id，但是 type、key、extra 等几个字段中都告诉我们，索引没生效。</p><blockquote><p> 查了一下资料，我选择尝试添加 FORCE INDEX (idx_template_id) ，耗时变成了 ～700ms，问题解决了，explain 可以看到强制索引生效了，但是也多了一个奇怪的参数：Using MRR。</p></blockquote><p><strong>explain 的用法</strong></p><p><strong>MRR</strong>  </p><p>MRR 把「随机磁盘读」，转化为「顺序磁盘读」，主要原理是在从索引中读出记录后，查磁盘前先按照记录在磁盘中的顺序排序，然后再去读磁盘，这样可以减少磁盘的机械运动次数，另外也可以充分利用磁盘预读(磁盘预读是指在一次磁盘读取中，将要读取的数据附近的数据放进数据缓存区，这样做的原因是局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用)。</p><blockquote><p> 索引优化之 MRR</p><p>例如有一张表 user，主键 id，普通字段 age，为 age 创建非聚集索引，有一条查询语句 select<em> user from table where age &gt; 18;(注意查询语句中的结果是</em>)</p><blockquote><p>在 MySQL5.5 以及之前的版本中如何查询呢？先通过非聚集索引查询到 age&gt;18 的第一条数据，获取到了主键 id；然后根据非聚集索引中的叶子节点存储的主键 id 去聚集索引中查询行数据；根据 age&gt;18 的数据条数每次查询聚集索引，这个过程叫做回表。</p></blockquote><p>上述的步骤有什么缺点呢？如何 age&gt;18 的数据非常多，那么每次回表都需要经过 3 次 IO(假设 B+树的高度是 3)，那么会导致查询效率过低。</p><blockquote><p>在 MySQL5.6 时针对上述问题进行了优化，优化器先查询到 age&gt;3 的所有数据的主键 id，对所有主键的 id 进行排序，排序的结果缓存到 read_rnd_buffer，然后通过排好序的主键在聚簇索引中进行查询。</p><p>如果两个主键的范围相近，在同一个数据页中就可以之间按照顺序获取，那么磁盘 io 的过程将会大大降低。这个优化的过程就叫做 Multi Range Read(MRR) 多返回查询。</p></blockquote><p> 优化器主要由转换模块、计划生成模块、评估模块三个模块组成，其中最重要的是评估模块，它会负责决定不同执行计划的成本，作为最优计划的选择标准。</p><p>那么成本是如何决定的呢？有三个维度：Selectivity、Cardinality、Cost</p><p>Mysql【数据库设计，调优案例，索引，事务，锁】</p><p>计算机网络</p><p>操作系统</p><p>数据结构</p><p>虽然要涉及到要更换语言，但是相信自己的学习能力和自己的计算机基础比较扎实</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec19496d4064d0aa62c7e7df469b1f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432a5f08fb604b578dce14dd8f21916d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="Onenet-软硬打通"><a href="#Onenet-软硬打通" class="headerlink" title="Onenet 软硬打通"></a>Onenet 软硬打通</h2><p>在系统的实现过程中，软件系统、硬件系统和云端之间的数据关联和统一至关重要，尤其是当需要同步设备状态、数据和指令时，必须确保数据一致性和实时性。以下是详细的流程描述、技术细节和实现方式。</p><h3 id="1-软件系统、硬件系统和云端关联的主要工作"><a href="#1-软件系统、硬件系统和云端关联的主要工作" class="headerlink" title="1. 软件系统、硬件系统和云端关联的主要工作"></a>1. 软件系统、硬件系统和云端关联的主要工作</h3><p>在实现软件、硬件和云端之间的数据关联时，主要工作包括：</p><ul><li><strong>硬件数据采集和上传</strong>：通过传感器或控制器采集硬件设备的数据（如温度、湿度等），并将数据上传到云端平台。</li><li><strong>云端数据管理和推送</strong>：在云端平台（如 OneNet、阿里云 IoT）管理设备数据，将硬件数据转发给软件系统，或接收软件系统的控制指令并转发给硬件设备。</li><li><strong>软件系统的数据统一和展示</strong>：软件系统从云端平台获取硬件数据，并展示给用户。同时，软件系统可以发送控制指令到云端，由云端转发给硬件设备。</li></ul><h3 id="2-实现数据统一的技术流程"><a href="#2-实现数据统一的技术流程" class="headerlink" title="2. 实现数据统一的技术流程"></a>2. 实现数据统一的技术流程</h3><p>整个数据流主要包括以下流程：</p><ol><li><strong>硬件设备数据采集</strong>：硬件设备通过传感器采集数据，并通过通信模块（如 WiFi 模块、LoRa 模块）上传数据至云端。</li><li><strong>云端平台数据接收和处理</strong>：云端平台接收硬件设备数据，对数据进行格式化处理，并存储在云端数据库中。同时，云端会根据设定的回调，将数据推送到软件系统。</li><li><strong>软件系统数据接收与统一展示</strong>：软件系统接收到云端数据后，将其存储到本地数据库中，展示在前端界面。</li><li><strong>软件系统向硬件发送控制指令</strong>：当用户在软件系统中下发控制指令时，指令通过云端转发至硬件设备，执行相应的操作。</li></ol><h3 id="3-技术细节和组件说明"><a href="#3-技术细节和组件说明" class="headerlink" title="3. 技术细节和组件说明"></a>3. 技术细节和组件说明</h3><h4 id="（1）硬件系统数据采集与上传"><a href="#（1）硬件系统数据采集与上传" class="headerlink" title="（1）硬件系统数据采集与上传"></a>（1）硬件系统数据采集与上传</h4><ul><li><p><strong>硬件设备</strong>：设备使用 STM32、ESP8266 等硬件平台，通过传感器采集数据。</p></li><li><p><strong>通信协议</strong>：使用 MQTT 或 HTTP 协议将数据发送到云端平台，如 OneNet 平台。MQTT 是物联网常用的消息传输协议，适合实时数据传输。</p></li><li><p><strong>数据格式</strong>：硬件将采集的数据封装成 JSON 格式，以便上传到云端。</p><p><strong>示例代码（MQTT 发送数据）</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="comment">// 使用 MQTT 发布传感器数据</span></span><br><span class="line">mqttClient.publish(<span class="string">&quot;device/data&quot;</span>, <span class="string">&quot;&#123;<span class="subst">\&quot;</span>temperature<span class="subst">\&quot;</span>:25.6,<span class="subst">\&quot;</span>humidity<span class="subst">\&quot;</span>:60&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）云端平台的数据接收和推送"><a href="#（2）云端平台的数据接收和推送" class="headerlink" title="（2）云端平台的数据接收和推送"></a>（2）云端平台的数据接收和推送</h4><ul><li><p><strong>平台配置</strong>：在 OneNet、阿里云 IoT 等平台配置设备，创建数据流，确保设备上传的数据能够被正确接收和存储。</p></li><li><p><strong>数据格式化与回调</strong>：云端平台将硬件设备上传的数据格式化，并根据配置将数据回调到指定的 URL，即软件系统的 API 接口。</p></li><li><p><strong>消息转发</strong>：云端平台通过 MQTT 或 HTTP 协议将数据推送给软件系统。</p><p><strong>示例流程</strong>：</p><ul><li>硬件上传的数据到达云端，云端会对数据进行格式化处理。</li><li>云端通过 HTTP 回调，将数据发送至软件系统的 API 接口。</li></ul></li></ul><h4 id="（3）软件系统的数据接收和展示"><a href="#（3）软件系统的数据接收和展示" class="headerlink" title="（3）软件系统的数据接收和展示"></a>（3）软件系统的数据接收和展示</h4><ul><li><p><strong>技术组件</strong>：软件系统通常使用 Spring Boot 搭建，通过 REST API 接收来自云端的数据回调。</p></li><li><p><strong>数据存储</strong>：软件系统将数据存储到数据库（如 MySQL）中，便于统一管理和展示。</p></li><li><p><strong>数据展示</strong>：前端通过 AJAX 或 WebSocket 实时展示设备数据，提供用户界面。</p><p><strong>核心代码示例</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="symbol">code@</span>RestController</span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/api/devices&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeviceController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeviceService deviceService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收来自云端的数据回调</span></span><br><span class="line">    <span class="meta">@PostMapping(<span class="string">&quot;/data&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; receiveDeviceData(<span class="meta">@RequestBody</span> Map&lt;String, Object&gt; <span class="keyword">data</span>) &#123;</span><br><span class="line">        deviceService.processDeviceData(<span class="keyword">data</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Data received&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>@RestController</code></strong> 和 <strong><code>@RequestMapping</code></strong>：标识控制器并定义 API 路径。</li><li><strong><code>@PostMapping</code></strong> 和 <strong><code>@RequestBody</code></strong>：用于接收云端回调的设备数据。</li></ul><p><strong>Service 层代码</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="symbol">code@</span>Service</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeviceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeviceRepository deviceRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void processDeviceData(Map&lt;String, Object&gt; <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据解析</span></span><br><span class="line">        String deviceId = (String) <span class="keyword">data</span>.<span class="keyword">get</span>(<span class="string">&quot;device_id&quot;</span>);</span><br><span class="line">        <span class="built_in">Double</span> temperature = (<span class="built_in">Double</span>) <span class="keyword">data</span>.<span class="keyword">get</span>(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line">        <span class="built_in">Double</span> humidity = (<span class="built_in">Double</span>) <span class="keyword">data</span>.<span class="keyword">get</span>(<span class="string">&quot;humidity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        DeviceData deviceData = new DeviceData(deviceId, temperature, humidity);</span><br><span class="line">        deviceRepository.save(deviceData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）软件系统向硬件发送控制指令"><a href="#（4）软件系统向硬件发送控制指令" class="headerlink" title="（4）软件系统向硬件发送控制指令"></a>（4）软件系统向硬件发送控制指令</h4><ul><li><p><strong>前端控制界面</strong>：用户在前端界面点击控制按钮，触发控制指令的发送。</p></li><li><p><strong>后端处理控制请求</strong>：后端接收控制请求，生成控制指令并发送到云端。</p></li><li><p><strong>云端转发指令</strong>：云端平台将控制指令转发至硬件设备。</p></li><li><p><strong>硬件执行指令</strong>：硬件设备接收到指令后，执行相应操作（如开启或关闭设备）。</p><p><strong>示例代码（控制设备）</strong>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javaCopy</span> <span class="selector-tag">code</span>@<span class="selector-tag">RestController</span></span><br><span class="line">@<span class="selector-tag">RequestMapping</span>(<span class="string">&quot;/api/control&quot;</span>)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">ControlController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private CloudService cloudService;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@PostMapping</span>(<span class="string">&quot;/device/&#123;deviceId&#125;/command&quot;</span>)</span><br><span class="line">    public ResponseEntity&lt;String&gt; <span class="built_in">controlDevice</span>(<span class="variable">@PathVariable</span> String deviceId, <span class="variable">@RequestBody</span> Command command) &#123;</span><br><span class="line">        <span class="selector-tag">cloudService</span><span class="selector-class">.sendCommandToCloud</span>(deviceId, command);</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ResponseEntity</span><span class="selector-class">.ok</span>(<span class="string">&quot;Command sent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service 层代码（调用云端 API 发送指令）</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloudService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">sendCommandToCloud</span>(<span class="params"><span class="title class_">String</span> deviceId, <span class="title class_">Command</span> command</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用云端 API 发送控制指令</span></span><br><span class="line">        <span class="title class_">RestTemplate</span> restTemplate = <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="title class_">String</span> url = <span class="string">&quot;https://cloud-platform/api/sendCommand&quot;</span>;</span><br><span class="line">        <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        payload.<span class="title function_">put</span>(<span class="string">&quot;deviceId&quot;</span>, deviceId);</span><br><span class="line">        payload.<span class="title function_">put</span>(<span class="string">&quot;command&quot;</span>, command);</span><br><span class="line"></span><br><span class="line">        restTemplate.<span class="title function_">postForObject</span>(url, payload, <span class="title class_">String</span>.<span class="property">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用到的主要技术和组件"><a href="#用到的主要技术和组件" class="headerlink" title="用到的主要技术和组件"></a>用到的主要技术和组件</h3><ul><li><strong>MQTT 协议</strong>：用于硬件和云端的数据上传和控制指令传输。</li><li><strong>HTTP 回调和 REST API</strong>：用于云端与软件系统之间的数据交互。云端将数据回调到软件系统的 REST API，软件系统发送控制指令到云端的 API。</li><li><strong>Spring Boot 和 REST API</strong>：软件系统使用 Spring Boot 搭建，通过 REST API 接收数据并实现控制逻辑。</li><li><strong>数据库（MySQL）</strong>：用于软件系统存储设备数据，确保数据持久化和查询性能。</li><li><strong>前端技术（AJAX、WebSocket）</strong>：前端界面展示数据并进行控制，使用 AJAX 或 WebSocket 实现实时数据更新。</li></ul><h3 id="整体流程总结"><a href="#整体流程总结" class="headerlink" title="整体流程总结"></a>整体流程总结</h3><ol><li><strong>数据上传</strong>：硬件通过 MQTT 或 HTTP 将数据上传到云端。</li><li><strong>数据转发</strong>：云端平台接收硬件数据并回调给软件系统的 API 接口。</li><li><strong>数据存储和展示</strong>：软件系统接收到数据，存储到数据库，并展示在前端界面。</li><li><strong>控制指令发送</strong>：用户在前端界面操作，软件系统生成控制指令，通过云端转发至硬件。</li><li><strong>硬件执行指令</strong>：硬件设备执行控制指令，实现远程操作。</li></ol><p>这种设计实现了软件系统、硬件设备和云端的无缝集成，确保数据一致性，并通过云端实现数据的收发和设备的远程控制。</p><h1 id="用户登录-与鉴权"><a href="#用户登录-与鉴权" class="headerlink" title="用户登录 与鉴权"></a>用户登录 与鉴权</h1><p>在用户登录和鉴权的实现中，主要功能包括用户身份验证、角色权限校验、Token 生成与校验（如使用 JWT），并基于角色实现不同用户的访问控制。以下是实现流程、用到的技术细节、注解和组件说明。</p><h3 id="1-用户登录和鉴权角色校验的主要功能"><a href="#1-用户登录和鉴权角色校验的主要功能" class="headerlink" title="1. 用户登录和鉴权角色校验的主要功能"></a>1. 用户登录和鉴权角色校验的主要功能</h3><ul><li><strong>身份验证</strong>：在用户登录时验证用户名和密码，确保用户身份的合法性。</li><li><strong>Token 生成和校验</strong>：登录成功后生成 Token（如 JWT），用户在后续请求中携带 Token 以进行鉴权。</li><li><strong>角色和权限管理</strong>：为用户分配不同的角色（如 <code>ADMIN</code> 和 <code>USER</code>），控制不同角色用户的访问权限。</li><li><strong>访问控制</strong>：基于角色和权限的控制（RBAC），实现不同角色访问不同的资源。</li><li><strong>Session 或 Token 验证</strong>：确保用户在访问受保护资源时具有有效的会话或 Token。</li></ul><h3 id="2-实现流程"><a href="#2-实现流程" class="headerlink" title="2. 实现流程"></a>2. 实现流程</h3><h4 id="（1）用户登录流程"><a href="#（1）用户登录流程" class="headerlink" title="（1）用户登录流程"></a>（1）用户登录流程</h4><ol><li><strong>用户输入凭据</strong>：用户在客户端输入用户名和密码。</li><li><strong>服务器验证用户身份</strong>：后端接收用户名和密码，调用认证服务验证用户身份。</li><li><strong>生成 Token</strong>：身份验证成功后，服务器生成 JWT Token，包含用户 ID 和角色信息，并将 Token 返回给客户端。</li><li><strong>客户端存储 Token</strong>：客户端将 Token 存储在 <code>localStorage</code> 或 <code>sessionStorage</code> 中，以便后续请求携带 Token。</li></ol><h4 id="（2）请求鉴权流程"><a href="#（2）请求鉴权流程" class="headerlink" title="（2）请求鉴权流程"></a>（2）请求鉴权流程</h4><ol><li><strong>Token 校验</strong>：客户端在后续请求中将 Token 放入请求头的 <code>Authorization</code> 字段中，后端通过 JWT 过滤器解析并验证 Token。</li><li><strong>角色权限验证</strong>：后端解析 Token 获取用户角色，并根据角色控制访问权限。</li><li><strong>访问控制</strong>：只有符合角色和权限要求的用户可以访问受保护的资源。</li><li><strong>返回结果</strong>：如果校验成功，返回数据；如果校验失败，返回授权错误信息。</li></ol><h3 id="3-技术细节和组件说明-1"><a href="#3-技术细节和组件说明-1" class="headerlink" title="3. 技术细节和组件说明"></a>3. 技术细节和组件说明</h3><h4 id="使用到的技术和组件"><a href="#使用到的技术和组件" class="headerlink" title="使用到的技术和组件"></a>使用到的技术和组件</h4><ul><li><strong>Spring Security</strong>：用于实现安全性和权限控制，提供登录、会话管理和访问控制功能。</li><li><strong>JWT（JSON Web Token）</strong>：用于生成 Token，实现无状态的身份验证。</li><li><strong>BCrypt 密码加密</strong>：使用 <code>BCryptPasswordEncoder</code> 对用户密码进行加密存储，增强安全性。</li><li><strong><code>@PreAuthorize</code> 注解</strong>：用于在方法级别控制权限，实现基于角色的访问控制。</li></ul><h4 id="实现流程的具体步骤"><a href="#实现流程的具体步骤" class="headerlink" title="实现流程的具体步骤"></a>实现流程的具体步骤</h4><h5 id="Step-1-配置-Spring-Security"><a href="#Step-1-配置-Spring-Security" class="headerlink" title="Step 1: 配置 Spring Security"></a>Step 1: 配置 Spring Security</h5><p>在 Spring Security 配置类中禁用默认的会话管理，设置为无状态模式，并配置登录路径和角色访问控制。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .sessionManagement().sessionCreationPolicy(<span class="type">SessionCreationPolicy</span>.<span class="type">STATELESS</span>) <span class="comment">// 无状态</span></span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>).permitAll() <span class="comment">// 登录接口不需要认证</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// 管理员权限</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>) <span class="comment">// 普通用户权限</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .addFilterBefore(<span class="keyword">new</span> <span class="type">JwtAuthenticationFilter</span>(), <span class="type">UsernamePasswordAuthenticationFilter</span>.<span class="keyword">class</span>); <span class="comment">// JWT 过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">PasswordEncoder</span> passwordEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BCryptPasswordEncoder</span>(); <span class="comment">// 密码加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Step-2-实现用户登录接口"><a href="#Step-2-实现用户登录接口" class="headerlink" title="Step 2: 实现用户登录接口"></a>Step 2: 实现用户登录接口</h5><ul><li>用户登录接口用于接收用户名和密码，验证成功后生成 JWT。</li><li>验证通过后将 JWT 返回给客户端。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">AuthenticationManager</span> authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">JwtTokenProvider</span> jwtTokenProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">ResponseEntity</span>&lt;?&gt; <span class="title function_">authenticateUser</span>(<span class="params"><span class="meta">@RequestBody</span> <span class="title class_">LoginRequest</span> loginRequest</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户身份验证</span></span><br><span class="line">        <span class="title class_">Authentication</span> authentication = authenticationManager.<span class="title function_">authenticate</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                loginRequest.<span class="title function_">getUsername</span>(),</span><br><span class="line">                loginRequest.<span class="title function_">getPassword</span>()</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="title class_">SecurityContextHolder</span>.<span class="title function_">getContext</span>().<span class="title function_">setAuthentication</span>(authentication);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 JWT</span></span><br><span class="line">        <span class="title class_">String</span> jwt = jwtTokenProvider.<span class="title function_">generateToken</span>(authentication);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ResponseEntity</span>.<span class="title function_">ok</span>(<span class="keyword">new</span> <span class="title class_">JwtResponse</span>(jwt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Step-3-使用-JWT-实现-Token-生成和校验"><a href="#Step-3-使用-JWT-实现-Token-生成和校验" class="headerlink" title="Step 3: 使用 JWT 实现 Token 生成和校验"></a>Step 3: 使用 JWT 实现 Token 生成和校验</h5><ul><li><strong>生成 Token</strong>：在用户登录成功后，生成一个包含用户ID、角色等信息的 JWT，并使用服务器私钥进行签名。</li><li><strong>验证 Token</strong>：在每次请求时，JWT 过滤器从请求头中获取 Token 并验证其有效性。</li></ul><p><strong>JWT 生成类</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> jwtSecret = <span class="string">&quot;secretKey&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> int jwtExpirationInMs = <span class="number">86400000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">generateToken</span>(<span class="params"><span class="title class_">Authentication</span> authentication</span>) &#123;</span><br><span class="line">        <span class="title class_">UserPrincipal</span> userPrincipal = (<span class="title class_">UserPrincipal</span>) authentication.<span class="title function_">getPrincipal</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Jwts</span>.<span class="title function_">builder</span>()</span><br><span class="line">            .<span class="title function_">setSubject</span>(<span class="title class_">Long</span>.<span class="title function_">toString</span>(userPrincipal.<span class="title function_">getId</span>()))</span><br><span class="line">            .<span class="title function_">setIssuedAt</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">            .<span class="title function_">setExpiration</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + jwtExpirationInMs))</span><br><span class="line">            .<span class="title function_">signWith</span>(<span class="title class_">SignatureAlgorithm</span>.<span class="property">HS512</span>, jwtSecret)</span><br><span class="line">            .<span class="title function_">compact</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Long</span> <span class="title function_">getUserIdFromJWT</span>(<span class="params"><span class="title class_">String</span> token</span>) &#123;</span><br><span class="line">        <span class="title class_">Claims</span> claims = <span class="title class_">Jwts</span>.<span class="title function_">parser</span>()</span><br><span class="line">            .<span class="title function_">setSigningKey</span>(jwtSecret)</span><br><span class="line">            .<span class="title function_">parseClaimsJws</span>(token)</span><br><span class="line">            .<span class="title function_">getBody</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Long</span>.<span class="title function_">parseLong</span>(claims.<span class="title function_">getSubject</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">validateToken</span>(<span class="params"><span class="title class_">String</span> authToken</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title class_">Jwts</span>.<span class="title function_">parser</span>().<span class="title function_">setSigningKey</span>(jwtSecret).<span class="title function_">parseClaimsJws</span>(authToken);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Step-4-JWT-鉴权过滤器"><a href="#Step-4-JWT-鉴权过滤器" class="headerlink" title="Step 4: JWT 鉴权过滤器"></a>Step 4: JWT 鉴权过滤器</h5><p>使用 <code>JwtAuthenticationFilter</code> 过滤器，拦截每个请求，验证 Token 有效性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JwtTokenProvider</span> tokenProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CustomUserDetailsService</span> customUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doFilterInternal(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">FilterChain</span> filterChain)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">String</span> token = getJwtFromRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasText(token) &amp;&amp; tokenProvider.validateToken(token)) &#123;</span><br><span class="line">            <span class="type">Long</span> userId = tokenProvider.getUserIdFromJWT(token);</span><br><span class="line"></span><br><span class="line">            <span class="type">UserDetails</span> userDetails = customUserDetailsService.loadUserById(userId);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> authentication = <span class="keyword">new</span> <span class="type">UsernamePasswordAuthenticationToken</span>(userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">            authentication.setDetails(<span class="keyword">new</span> <span class="type">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line"></span><br><span class="line">            <span class="type">SecurityContextHolder</span>.getContext().setAuthentication(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> getJwtFromRequest(<span class="type">HttpServletRequest</span> request) &#123;</span><br><span class="line">        <span class="type">String</span> bearerToken = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Step-5-基于角色的访问控制"><a href="#Step-5-基于角色的访问控制" class="headerlink" title="Step 5: 基于角色的访问控制"></a>Step 5: 基于角色的访问控制</h5><p>使用 <code>@PreAuthorize</code> 注解实现方法级权限控制，确保不同角色用户只能访问特定资源。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="symbol">code@</span>RestController</span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/api&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(<span class="string">&quot;hasRole(&#x27;USER&#x27;)&quot;</span>)</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/user/dashboard&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String userDashboard() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User Dashboard&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;)&quot;</span>)</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/admin/dashboard&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String adminDashboard() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Admin Dashboard&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-用到的注解和组件"><a href="#4-用到的注解和组件" class="headerlink" title="4. 用到的注解和组件"></a>4. 用到的注解和组件</h3><ul><li><p>注解</p><p>：</p><ul><li><code>@RestController</code>：标记控制器类为 RESTful 风格。</li><li><code>@RequestMapping</code>：定义类或方法的请求路径。</li><li><code>@GetMapping</code> / <code>@PostMapping</code>：定义 HTTP 请求类型。</li><li><code>@PreAuthorize</code>：方法级别权限控制，根据用户角色允许或拒绝访问。</li><li><code>@Autowired</code>：自动注入 Spring 容器中的 Bean。</li></ul></li><li><p>组件</p><p>：</p><ul><li><strong>AuthenticationManager</strong>：Spring Security 组件，用于处理用户身份验证。</li><li><strong>JwtTokenProvider</strong>：自定义组件，负责生成和验证 JWT。</li><li><strong>JwtAuthenticationFilter</strong>：自定义过滤器，用于拦截请求和验证 Token。</li><li><strong>BCryptPasswordEncoder</strong>：Spring 提供的加密工具，用于加密用户密码。</li><li><strong>SecurityContextHolder</strong>：持有当前的用户信息，帮助进行鉴权。</li></ul></li></ul><h3 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h3><ol><li><strong>用户登录</strong>：客户端发送用户名和密码，服务器验证后生成 JWT 并返回。</li><li><strong>Token 验证</strong>：客户端请求时附带 JWT，后端通过 JWT 过滤器验证 Token。</li><li><strong>角色权限控制</strong>：后端根据用户角色控制不同接口的访问权限。</li><li><strong>返回结果</strong>：验证通过后返回数据，验证失败返回错误信息。</li></ol><p>这种设计实现了用户的登录鉴权、角色校验、Token 验证，并确保系统的安全性和灵活性。</p><blockquote><p>面试使用的工具<a href="https://juejin.cn/post/7166134446301642788#heading-33">15755字，解锁MySQL性能优化新姿势本文正在参加「技术专题19期 漫谈数据库技术」活动 0. 目录 1 MySQL - 掘金</a></p><p><img src="../assets/image-20241107095858200.png" alt="image-20241107095858200"></p></blockquote><p><strong>==细问实习，实习遇到的难点，做了什么==</strong></p><p>Redis用在哪、如何解决缓存三兄弟</p><ul><li>读写锁扩展、读写锁原理是什么、项目用在哪、为什么这里要加写锁，不用读写锁怎么解决</li></ul><ul><li>实习负责的内容是什么</li><li>开发团队是怎么分工的</li><li>实习遇到什么问题怎么去解决的</li></ul><h4 id="问实习"><a href="#问实习" class="headerlink" title="问实习"></a>问实习</h4><ul><li>介绍自己做的业务</li><li>上一段实习的公司框架和开源的 RPC 框架的区别</li><li>负责的业务与核心业务的依赖关系</li><li>场景题 -&gt; 设计高并发下的负载均衡</li></ul><h4 id="3-项目拷打"><a href="#3-项目拷打" class="headerlink" title="3. 项目拷打"></a>3. 项目拷打</h4><ul><li>手写 双检锁单例模式（项目中用到，让我现场写一个示例；有点小细节写错了![，但面试官说大差不差）</li><li>假设注册中心某个节点突然挂掉了，讲下之后的处理逻辑</li><li>解释项目中 Etcd 的心跳机制</li><li>注册中心和服务端怎么保持数据的一致性</li><li>为什么使用 ConcurrentHashMap 作为本地缓存</li><li>ConcurrentHashMap 底层的线程安全怎么实现的</li><li>系统中不同的重试策略是怎么选择和考虑的</li><li>一致性Hash 的实现</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/image-20241106090950823.png&quot; alt=&quot;image-20241106090950823&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/image-20241106091011068.png&quot; a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>bank_preparation</title>
    <link href="https://www.fomal.cc/posts/db7b1c8b.html"/>
    <id>https://www.fomal.cc/posts/db7b1c8b.html</id>
    <published>2024-11-04T10:03:22.000Z</published>
    <updated>2024-11-09T11:25:42.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="银行-amp-amp-国企运营商准备"><a href="#银行-amp-amp-国企运营商准备" class="headerlink" title="银行&amp;&amp;国企运营商准备"></a>银行&amp;&amp;国企运营商准备</h1><blockquote><p>11.5日 邮政储蓄银行面试准备</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextLong();</span><br><span class="line">            <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> scanner.nextLong();</span><br><span class="line">            <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextLong();</span><br><span class="line">            <span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> scanner.nextLong();</span><br><span class="line"></span><br><span class="line">            result.append(calculateMinCost(n, k, x, y)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(result);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calculateMinCost</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> k, <span class="type">long</span> x, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">1</span> &amp;&amp; n % k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 n 可以被 k 整除，计算分割的代价</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">divisionCost</span> <span class="operator">=</span> y;</span><br><span class="line">                cost += divisionCost;</span><br><span class="line">                n /= k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不能被 k 整除，批量减少到能被 k 整除的数值</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">remainder</span> <span class="operator">=</span> n % k;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">1</span> || remainder == <span class="number">0</span>) &#123;</span><br><span class="line">                    cost += (n - <span class="number">1</span>) * x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 批量减少 remainder 次，使 n 能够被 k 整除</span></span><br><span class="line">                    cost += remainder * x;</span><br><span class="line">                    n -= remainder;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程了解："><a href="#流程了解：" class="headerlink" title="流程了解："></a>流程了解：</h2><p>询问了朋友，大概是如下流程：</p><blockquote><p>先自我介绍，然后感觉他注重问你问什么选择银行工作，</p><p>五到十分钟总长，但可能需要进行等待前边的人结束</p><p>问的最多的是为啥选择银行这个岗位</p></blockquote><h2 id="国企的面试形式和流程"><a href="#国企的面试形式和流程" class="headerlink" title="国企的面试形式和流程"></a>国企的面试形式和流程</h2><h3 id="面试形式"><a href="#面试形式" class="headerlink" title="面试形式"></a>面试形式</h3><p><strong>半结构化面试：</strong>主要围绕自我介绍和简历进行提问，一般3 ~  5题，每人答题时间为6 ~12分钟，侧重考察考生的自我认知，实习经历，职业规划等等，部分岗位可能会问及专业问题，追问环节问题的设置往往围绕回答的内容，个人简历中的背景信息展开。</p><p><strong>无领导小组讨论面试：</strong>一般分为8~12人一组，面试时间40-60分钟左右，包含审题，个人陈述，自由讨论，总结陈词四个阶段。近年来辩论对抗的形式越来越多，部分分行会对讨论过程进行追问，或是让考生进行互评，邮储银行无领导小组讨论的题型包括开放类、两难类、多项选择及排序类、资源争夺类、操作类，其中以<strong>辩论对抗类</strong>选择排序类最为常见。</p><h3 id="邮储银行"><a href="#邮储银行" class="headerlink" title="邮储银行"></a>邮储银行</h3><p>3个面试考官，5个考生一组，一起进入面试考场进行答题，<strong>针对部分考生回答没重点，考官会反复追问，有点考场压力测试的情形</strong>。</p><p>　　（1）请做一分钟的自我介绍</p><p>　　（2）为什么报考邮储银行，你个人有什么优势？</p><p>　　（以上2个问题，每个考生都要回答的）</p><p>　　（3）报考岗位是什么？谈谈你认为这个岗位需要什么素养？</p><p>　　（4）银行岗位有业务营销和综合服务的类型，你更偏向哪一种，为什么？</p><p>　　（5）金融银行的工作都需要营销和加班，你怎么处理？</p><p>　　（6）请用三个词语来形容你的性格特征。</p><blockquote><p>这其中不仅仅包括当下所考虑的收入、稳定、离家远近、性格适合等现实因素，也会受自己未来的职业理想和单位发展情况的影响，应试者需要理性负责的选择自己的职业，而非三分钟热度，盲目跟风。</p><p> 表达内容要具体，展现对银行工作的了解和适应。很多应聘者阐述的理由过于笼统，比如谈到对单位的认识和了解，很多同学都会说发展前景好，但是具体的发展和前景却不能清晰的表述，无法展现对银行的深刻了解，以至于不具备说服力。</p></blockquote><p>示例（中行）</p><p>　　1.我的专业是会计学，我的专业方向主要就是在金融或者银行业，我也非常喜欢自己的专业，希望能够学以致用。</p><p>　　2.<a href="http://www.yinhangzhaopin.com/zgyhzp/">中国银行</a>的业务范围很广，包括投资、保险、航空租赁。而且旗下还有中银<a href="http://www.yinhangzhaopin.com/tag/xianggang_292_1.html">香港</a>，中银国际，中银保险等控股的金融机构;中国银行是一家国际化和多元化程度最高的公司，这也是我比较喜欢的地方，非常的专业和规范。而且有国际化视野，这是其他银行所不具备的。中国银行的品牌价值高达800多亿，排名第十。在全球1000家银行里面排名居于前列。我非常希望能在这个平台有所发展和进步。这也是我选择中国银行的原因。</p><p>　　3.从现实角度看，我们整个中国银行的晋升体系以及培养的系统非常完善。正是基于我对自己的了解和对中国银行的认识，所以我选择了中国银行。希望今后能加入中国银行工作，为中国银行贡献自己的一份力量。谢谢!</p><p>示例 汇总：</p><blockquote><p><a href="http://www.yinhangzhaopin.com/yhks/yhms/5/99885.html">银行面试经典题目及回答：为什么选择我们银行？_银行考试网</a></p><p>邮储独有：</p><ol><li><p>网点众多，是最多的银行，服务最好 <strong>说邮政储蓄银行独有的</strong>。比如邮储银行优势之一就是网点众多，全国有近4万个网点，是工行的两倍，中行的近三倍。是我国服务范围和服务能力最广的银行。</p><p>此外，邮储银行利率较其他五大行略有优势。</p></li><li><p>就要先表达想加入金融行业，因为认为国家持续发展的情况下，金融行业的发展前景会非常好，因此想加入金融行业。</p></li><li><p>然后说邮储银行依托中国邮政，有全国范围内覆盖最广的邮政网点，依托这个网点覆盖，加上国家大力发展乡村振兴，未来可以覆盖全国几乎所有人，发展潜力巨大。因此很想加入。</p><p>作者：吉老师求职咨询<br>链接：<a href="https://www.zhihu.com/question/531760001/answer/3180942923">https://www.zhihu.com/question/531760001/answer/3180942923</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></li></ol></blockquote><p>作者：offer先生<br>链接：<a href="https://www.zhihu.com/question/382312303/answer/3288152559">https://www.zhihu.com/question/382312303/answer/3288152559</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="为什么报考银行"><a href="#为什么报考银行" class="headerlink" title="为什么报考银行"></a>为什么报考银行</h4><p>问为什么报考银行是在测查考生的<a href="https://www.zhihu.com/search?q=求职动机&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A3283498746}">求职动机</a>，<strong>求职动机是指在一定需要的刺激下，直接推动个体进行求职活动以达到求职目的的内部心理活动。</strong></p><p>个人的求职目的与拟任岗位所能提供的条件相一致时，个体胜任该岗位工作并稳定地从事该工作的可能性较大。求职动机可分为两个层面，即现实性的需求动机和高尚的理想追求。</p><p>在表达自身求职动机时需要注意三个方面(1)有选择地表述自己的现实性需求。(2)不能仅谈现实性需求，还要与高尚的动机相结合。(3)动机表述不可过于抽象，融入真情实感。</p><h3 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a><strong>参考解析</strong></h3><p><strong>各位考官好，我选择邮政银行是因为以下几点原因：</strong></p><p><strong>第一，</strong>据我了解邮政银行有着完善员工成长的制度和培训体系，是值得托付理想的平台。而且贵行人才济济，能与优秀的人共事、交朋友，才更能促进我成长。我相信我在这样的平台工作一定会学到很多知识、积累经验、使自身能力得到很大提升。</p><p><strong>第二，</strong>这次所选的岗位离我家很近，方便我平衡家庭和工作，既拥有了心仪的工作又能很好的陪伴父母，这让我觉得很满足。</p><p><strong>第三，</strong>我学会计*年了，这期间让我对自己的专业产生了浓厚的兴趣，我也很热爱我的专业，渴望把自己的专业投入实践，创造社会价值。</p><p><strong>第四，</strong>从小我就有进入银行工作的理想，认为银行的工作是十分有价值的，希望各位考官能给这次机会，让我为邮政添砖加瓦。</p><p>银行想看的就是考生的求职动机以及考生的临场反应能力、语言表达能力等综合方面的能力。考生可以从求职动机方面入手，谈谈为什么加入邮储，比如工作地点离家较近，可以好好照顾父母。也可以在深入谈谈一些比较高大上的东西，比如自己的职业理想、发展道路等等。另一方面在说一下自己的优势，自己能为银行带来什么。</p><p>邮储面试常见问题：</p><p>我们为什么要录用你？</p><p>答：如”我符合贵公司的招聘条件，凭我目前掌握的技能、高度的责任感和良好的适应能力及学习能力 ，能胜任这份工作。我十分希望能为贵公司服务，如果贵公司给我这个机会，我一定能成为贵公司的栋梁！”</p><p>你希望与什么样的上级共事？</p><p>答：”做为刚步入社会新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。”</p><p>你有什么优势（责任心+写作特长+性格随和）</p><p>第一，我有较强的责任心，做事比较有耐性，而且比较勤奋，符合银行员工的职业要求。</p><p>第二，从专业上讲，经过本科和研究生期间的学习，虽然我的专业跟金融界相差甚远，但多年来积累的写作水平和文字处理能力是我认为自己能胜任这份工作的主要之一。最后，从性格上说，我比较随和，待人比较真诚，容易跟同事建立良好的人际关系。</p><p>作者：知乎用户IlcSJ7<br>链接：<a href="https://www.zhihu.com/question/382312303/answer/1103129618">https://www.zhihu.com/question/382312303/answer/1103129618</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="个人准备"><a href="#个人准备" class="headerlink" title="个人准备"></a>个人准备</h3><p><strong>专业不对口面试银行业务岗的回答思路：</strong></p><p><strong>1、</strong>虽然我不是经济金融专业的毕业生，但是我一直很向往加入金融领域的工作，并且具备较强的学习能力和钻研能力，在保障本专业课程学习的基础上，我还自学了xxx(书or课程or相关教学视频)，选修了金融专业的xx课程，通过了xx证书的考试，在学习这些知识的过程中，让我对于xxx有了一个基本的认识，也更加坚定了我职业选择的方向，我相信今后在职场中我也会继续保持心极学习的态度，并胜任我的工作。</p><p><strong>2、</strong>之前在xx银行/券商/保险/互联网金融等公司实习过x个月，在实习的过程中负责了xx(尽量说与银行有关的行业，比如个人金融、授信审批、风控等)，对于xx业务有一定的了解，经过不断的探索也更加坚定了进入银行的想法。</p><p><strong>3、</strong>我的性格和平时的做事风格是比较稳定细心的，与银行业的xx岗位很匹配，xx岗位更多的时候会跟金钱、数字打交道，我很喜欢这样规范严谨的工作氛围;</p><p><strong>4、</strong>银行的xx岗位作为银行产品和服务接触市场和客户的重要桥梁，需要具备较强的营销能力和协调能力，而我之前在学校期间组织过xx活动(拉到过多少赞助)，或者在之前的xx实习中担任xx，负责xx(最好是跟人打交代的工作)，这些经历在不断的锻炼我的沟通和组织能力，我也很喜欢从事金融服务行业的工作。</p><p><a href="https://zhuanlan.zhihu.com/p/631834570">银行面试被问“专业不对口，为什么想来银行？” - 知乎</a></p><p>个人介绍：</p><p><strong>面试官您好，我叫马增龙，24岁，来自山东济南，目前正在攻读计算机技术的硕士学位</strong> </p><p><strong>校内经历、实习经历和个人岗位匹配度</strong></p><p><strong>校内经历，我在校期期间成绩名列前茅，本科综合成绩10%，拥有保研资格，连续三年获得国家励志奖学金，曾多次获得优秀学生</strong></p><p><strong>读研期间扎根于科研，已发表一篇会议文章和专利，另有一篇期刊文章在投</strong></p><p>校内实践方面，任4年班长，获优秀班干部，优秀班集体等荣誉，也投身于实践，任山东建筑大学图书馆志愿者协会主席，多次组织和参与志愿活动。</p><p>实习经历上</p><p><strong>学而思科技教育公司</strong>  和一个<strong>远程实习</strong>   积累了丰富的实践经验</p><p>作为实习组长，管理300左右实习生  团队管理能力+与人交流协作能力。</p><p><strong>个人评价与岗位匹配</strong></p><p>个人善于与客户和组内人员交流沟通，服务能力 较强</p><p>大局观良好，抗压能力和适应能力能力强  </p><p>我热爱写博客，读研两年左右，我搭建个人博客写下将近44w字的个人技术博客，有很强的学习和动手能力；</p><p>相信以往的经历和实习经验能够助我积累与岗位相关的经验，并能够做好该岗位的工作，以上便是我的个人介绍，面试官还有什么其他问题~</p><ol><li>据我了解   中国邮政储蓄银行拥有优良的资产质量和显著的成长潜力，是中国领先的大型零售银行</li><li>邮政银行有着完善员工成长的制度和培训体系，是值得托付理想的平台。而且贵行人才济济，能与优秀的人共事、交朋友，才更能促进我成长。我相信我在这样的平台工作一定会学到很多知识、积累经验、使自身能力得到很大提升。</li><li>邮储银行利率较其他五大行略有优势。，邮储银行依托中国邮政，有全国范围内覆盖最广的邮政网点，依托这个网点覆盖，加上国家大力发展乡村振兴，未来可以覆盖全国几乎所有人，发展潜力巨大。网点众多，是最多的银行，服务最好  全国有近4万个网点，是工行的两倍，中行的近三倍。是我国服务范围和服务能力最广的银行。</li><li><p>出身农村，发现邮储 亲民惠民政策非常好，<strong>扎实服务乡村振兴</strong>    打造“三农”金融服务统一品牌，建设服务乡村振兴数字生态银行  别样的感情吧</p></li><li><p>个人</p><ol><li><p>职业发展个人兴趣——金融方向靠拢  </p><ol><li>入金融行业，因为认为国家持续发展的情况下，金融行业的发展前景会非常好，因此想加入金融行业。具备较强的学习能力和钻研能力，在保障本专业课程学习的基础上，看一些金融和经济学相关的书 《小岛经济学》《怪诞行为学》《魔鬼经济学》</li></ol></li><li><p>能力上 【服务能力】  与人交流沟通合作  +做好服务工作</p></li></ol></li></ol><p><strong>3、</strong>我的性格和平时的做事风格是比较稳定细心的，与银行业的xx岗位很匹配，xx岗位更多的时候会跟金钱、数字打交道，我很喜欢这样规范严谨的工作氛围;</p><p><strong>4、</strong>银行的xx岗位作为银行产品和服务接触市场和客户的重要桥梁，需要具备较强的营销能力和协调能力，而我之前在学校期间组织过xx活动(拉到过多少赞助)，或者在之前的xx实习中担任xx，负责xx(最好是跟人打交代的工作)，这些经历在不断的锻炼我的沟通和组织能力，我也很喜欢从事金融服务行业的工作。</p><p>2024年10月23日，中国邮政储蓄银行（邮储银行）正式宣布新一代公司业务核心系统的全面上线，这标志着其在公司金融服务领域的重要技术升级。根据邮储银行的消息，该系统在整体运行效率上提升了超过10倍，充分展示了其在智能化和数字化转型方面的努力。</p><h2 id="重点看"><a href="#重点看" class="headerlink" title="重点看"></a>重点看</h2><p><a href="https://www.zhihu.com/question/373716552/answers/updated">(99+ 封私信 / 55 条消息) 银行面试被问到「为什么选择我们银行」怎么回答比较好？ - 知乎</a></p><p><strong>第三个问题，为什么选择我们银行，而不是其他银行。</strong></p><p>这个问题就要回答谨慎了。</p><p>因为面试官是十分了解自己的银行和身处的银行系统，如果没说到点子上，那会非常尴尬。但是让一个还没入职的面试者去谈贵行与其他行的区别，这是一件非常困难的事情。那么如何解决呢？</p><p>程序锅给出如下建议：</p><p>1、研究指定银行的科技业务，谈一谈自己对贵行战略和文化的看法。</p><p>2、特别实用的一点，就找最近银行高层的讲话。去读一读领导对于金融科技的看法（这一招非常有效，因为国企就是领导走向，领导对于金融科技的看法，就是金融科技的未来状况）</p><p>3、找一找师哥师姐，了解内部状况。当然，也可以找我，哈哈。 最后，还有非常实用的一招。</p><p>作者：程序锅<br>链接：<a href="https://www.zhihu.com/question/373716552/answer/1920090623">https://www.zhihu.com/question/373716552/answer/1920090623</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>问题清单：</p><p><a href="https://zhuanlan.zhihu.com/p/667131633">银行面试技巧：为什么报考我们银行？ - 知乎</a></p><p>网友的回复</p><p><a href="https://zhidao.baidu.com/question/515551381.html">中国邮政储蓄银行面试 问： 为什么要选择在中国邮政储蓄银行工作? 我该怎么回答。 要有点新意的。。_百度知道</a></p><p>​    </p><blockquote><p>自我介绍</p><p>计算机相关 岗位契合 /能够做哪些贡献对于该岗位</p><p>有哪些要提升的点？</p></blockquote>]]></content>
    
    
    <summary type="html">国企&amp;&amp;银行运营商准备</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>STATE-OWNED—ENTERPRISES</title>
    <link href="https://www.fomal.cc/posts/4d73482b.html"/>
    <id>https://www.fomal.cc/posts/4d73482b.html</id>
    <published>2024-10-28T06:13:59.000Z</published>
    <updated>2024-11-04T09:48:04.702Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/353157994655457280?sourceSSR=search">秋招收到6家银行offer的一点经验_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/discuss/669874979206406144?sourceSSR=dynamic">秋招结束写一点自己的建议（关于国企银行）_牛客网 (nowcoder.com)</a></p><p>民生银行考试</p><p><a href="https://www.nowcoder.com/discuss/414928856946065408">中国民生银行2023秋招科技类笔试_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/325447d8caa1493898423e1c81ded764?sourceSSR=search">2024民生银行笔试考情分析+备考指南_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/5324f5751c7140b28c5f3541954b6714?sourceSSR=search">中国民生银行 笔试 科技类_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/5088dec94a3d4bcc9255078cf02cbf0d?sourceSSR=search">民生银行暑期夏令营_牛客网 (nowcoder.com)</a></p>]]></content>
    
    
    <summary type="html">央国企业经验积累</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>zhongkechuangda</title>
    <link href="https://www.fomal.cc/posts/133df845.html"/>
    <id>https://www.fomal.cc/posts/133df845.html</id>
    <published>2024-10-28T05:03:02.000Z</published>
    <updated>2024-11-04T09:48:04.705Z</updated>
    
    <content type="html"><![CDATA[<p>过往总结</p><p><a href="https://www.nowcoder.com/feed/main/detail/07b033630dd3436fb5d4a11a660a45cc?sourceSSR=search">中科创达面经 java_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/65938b1a952249f990e7160755e4c6e8?sourceSSR=search">中科创达（java转安卓）_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/discuss/658446441358098432?sourceSSR=search">面试记录01—中科创达_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/e79f00ec43294477aea43bfaed30a715?sourceSSR=search">8.20 中科创达群面 1.5h_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/feed/main/detail/5bd0d55dc5e84add971f05291e96c74a?sourceSSR=search">中科创达一面（秋招）_牛客网 (nowcoder.com)</a></p>]]></content>
    
    
    <summary type="html">中科创达面经</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>recruitment1</title>
    <link href="https://www.fomal.cc/posts/undefined.html"/>
    <id>https://www.fomal.cc/posts/undefined.html</id>
    <published>2024-10-17T07:20:57.000Z</published>
    <updated>2024-10-26T05:28:22.638Z</updated>
    
    <content type="html"><![CDATA[<p>9.3-10.17 秋招个人复盘总结</p><p>目标是 小厂的开发/ 测试，先找找本地或者自己地方的技术公司，能多拿点工资的那种</p><p>中厂/大厂的测试，能够去找一些比较大的平台</p><p>10.17- 10.20  （周四-周六） 全力投递 中大厂 </p><p>面试准备：</p><ol><li>了解公司（公司背调   做什么业务 岗位要求 匹配度） </li><li>用什么坑、什么自我介绍、什么面试技巧来应对</li><li>完善项目+八股</li></ol><p>10.21日实习面试复盘（聊天+技术面）</p><blockquote><p> 实习和后续转正的计划是什么？直接找工作or当下找实习，在去准备秋招呢？</p></blockquote><p>技术面</p><blockquote><p>最拿手的项目/实习</p><p><strong>==MQTT协议（topic  Payload ）==</strong></p><p>校验协议</p><p>==<strong>java中springboot的理解</strong>==</p><p>介绍一下你的算法相关的这个实习</p><p>==<strong>国产化  stgcn了解不足</strong>==</p><p>研究生最拿手的课程</p><p>个人的职业规划（实习 and 转正）</p><p>期望薪资</p><p>反问</p><ol><li>实习到岗时间和面试候选的后续安排<ol><li>中间可能有合适的人 就没有岗位了，如果觉得合适的话，就等到12月份去实习</li></ol></li><li>面试过程的建议（面评）<ol><li>整体还可以，但是少一些实践的经历，尤其涉及到疫情的话，少一些与公司和实际业务之间的交互</li><li>在介绍个人项目和价值的时候，只是从个人层面去讲解了，没有讲解为公司和业务组带来的价值，可以从整体去出发</li></ol></li><li>对于这个岗位的候选人的要求/ 期望的成绩、能力等<ol><li>轮流尝试，哪里能胜任就去做哪里，当然可能都能去做（如果本事够硬）</li></ol></li></ol><p>完善包装 这个前后端的项目（软硬端）——springboot—— 微服务项目</p><p>10.24日 中科创达【18：00-19:30】</p><p>10.24日 民生银行笔试【18:00-20.30】 能力测试【行测北森那一套+性格测试】+技术测试【20个单选+10个多选【技术开发/算法 二选一】】</p></blockquote><h4 id="关于软件考试的一些小门道"><a href="#关于软件考试的一些小门道" class="headerlink" title="关于软件考试的一些小门道"></a>关于软件考试的一些小门道</h4><p>防止切屏、防止投屏的软甲</p><blockquote><p>e考 软件{中国邮储银行、华夏银行等 都是用这个软件}</p></blockquote><p><a href="https://blog.csdn.net/sinat_23971513/article/details/108793786">易考——连接多个显示器解决办法_eztest 绕过屏幕检测-CSDN博客</a></p><p><a href="https://www.bilibili.com/read/cv28425368/">LockdownBroswer下远程连接的解决方案 - 哔哩哔哩 (bilibili.com)</a></p><blockquote><p>有的检测系统是检测对应的软件进程，或者检测对应的软件、硬件的一些插口检测比如usb检测等，来保证整个软件的检测成功</p><p>所以对于作弊来说，可以利用对应的一些方式 跳过进程检测 或者跳过一些硬件检测</p><p>比如修改进程号 修改进程名称等</p><p><a href="https://www.zhihu.com/question/391574647">(99+ 封私信 / 53 条消息) 易考线上考试能操作吗？ - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;9.3-10.17 秋招个人复盘总结&lt;/p&gt;
&lt;p&gt;目标是 小厂的开发/ 测试，先找找本地或者自己地方的技术公司，能多拿点工资的那种&lt;/p&gt;
&lt;p&gt;中厂/大厂的测试，能够去找一些比较大的平台&lt;/p&gt;
&lt;p&gt;10.17- 10.20  （周四-周六） 全力投递 中大厂 &lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>System</title>
    <link href="https://www.fomal.cc/posts/undefined.html"/>
    <id>https://www.fomal.cc/posts/undefined.html</id>
    <published>2024-10-09T13:02:42.000Z</published>
    <updated>2024-10-09T13:02:42.809Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql_review</title>
    <link href="https://www.fomal.cc/posts/28b9223d.html"/>
    <id>https://www.fomal.cc/posts/28b9223d.html</id>
    <published>2024-10-04T10:35:23.000Z</published>
    <updated>2024-10-15T14:27:55.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql面试题"><a href="#Mysql面试题" class="headerlink" title="Mysql面试题"></a>Mysql面试题</h1><p>[toc]</p><h2 id="一-Mysql索引"><a href="#一-Mysql索引" class="headerlink" title="一 Mysql索引"></a>一 Mysql索引</h2><h3 id="001-Mysql如何实现的索引机制？"><a href="#001-Mysql如何实现的索引机制？" class="headerlink" title="001 Mysql如何实现的索引机制？"></a>001 Mysql如何实现的索引机制？</h3><p>MySQL中索引分三类：B+树索引、Hash索引、全文索引</p><h4 id="002-InnoDB索引与MyISAM索引实现的区别是什么？"><a href="#002-InnoDB索引与MyISAM索引实现的区别是什么？" class="headerlink" title="002 InnoDB索引与MyISAM索引实现的区别是什么？"></a>002 InnoDB索引与MyISAM索引实现的区别是什么？</h4><ul><li><p><code>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。</code></p><ul><li><p>在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引 。 </p></li><li><p>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。</p><ul><li>MyISAM的表在磁盘上存储在以下文件中：  <code>*.sdi（描述表结构）</code>、<code>*.MYD（数据）</code>，<code>*.MYI（索引）</code></li><li>InnoDB的表在磁盘上存储在以下文件中： <code>.ibd（表结构、索引和数据都存在一起）</code></li></ul></li><li><p>InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p></li><li>MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</li></ul><p><img src="./../assets/image-20220709183820796.png" alt="image-20220709183820796"></p></li></ul><h4 id="003-一个表中如果没有创建索引，那么还会创建B-树吗？"><a href="#003-一个表中如果没有创建索引，那么还会创建B-树吗？" class="headerlink" title="003 一个表中如果没有创建索引，那么还会创建B+树吗？"></a>003 一个表中如果没有创建索引，那么还会创建B+树吗？</h4><p>会</p><ul><li><p>如果有主键会创建聚簇索引</p></li><li><p>如果没有主键会生成rowid作为隐式主键</p></li></ul><h3 id="004-说一下B-树索引实现原理（数据结构）"><a href="#004-说一下B-树索引实现原理（数据结构）" class="headerlink" title="004 说一下B+树索引实现原理（数据结构）"></a>004 说一下B+树索引实现原理（数据结构）</h3><h4 id="讲义"><a href="#讲义" class="headerlink" title="讲义"></a>讲义</h4><p>假设有一个表index_demo，表中有2个INT类型的列，1个CHAR(1)类型的列，c1列为主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(c1 <span class="type">INT</span>,c2 <span class="type">INT</span>,c3 <span class="type">CHAR</span>(<span class="number">1</span>),<span class="keyword">PRIMARY</span> KEY(c1)) ;</span><br></pre></td></tr></table></figure><p>index_demo表的简化的行格式示意图如下：</p><p><img src="./../assets/image-20220709071051043.png" alt="image-20220709071051043"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type：</code>表示记录的类型， 0是普通记录、 2是最小记录、 3 是最大记录、1是B+树非叶子节点记录。</li><li><code>next_record：</code>表示下一条记录的相对位置，我们用箭头来表明下一条记录。</li><li><code>各个列的值：</code>这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 </li><li><code>其他信息：</code>除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将<code>其他信息</code>项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="./../assets/image-20220709071958145.png" alt="image-20220709071958145"></p><p>把一些记录放到页里的示意图就是（这里一页就是一个磁盘块，代表一次IO）：</p><p><img src="./../assets/image-20220709072138395.png" alt="image-20220709072138395"></p><p>name age sex</p><p><code>MySQL InnoDB的默认的页大小是16KB</code>，因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中的记录没有规律，我们就不得不依次遍历所有的数据页。<code>如果我们想快速的定位到需要查找的记录在哪些数据页中</code>，我们可以这样做 ：</p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</li><li>给所有的页建立目录项</li></ul><p><img src="./../assets/image-20220709073749310.png" alt="image-20220709073749310"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code> ，这个目录项中包含着该页的<code>页号28</code>以及该页中用户记录的<code>最小主键值 5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。<code>比如：查找主键值为 20 的记录，具体查找过程分两步：</code></p><ol><li>先从目录项中根据二分法快速确定出<code>主键值为20的记录在目录项3中</code>（因为 12 ≤ 20 &lt; 209 ），<code>对应页9</code>。 </li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code> 。 </p><h4 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h4><p>我们新分配一个编号为30的页来专门存储<code>目录项记录</code>，页10、28、9、20专门存储<code>用户记录</code>： </p><p><img src="./../assets/image-20220709074801215.png" alt="image-20220709073749310"></p><p><img src="./../assets/1557565-20220429110413866-1755798300.png" alt="img"></p><p><code>目录项记录和普通的用户记录的不同点：</code> </p><ul><li>目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，包含很多列，另外还有InnoDB自己添加的隐藏列。</li></ul><p><code>现在查找主键值为 20 的记录，具体查找过程分两步：</code></p><ol><li>先到页30中通过二分法快速定位到对应目录项，因为 12 ≤ 20 &lt; 209 ，就是页9。 </li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p><strong>更复杂的情况如下：</strong></p><p>我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <code>[1, 320)</code> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。<strong>这个数据结构，它的名称是 B+树 。</strong> </p><p><img src="./../assets/image-20220709080648851.png" alt="image-20220709080648851"></p><h4 id="005-聚簇索引与非聚簇索引b-树实现有什么区别？"><a href="#005-聚簇索引与非聚簇索引b-树实现有什么区别？" class="headerlink" title="005    聚簇索引与非聚簇索引b+树实现有什么区别？"></a>005    聚簇索引与非聚簇索引b+树实现有什么区别？</h4><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p><strong>特点：</strong></p><ul><li><p><code>索引和数据保存在同一个B+树中</code></p></li><li><p><code>页内的记录</code>是按照<code>主键</code>的大小顺序排成一个<code>单向链表</code> 。</p></li><li><code>页和页之间</code>也是根据页中记录的<code>主键</code>的大小顺序排成一个<code>双向链表</code> 。</li><li>非叶子节点存储的是记录的<code>主键+页号</code>。</li><li>叶子节点存储的是<code>完整的用户记录</code>。</li></ul><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于<code>数据都是紧密相连</code>，数据库可以从更少的数据块中提取数据，<code>节省了大量的IO操作</code> 。</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code>。</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<code>主键为不可更新</code>。</li></ul><p><strong>限制：</strong></p><ul><li>只有InnoDB引擎支持聚簇索引，<code>MyISAM不支持聚簇索引</code>。</li><li>由于数据的物理存储排序方式只能有一种，所以<code>每个MySQL的表只能有一个聚簇索引</code>。</li><li>如果没有为表定义主键，InnoDB会选择<code>非空的唯一索引列代替</code>。如果没有这样的列，InnoDB会<code>隐式的定义一个主键</code>作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇特性，InnoDB中表的<code>主键应选择有序的id</code>，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。</li></ul><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><p><strong>（二级索引、辅助索引）</strong></p><p><code>聚簇索引</code>，只能在搜索条件是<code>主键值</code>时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建<code>非聚簇索引</code>。</p><p><strong>例如，</strong><code>以c2列作为搜索条件</code>，那么需要使<code>用c2列创建一棵B+树</code>，如下所示：</p><p><img src="./../assets/image-20220709130937991.png" alt="image-20220709130937991"></p><p><strong>这个B+树与聚簇索引有几处不同：</strong></p><ul><li><code>页内的记录</code>是按照从<code>c2列</code>的大小顺序排成一个<code>单向链表</code> 。</li><li><p><code>页和页之间</code>也是根据页中记录的<code>c2列</code>的大小顺序排成一个<code>双向链表</code> 。</p></li><li><p>非叶子节点存储的是记录的<code>c2列+页号</code>。</p></li><li>叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</li></ul><p><strong>一张表可以有多个非聚簇索引：</strong></p><p><img src="./../assets/image-20220709134109900-16668534893372.png" alt="image-20220709134109900"></p><h4 id="006-说一下B-树中聚簇索引的查找（匹配）逻辑"><a href="#006-说一下B-树中聚簇索引的查找（匹配）逻辑" class="headerlink" title="006    说一下B+树中聚簇索引的查找（匹配）逻辑"></a>006    说一下B+树中聚簇索引的查找（匹配）逻辑</h4><p><img src="./../assets/image-20220709080648851.png" alt="image-20220709080648851"></p><h4 id="007-说一下B-树中非聚簇索引的查找（匹配）逻辑"><a href="#007-说一下B-树中非聚簇索引的查找（匹配）逻辑" class="headerlink" title="007    说一下B+树中非聚簇索引的查找（匹配）逻辑"></a>007    说一下B+树中非聚簇索引的查找（匹配）逻辑</h4><p><strong>例如：</strong>根据c2列的值查找c2=4的记录，查找过程如下：</p><ol><li>根据<code>根页面44</code>定位到<code>页42</code>（因为<code>2 ≤  4 &lt; 9</code>）</li><li>由于<code>c2列没有唯一性约束</code>，所以c2=4的记录可能分布在多个数据页中，又因为 <code>2 ≤ 4  ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34和页35</code>中。</li><li>在页34和35中<code>定位到具体的记录</code>。</li><li>但是这个B+树的叶子节点<code>只存储了c2和c1（主键）</code>两个列，所以我们必须<code>再根据主键值去聚簇索引中再查找</code>一遍完整的用户记录。</li><li>like 张%</li></ol><p><img src="./../assets/image-20220709130937991.png" alt="image-20220709130937991"></p><h4 id="008-平衡二叉树，红黑树，B树和B-树的区别是什么？都有哪些应用场景？"><a href="#008-平衡二叉树，红黑树，B树和B-树的区别是什么？都有哪些应用场景？" class="headerlink" title="008    平衡二叉树，红黑树，B树和B+树的区别是什么？都有哪些应用场景？"></a>008    平衡二叉树，红黑树，B树和B+树的区别是什么？都有哪些应用场景？</h4><p>平衡二叉树</p><ul><li>基础数据结构</li><li>左右平衡</li><li>高度差大于1会自旋</li><li>每个节点记录一个数据</li></ul><p><strong>平衡二叉树（AVL）</strong></p><p>AVL树全称G.M. Adelson-Velsky和E.M. Landis，这是两个人的人名。</p><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</p><p><code>具有以下特点：</code></p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</li><li>并且左右两个子树都是一棵平衡二叉树。</li></ul><p><img src="./../assets/image-20220708235509010.png" alt="image-20220708235509010"></p><p>AVL的生成演示：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a></p><p><strong>AVL的问题</strong></p><p>众所周知，IO操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐节点加载（一个节点一次IO）。如果我们利用二叉树作为索引结构，<code>那么磁盘的IO次数和索引树的高度是相关的</code>。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p><p><img src="./../assets/image-20220708233351509.png" alt="image-20220708233351509"></p><p>为了提高查询效率，就需要 减少磁盘IO数 。<code>为了减少磁盘IO的次数，就需要尽量降低树的高度</code> ，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三叉树：</p><p><img src="./../assets/image-20220708235725124.png" alt="image-20220708235725124"></p><p>上面的例子中，我们将二叉树变成了三叉树，降低了树的高度。如果能够在一个节点中存放更多的数据，我们还可以进一步减少节点的数量，从而进一步降低树的高度。这就是<code>多叉树</code>。</p><p><strong>普通树的问题</strong></p><ul><li>左子树全部为空，从形式上看，更像一个单链表，不能发挥BST的优势。</li><li><code>解决方案：平衡二叉树(AVL)</code> </li></ul><p><img src="./../assets/image-20220708231622916.png" alt="image-20220708231622916"></p><p>红黑树</p><ul><li>hashmap存储</li><li>两次旋转达到平衡</li><li>分为红黑节点</li></ul><p>在这个棵严格的平台树上又进化为“红黑树”{是一个非严格的平衡树 左子树与右子树的高度差不能超过1}，红黑树的长子树只要不超过短子树的两倍即可！</p><p><img src="./../assets/image-20221027154142690.png" alt="image-20221027154142690"></p><p>当再次插入7的时候，这棵树就会发生旋转</p><p><img src="./../assets/image-20221027154120483.png" alt="image-20221027154120483"></p><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ul><li>B+树中非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大值（或最小）。</li><li>B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中， 非叶子节点既保存索引，也保存数据记录 。 </li><li>B+树中所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ul><h4 id="009-一个b-树中大概能存放多少条索引记录？"><a href="#009-一个b-树中大概能存放多少条索引记录？" class="headerlink" title="009    一个b+树中大概能存放多少条索引记录？"></a>009    一个b+树中大概能存放多少条索引记录？</h4><ul><li><code>真实环境</code>中一个页存放的记录数量是非常大的（默认16KB），假设指针与键值忽略不计（或看做10个字节），数据占 1 kb 的空间：</li><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 16 条记录。</li><li>如果B+树有2层，最多能存放 <code>1600×16=25600</code> 条记录。</li><li>如果B+树有3层，最多能存放 <code>1600×1600×16=40960000</code> 条记录。</li><li>如果存储千万级别的数据，只需要三层就够了</li></ul><p><code>B+树的非叶子节点不存储用户记录，只存储目录记录，相对B树每个节点可以存储更多的记录，树的高度会更矮胖，IO次数也会更少。</code></p><h4 id="010-使用B-树存储的索引crud执行效率如何？"><a href="#010-使用B-树存储的索引crud执行效率如何？" class="headerlink" title="010    使用B+树存储的索引crud执行效率如何？"></a>010    使用B+树存储的索引crud执行效率如何？</h4><p>c 新增</p><p>O(lognN)</p><p>N = 高度</p><h4 id="011-什么是自适应哈希索引？"><a href="#011-什么是自适应哈希索引？" class="headerlink" title="011    什么是自适应哈希索引？"></a>011    什么是自适应哈希索引？</h4><p>自适应哈希索引是Innodb引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree所有之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置</p><p>使用命令</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS \G <span class="comment">;</span></span><br></pre></td></tr></table></figure><p>查看INSERT BUFFER AND ADAPTIVE HASH INDEX</p><h4 id="012-什么是2-3树-2-3-4树？"><a href="#012-什么是2-3树-2-3-4树？" class="headerlink" title="012    什么是2-3树 2-3-4树？"></a>012    什么是2-3树 2-3-4树？</h4><p>多叉树（multiway tree）允许<code>每个节点可以有更多的数据项和更多的子节点</code>。2-3树，2-3-4树就是多叉树，多叉树通过<code>重新组织节点，减少节点数量，增加分叉，减少树的高度</code>，能对二叉树进行优化。</p><p><strong>2-3树</strong></p><p>下面2-3树就是一颗多叉树</p><p><img src="./../assets/image-20220709002223882.png" alt="image-20220709002223882"></p><p>2-3树具有如下特点：</p><ul><li>2-3树的所有叶子节点都在同一层。</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</li><li>2-3树是由二节点和三节点构成的树。</li><li>对于三节点的子树的值大小仍然遵守 BST 二叉排序树的规则。</li></ul><p><img src="./../assets/image-20220709002554341.png" alt="image-20220709002554341"></p><p><strong>2-3-4树</strong></p><p><img src="./../assets/image-20220709004531952.png" alt="image-20220709004531952"></p><h3 id="013-为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）"><a href="#013-为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）" class="headerlink" title="013 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）"></a>013 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）</h3><ul><li>自增主键能够维持底层数据顺序写入</li><li>读取可以由b+树的二分查找定位</li><li>支持范围查找，范围数据自带顺序</li></ul><p>字符串无法完成以上操作</p><h4 id="014-使用int自增主键后-最大id是10，删除id-10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？"><a href="#014-使用int自增主键后-最大id是10，删除id-10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？" class="headerlink" title="014 使用int自增主键后 最大id是10，删除id 10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？"></a>014 使用int自增主键后 最大id是10，删除id 10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？</h4><p>删除之后</p><ul><li>如果重启，会从最大的id开始递增</li><li>如果没重启，会延续删除之前最大的id开始递增</li></ul><h3 id="015-索引的优缺点是什么？"><a href="#015-索引的优缺点是什么？" class="headerlink" title="015 索引的优缺点是什么？"></a>015 索引的优缺点是什么？</h3><p><strong>优点</strong></p><p>聚簇（主键）索引：</p><ul><li>顺序读写</li><li>范围快速查找</li><li>范围查找自带顺序</li></ul><p>非聚簇索引：</p><ul><li>条件查询避免全表扫描scan</li><li>范围，排序，分组查询返回行id，排序分组后，再回表查询完整数据，有可能利用顺序读写</li><li>覆盖索引不需要回表操作</li></ul><p><strong>索引的代价</strong></p><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，<code>每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间</code>，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p><code>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引</code>。而增、删、改操作可能会对节点和记录的排序造成破坏<code>，所以存储引擎需要额外的时间进行一些记录移位、页面分裂、页面回收等操作来维护好节点和记录的排序。</code>如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><p>B 树和 B+ 树都可以作为索引的数据结构，<strong>在 MySQL 中采用的是 B+ 树。</strong></p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p><h4 id="016-使用索引一定能提升效率吗？"><a href="#016-使用索引一定能提升效率吗？" class="headerlink" title="016    使用索引一定能提升效率吗？"></a>016    使用索引一定能提升效率吗？</h4><p>不一定</p><ul><li>少量数据全表扫描也很快，可以直接获取到全量数据</li><li>唯一索引会影响插入速度，但建议使用</li><li>索引过多会影响更新，插入，删除数据速度</li></ul><h4 id="017-如果是大段文本内容，如何创建（优化）索引？"><a href="#017-如果是大段文本内容，如何创建（优化）索引？" class="headerlink" title="017    如果是大段文本内容，如何创建（优化）索引？"></a>017    如果是大段文本内容，如何创建（优化）索引？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">B</span> 树和 <span class="selector-tag">B</span>+ 树都可以作为     索引的数据结构，**在 MySQL 中采用的是 <span class="selector-tag">B</span>+ 树。**</span><br></pre></td></tr></table></figure><p>第一种方式是分表存储，然后创建索引</p><p>第二是使用es为大文本创建索引</p><h3 id="018-什么是聚簇索引？"><a href="#018-什么是聚簇索引？" class="headerlink" title="018 什么是聚簇索引？"></a>018 什么是聚簇索引？</h3><p>聚簇索引数据和索引存放在一起组成一个b+树</p><p>参考005题</p><h4 id="019-一个表中可以有多个（非）聚簇索引吗？"><a href="#019-一个表中可以有多个（非）聚簇索引吗？" class="headerlink" title="019    一个表中可以有多个（非）聚簇索引吗？"></a>019    一个表中可以有多个（非）聚簇索引吗？</h4><p>聚簇索引只能有一个</p><p>非聚簇索引可以有多个</p><h4 id="020-聚簇索引与非聚集索引的特点是什么？"><a href="#020-聚簇索引与非聚集索引的特点是什么？" class="headerlink" title="020    聚簇索引与非聚集索引的特点是什么？"></a>020    聚簇索引与非聚集索引的特点是什么？</h4><p>参考005题</p><h4 id="021-CRUD时聚簇索引与非聚簇索引的区别是什么？"><a href="#021-CRUD时聚簇索引与非聚簇索引的区别是什么？" class="headerlink" title="021    CRUD时聚簇索引与非聚簇索引的区别是什么？"></a>021    CRUD时聚簇索引与非聚簇索引的区别是什么？</h4><ul><li>聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复</li><li>聚簇索引范围，排序查找效率高，因为是有序的</li><li>非聚簇索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h4 id="022-非聚簇索引为什么不存数据地址值而存储主键？"><a href="#022-非聚簇索引为什么不存数据地址值而存储主键？" class="headerlink" title="==022 非聚簇索引为什么不存数据地址值而存储主键？=="></a>==022 非聚簇索引为什么不存数据地址值而存储主键？==</h4><p>因为聚簇索引中有时会引发分页操作、重排操作数据有可能会移动</p><blockquote><p>数据的地址会变，主键不会变</p></blockquote><h3 id="023-什么是回表操作？"><a href="#023-什么是回表操作？" class="headerlink" title="023 什么是回表操作？"></a>023 什么是回表操作？</h3><p>id age name sex</p><p>age -&gt; index</p><p>select * from user where age &gt;20 ;</p><p>第一次 取回id，第二次（回表）根据id拿到完整数据</p><p>select * from user where age &gt;20 ;</p><h4 id="024-什么是覆盖索引？"><a href="#024-什么是覆盖索引？" class="headerlink" title="024    什么是覆盖索引？"></a>024    什么是覆盖索引？</h4><p>id age name sex</p><p>age -&gt; index</p><p>select * from user where age &gt;20 ;</p><p>第一次 取回id，第二次（回表）根据id拿到完整数据</p><p>age,name -&gt; index</p><p>select age from user where age &gt;20 and name like”张%” ;</p><p>覆盖索引不会回表查询，查询效率也是比较高的</p><h4 id="025-非聚集索引一定回表查询吗"><a href="#025-非聚集索引一定回表查询吗" class="headerlink" title="025    非聚集索引一定回表查询吗?"></a>025    非聚集索引一定回表查询吗?</h4><p>不一定，只要b+树中包含的字段（创建索引的字段），覆盖（包含）想要select 的字段，那么就不会回表查询了。</p><h4 id="026-为什么要回表查询？直接存储数据不可以吗？"><a href="#026-为什么要回表查询？直接存储数据不可以吗？" class="headerlink" title="026    为什么要回表查询？直接存储数据不可以吗？"></a>026    为什么要回表查询？直接存储数据不可以吗？</h4><p>为了控制非聚簇索引的大小</p><h4 id="027-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#027-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="027    如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>027    如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>不是，InnoDB会生成rowid辅助回表查询</p><h3 id="028-什么是联合索引，组合索引，复合索引？"><a href="#028-什么是联合索引，组合索引，复合索引？" class="headerlink" title="==028 什么是联合索引，组合索引，复合索引？=="></a>==028 什么是联合索引，组合索引，复合索引？==</h3><blockquote><p>三者是一个东西，都是指的是复合索引</p></blockquote><p><code>为c2和c3列建立联合索引，</code>如下所示：</p><p>c2，c3 - &gt; index</p><p>c3,c2 -&gt; index</p><p>where c3=? </p><p>全职匹配[where条件顺序可以变，这里讲错了]【where 后面的顺序无关 而是看能不能匹配上最左原则就行】</p><p>最左前缀</p><p><img src="./../assets/image-20220712002627554.png" alt="image-20220712002627554"></p><h4 id="029-复合索引创建时字段顺序不一样使用效果一样吗？"><a href="#029-复合索引创建时字段顺序不一样使用效果一样吗？" class="headerlink" title="029 复合索引创建时字段顺序不一样使用效果一样吗？"></a>029 复合索引创建时字段顺序不一样使用效果一样吗？</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 <code>c2和c3列</code> 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li><li>B+树叶子节点处的记录由<code>c2列、c3列和主键c1列组成</code></li><li>本质上也是二级索引</li></ul><p><code>create index idx_c2_c3 on user (c2,c3);</code></p><h3 id="030-什么是唯一索引？"><a href="#030-什么是唯一索引？" class="headerlink" title="030 什么是唯一索引？"></a>030 什么是唯一索引？</h3><ul><li>随表一起创建索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    </span><br><span class="line">  id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id), <span class="comment">-- 主键索引：列设定为主键后会自动建立索引，唯一且不能为空。</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX uk_no (customer_no), <span class="comment">-- 唯一索引：索引列值必须唯一，允许有NULL值，且NULL可能会出现多次。</span></span><br><span class="line">  KEY idx_name (customer_name), <span class="comment">-- 普通索引：既不是主键，列值也不需要唯一，单纯的为了提高查询速度而创建。</span></span><br><span class="line">  KEY idx_no_name (customer_no,customer_name) <span class="comment">-- 复合索引：即一个索引包含多个列。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>单独建创索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer1 (</span><br><span class="line">  id <span class="type">INT</span> UNSIGNED,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer1 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY customer1(id); <span class="comment">-- 主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_no <span class="keyword">ON</span> customer1(customer_no); <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> customer1(customer_name);  <span class="comment">-- 普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_no_name <span class="keyword">ON</span> customer1(customer_no,customer_name); <span class="comment">-- 复合索引</span></span><br></pre></td></tr></table></figure><h4 id="031-唯一索引是否影响性能？"><a href="#031-唯一索引是否影响性能？" class="headerlink" title="031 唯一索引是否影响性能？"></a>031 唯一索引是否影响性能？</h4><p>是</p><h4 id="032-什么时候使用唯一索引？"><a href="#032-什么时候使用唯一索引？" class="headerlink" title="==032 什么时候使用唯一索引？=="></a>==032 什么时候使用唯一索引？==</h4><p>业务需求唯一字段的时候，一般不考虑性能问题</p><p>. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p><p><img src="../assets/image-20241005103928176.png" alt="image-20241005103928176"></p><h3 id="033-什么时候适合创建索引，什么时候不适合创建索引？"><a href="#033-什么时候适合创建索引，什么时候不适合创建索引？" class="headerlink" title="==033 什么时候适合创建索引，什么时候不适合创建索引？=="></a>==033 什么时候适合创建索引，什么时候不适合创建索引？==</h3><p>适合创建索引</p><ul><li><p>频繁作为where条件语句查询字段</p></li><li><p>关联字段需要建立索引</p></li><li><p>排序字段可以建立索引</p></li><li><p>分组字段可以建立索引(因为分组前提是排序)</p></li><li><p>统计字段可以建立索引（如.count(),max()）</p></li></ul><p>不适合创建索引</p><ul><li><p>频繁更新的字段不适合建立索引</p></li><li><p>where，分组，排序中用不到的字段不必要建立索引</p></li><li><p>可以确定表数据非常少不需要建立索引</p></li><li><p>参与mysql函数计算的列不适合建索引</p></li></ul><p>创建索引时避免有如下极端误解：</p><p> 1）宁滥勿缺。认为一个查询就需要建一个索引。 </p><p>2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 </p><p>3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p><h3 id="034-什么是索引下推？"><a href="#034-什么是索引下推？" class="headerlink" title="034 什么是索引下推？"></a>034 什么是索引下推？</h3><p>5.6之前的版本是没有索引下推这个优化的</p><p><strong>Using index condition：</strong>叫作  <code>Index Condition Pushdown Optimization （索引下推优化）</code></p><ul><li><code>如果没有索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给server层，server层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 &gt; &#39;z&#39; AND content1 LIKE &#39;%a&#39;</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给server层。</li></ul><p>总结：</p><p>未开启索引下推：</p><ul><li>根据筛选条件在索引树中筛选第一个条件</li><li>获得结果集后回表操作</li><li>进行其他条件筛选</li><li>再次回表查询</li></ul><p>开启索引下推：在条件查询时，当前索引树如果满足全部筛选条件，可以在当前树中完成全部筛选过滤，得到比较小的结果集再进行回表操作</p><h3 id="035-有哪些情况会导致索引失效？"><a href="#035-有哪些情况会导致索引失效？" class="headerlink" title="==035 有哪些情况会导致索引失效？=="></a>==035 有哪些情况会导致索引失效？==</h3><ul><li>计算、函数导致索引失效</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示查询分析</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name  <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> LEFT(emp.name,<span class="number">3</span>) = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>LIKE以%——通配符<em>， </em> (占位符)开头索引失效</li></ul><blockquote><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><p> 其实也是可以的，<strong>可以走全索引扫描index</strong>，不一定是走all。想了解的可以去看小林coding的mysql篇</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="type">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>不等于(!= 或者&lt;&gt;)索引失效</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name = <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name &lt;&gt; <span class="string">&#x27;abc&#x27;</span> ; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><p><code>&lt;&gt;</code>不等于  </p><p>&lt; /  &gt;  大于 或者小于 也都会导致后边的索引失效</p><blockquote><p>上边是一定失效的，而下边是有可能失效</p></blockquote><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span></span><br><span class="line"><span class="comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><ul><li>类型转换导致索引失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="number">123</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>复合索引未用左列字段失效——左值没用上 不会走索引</li><li>如果mysql觉得全表扫描更快时（数据少）;</li></ul><h4 id="036-为什么LIKE以-开头索引会失效？"><a href="#036-为什么LIKE以-开头索引会失效？" class="headerlink" title="==036  为什么LIKE以%开头索引会失效？=="></a>==036  为什么LIKE以%开头索引会失效？==</h4><blockquote><p>有可能失效 有可能不失效</p></blockquote><p>id,name,age</p><p>name 创建索引</p><p>select *  from user where  name like ‘%明’</p><p>type=all</p><p>select name,id  from user where  name like ‘%明’</p><p>type=index【使用覆盖索引  ——name覆盖索引】</p><p>张明</p><p>(name,age)</p><p>其实并不会完全失效，覆盖索引下会出现type=index，表示遍历了索引树，再回表查询，</p><p>如果是找对应的name id 的话 是不会回表查询了，因为符合索引中已经覆盖到了 </p><p>覆盖索引没有生效的时会直接type=all</p><p>没有高效使用索引是因为字符串索引会逐个转换成accii码，生成b+树时按首个字符串顺序排序，类似复合索引未用左列字段失效一样，跳过开始部分也就无法使用生成的b+树了</p><h3 id="037-一个表有多个索引的时候，能否手动选择使用哪个索引？"><a href="#037-一个表有多个索引的时候，能否手动选择使用哪个索引？" class="headerlink" title="037  一个表有多个索引的时候，能否手动选择使用哪个索引？"></a>037  一个表有多个索引的时候，能否手动选择使用哪个索引？</h3><p>不可用手动直接干预，只能通过mysql优化器自动选择</p><p>==可以使用FORCE INDEX或USE INDEX强制使用索引==</p><h4 id="038-如何查看一个表的索引？"><a href="#038-如何查看一个表的索引？" class="headerlink" title="==038      如何查看一个表的索引？=="></a>==038      如何查看一个表的索引？==</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show <span class="keyword">index</span> <span class="keyword">from</span> t_emp; <span class="comment">// 显示表上的索引</span></span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> t_emp <span class="keyword">where</span> id=<span class="number">1</span>; <span class="comment">// 显示可能会用到的索引及最终使用的索引</span></span><br></pre></td></tr></table></figure><p><img src="../assets/image-20241005171459612.png" alt="image-20241005171459612"></p><blockquote><p>展示索引</p></blockquote><p><img src="../assets/image-20241005171631993.png" alt="image-20241005171631993"></p><h4 id="039-能否查看到索引选择的逻辑？是否使用过optimizer-trace？"><a href="#039-能否查看到索引选择的逻辑？是否使用过optimizer-trace？" class="headerlink" title="==039      能否查看到索引选择的逻辑？是否使用过optimizer_trace？=="></a>==039      能否查看到索引选择的逻辑？是否使用过optimizer_trace？==</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>; <span class="comment">-- 打开优化器过程追踪</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE;</span><br><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=off&quot;;</span><br><span class="line"><span class="comment">-- 关掉优化器过程追踪</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>追踪查询优化器的选择过程追踪，可以使用上边命令进行打开，然后第二行进行展示其过程，用一个json文件展示出来</p></blockquote><p><img src="../assets/image-20241005171821747.png" alt="image-20241005171821747"></p><h4 id="040-多个索引优先级是如何匹配的？"><a href="#040-多个索引优先级是如何匹配的？" class="headerlink" title="040      ==多个索引优先级是如何匹配的？=="></a>040      ==多个索引优先级是如何匹配的？==</h4><ol><li>主键（唯一索引）匹配</li><li>全值匹配（单值匹配） index 匹配</li><li>最左前缀匹配</li><li>范围匹配</li><li>索引扫描</li><li>全表扫描</li></ol><p> 一般性建议(越精确的放前边，后边再放范围性的)</p><p>Ø 对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）</p><p>Ø 在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p><p>Ø 选择组合索引时，尽量包含where中更多字段的索引</p><p>Ø 组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面</p><p>Ø 尽量避免造成索引失效的情况</p><p>MySQL 优化器在执行查询时，会根据表的结构、索引的类型、查询条件等因素，选择不同的访问类型（Access Type）。访问类型决定了 MySQL 如何扫描表或索引，并在查询执行计划中使用哪种策略。不同的访问类型有不同的效率和适用场景。</p><h3 id="常见的-MySQL-访问类型"><a href="#常见的-MySQL-访问类型" class="headerlink" title="常见的 MySQL 访问类型"></a>常见的 MySQL 访问类型</h3><p>以下是 MySQL 优化器可选择的几种主要访问类型，从效率最低到最高排序：</p><ol><li><strong>ALL（全表扫描）</strong></li><li><strong>index（索引扫描）</strong></li><li><strong>range（范围扫描）</strong></li><li><strong>ref（索引等值查询）</strong></li><li><strong>eq_ref（唯一索引等值查询）</strong></li><li><strong>const（常量访问）</strong></li><li><strong>system（系统表访问）</strong></li></ol><p>让我们逐一分析这些访问类型及其适用条件。</p><h3 id="1-ALL（全表扫描）"><a href="#1-ALL（全表扫描）" class="headerlink" title="1. ALL（全表扫描）"></a>1. <strong>ALL（全表扫描）</strong></h3><p><strong>条件</strong>：当查询没有可用索引时，MySQL 会选择对整个表进行扫描。</p><ul><li><strong>适用场景</strong>：没有可用索引时，或者查询条件没有使用索引列，MySQL 必须扫描整个表来查找满足条件的行。</li><li><strong>效率</strong>：这是效率最低的一种访问方式，尤其是在表数据量较大的情况下。MySQL 需要逐行扫描表中的每一行，检查是否满足查询条件。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%phone%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>name</code> 列上没有可用的索引，或者 <code>LIKE &#39;%phone%&#39;</code> 的查询无法利用索引，MySQL 只能执行全表扫描。</li></ul><h3 id="2-index（索引扫描）"><a href="#2-index（索引扫描）" class="headerlink" title="2. index（索引扫描）"></a>2. <strong>index（索引扫描）</strong></h3><p><strong>条件</strong>：MySQL 通过扫描索引中的所有记录，而不是直接扫描数据表。虽然不像全表扫描那样直接扫描表，但仍需要逐个索引扫描。</p><ul><li><strong>适用场景</strong>：当查询的列涉及到某个索引，但查询不涉及过滤（即没有 <code>WHERE</code> 条件），例如只是用 <code>ORDER BY</code> 排序的情况。索引扫描比全表扫描效率略高，因为索引的 B+ 树结构更紧凑。</li><li><strong>效率</strong>：比 <code>ALL</code> 效率更高，但依然不理想，适合数据量较小的查询。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> product <span class="keyword">ORDER</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：即使没有 <code>WHERE</code> 条件，MySQL 也会通过 <code>name</code> 列上的索引扫描所有记录，并按照索引顺序返回结果。</li></ul><h3 id="3-range（范围扫描）"><a href="#3-range（范围扫描）" class="headerlink" title="3. range（范围扫描）"></a>3. <strong>range（范围扫描）</strong></h3><p><strong>条件</strong>：MySQL 可以通过索引查找特定范围内的记录，而不是扫描整个索引或表。常见的范围查询操作符有：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>BETWEEN</code>, <code>LIKE</code>（仅限前缀匹配）。</p><ul><li><strong>适用场景</strong>：当查询条件包含范围操作符，并且使用了索引列时，MySQL 会选择 <code>range</code> 访问类型。这种访问类型只需要扫描符合条件的部分索引，而不需要扫描整个索引。</li><li><strong>效率</strong>：比全表扫描或索引扫描更高效，因为它只扫描部分记录。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>id</code> 列上有索引，并且查询使用了 <code>id &gt; 100</code> 的范围条件，因此 MySQL 会使用 <code>range</code> 类型的索引扫描，只扫描满足条件的部分记录。</li></ul><h3 id="4-ref（非唯一索引的等值查询）"><a href="#4-ref（非唯一索引的等值查询）" class="headerlink" title="4. ref（非唯一索引的等值查询）"></a>4. <strong>ref（非唯一索引的等值查询）</strong></h3><p><strong>条件</strong>：MySQL 使用非唯一索引查找满足某个等值条件的所有记录。这种访问类型通常用于对<strong>非唯一索引</strong>或<strong>联合索引</strong>的等值查询。</p><ul><li><strong>适用场景</strong>：当 <code>WHERE</code> 子句中使用了索引列，并且该列上有多个重复值（例如普通索引），MySQL 会使用 <code>ref</code> 访问类型。查询结果可能会返回多条记录。</li><li><strong>效率</strong>：比 <code>range</code> 更高效，但仍然可能需要访问多个记录，适用于非唯一索引或联合索引的等值查询。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：假设 <code>category</code> 列上有索引，MySQL 会使用 <code>ref</code> 访问类型，因为 <code>category</code> 不是唯一索引，查询可能返回多条记录。</li></ul><h3 id="5-eq-ref（唯一索引的等值查询）"><a href="#5-eq-ref（唯一索引的等值查询）" class="headerlink" title="5. eq_ref（唯一索引的等值查询）"></a>5. <strong>eq_ref（唯一索引的等值查询）</strong></h3><p><strong>条件</strong>：MySQL 使用<strong>唯一索引</strong>进行等值查询。对于每个查询条件，MySQL 只会返回<strong>一条记录</strong>。<code>eq_ref</code> 是访问多表联合查询时最常用的类型之一。</p><ul><li><strong>适用场景</strong>：当 <code>WHERE</code> 子句使用了主键或唯一索引列的等值条件，并且这些列上有唯一约束（例如主键或 <code>UNIQUE</code> 索引），MySQL 会使用 <code>eq_ref</code> 访问类型。这种类型保证每次只返回一条记录。</li><li><strong>效率</strong>：非常高效，因为唯一索引能确保 MySQL 直接定位到一条唯一的记录。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>id</code> 是主键或唯一索引，查询条件是 <code>id = 1</code>，MySQL 会使用 <code>eq_ref</code> 访问类型，直接返回唯一记录。</li></ul><h3 id="6-const（常量访问）"><a href="#6-const（常量访问）" class="headerlink" title="6. const（常量访问）"></a>6. <strong>const（常量访问）</strong></h3><p><strong>条件</strong>：MySQL 在某些特定的查询中可以将表或结果视为常量，并直接将其作为查询的一部分。通常，<code>const</code> 类型用于<strong>主键或唯一索引的等值查询</strong>，并且表中的查询结果最多返回一条记录。</p><ul><li><strong>适用场景</strong>：如果查询中对主键或唯一索引进行了等值查询，并且结果集最多返回一条记录，MySQL 会选择 <code>const</code> 访问类型。这种类型的查询非常高效，几乎像查询一个常量一样简单。</li><li><strong>效率</strong>：这是 MySQL 查询中最快的一种访问方式，通常只需要一次索引查找即可返回结果。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>id</code> 是主键，并且查询条件是 <code>id = 1</code> 的等值查询，MySQL 可以将其视为常量，因此选择 <code>const</code> 访问类型。</li></ul><h3 id="7-system（系统表访问）"><a href="#7-system（系统表访问）" class="headerlink" title="7. system（系统表访问）"></a>7. <strong>system（系统表访问）</strong></h3><p><strong>条件</strong>：<code>system</code> 访问类型类似于 <code>const</code>，但是用于只有<strong>一行记录</strong>的系统表。在 MySQL 中，一些系统表只有一行记录，因此 MySQL 可以将其视为常量查询。</p><ul><li><strong>适用场景</strong>：当查询涉及到只有一行记录的系统表时，例如 <code>INFORMATION_SCHEMA</code> 或类似的表，MySQL 会使用 <code>system</code> 访问类型。</li><li><strong>效率</strong>：效率非常高，因为表只有一行记录，访问几乎没有成本。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> system_table;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>system_table</code> 只有一行记录，MySQL 将其视为系统常量，因此使用 <code>system</code> 访问类型。</li></ul><hr><h3 id="其他常见的访问类型"><a href="#其他常见的访问类型" class="headerlink" title="其他常见的访问类型"></a>其他常见的访问类型</h3><h4 id="8-ref-or-null"><a href="#8-ref-or-null" class="headerlink" title="8. ref_or_null"></a>8. <strong>ref_or_null</strong></h4><p><strong>条件</strong>：用于查询涉及索引列的等值查询，并且查询条件包含 <code>NULL</code> 值。</p><ul><li><strong>适用场景</strong>：当 <code>WHERE</code> 子句涉及索引列的等值查询，且查询条件包含了 <code>NULL</code>，MySQL 会选择 <code>ref_or_null</code> 类型。这种类型允许同时查找等值条件和 <code>NULL</code> 值的记录。</li><li><strong>效率</strong>：类似于 <code>ref</code>，但额外处理了 <code>NULL</code> 的情况。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span> <span class="keyword">OR</span> category <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="9-unique-subquery"><a href="#9-unique-subquery" class="headerlink" title="9. unique_subquery"></a>9. <strong>unique_subquery</strong></h4><p><strong>条件</strong>：用于 <code>IN</code> 子查询的优化，适用于<strong>唯一索引列</strong>的子查询。</p><ul><li><strong>适用场景</strong>：当 <code>IN</code> 子查询涉及唯一索引时，MySQL 可以优化子查询，使用 <code>unique_subquery</code> 类型来提高查询效率。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> product_id <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">WHERE</span> quantity <span class="operator">&gt;</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL 优化器选择不同的访问类型来确定如何执行查询，从低效到高效排序如下：</p><ul><li><strong>ALL</strong>：全表扫描，效率最低。</li><li><strong>index</strong>：索引扫描，稍微优于全表扫描。</li><li><strong>range</strong>：范围扫描，适合索引的范围查询。</li><li><strong>ref</strong>：非唯一索引的等值查询，返回多条记录。</li><li><strong>eq_ref</strong>：唯一索引或主键的等值查询，返回唯一一条记录。</li><li><strong>const</strong>：常量查询，效率极高，适用于主键或唯一索引的等值查询</li></ul><p>。</p><ul><li><strong>system</strong>：用于只有一行记录的系统表查询，效率最高。</li></ul><p>希望这些解释能够帮助你理解 MySQL 优化器如何选择访问类型及其对应的使用条件。</p><h3 id="041-使用Order-By时能否通过索引排序？"><a href="#041-使用Order-By时能否通过索引排序？" class="headerlink" title="041      使用Order By时能否通过索引排序？"></a>041      使用Order By时能否通过索引排序？</h3><p>没有过滤条件不走索引</p><p><img src="../assets/image-20241005172511311.png" alt="image-20241005172511311"></p><h4 id="042-通过索引排序内部流程是什么？"><a href="#042-通过索引排序内部流程是什么？" class="headerlink" title="==042          通过索引排序内部流程是什么？=="></a>==042          通过索引排序内部流程是什么？==</h4><p>select name,id  from user where  name like ‘%明’ order by name；</p><p>select name,id，age  from user where  name like ‘%明’</p><p>关键配置：</p><ul><li>sort_buffer可供排序的内存缓冲区大小</li><li>max_length_for_sort_data 单行所有字段总和限制，超过这个大小启动双路排序</li></ul><ol><li>通过索引检过滤筛选条件索到需要排序的字段+其他字段（如果是符合索引）</li><li>判断索引内容是否覆盖select的字段<ol><li>如果覆盖索引，select的字段和排序都在索引上，那么在内存中进行排序，排序后输出结果</li><li>如果索引没有覆盖查询字段，接下来计算select的字段是否超过max_length_for_sort_data限制，如果超过，启动双路排序，否则使用单路</li></ol></li></ol><p><strong>索引覆盖时，内存中排序，未覆盖时，超长双路排序，不超长单路排序</strong></p><h4 id="043-什么是双路排序和单路排序"><a href="#043-什么是双路排序和单路排序" class="headerlink" title="==043          什么是双路排序和单路排序=="></a>==043          什么是双路排序和单路排序==</h4><p>单路排序：一次取出所有字段进行排序，内存不够用的时候会使用磁盘</p><p>双路排序：取出排序字段进行排序，排序完成后再次回表查询所需要的其他字段【超过max_length_for_sort_data限制】</p><blockquote><p>单路排序发生在内存，排序时一次性取出全部查询的字段，双路排序先去需要排序的字段先存到磁盘，再对剩余字段进行查询，实质上是因为单条记录字节过大无法在内存排序的一种妥协方法。</p></blockquote><p>如果不在索引列上，filesort有两种算法： mysql就要启动双路排序和单路排序</p><p> <strong>双路排序（慢）</strong></p><p>Select id,age,name from stu order by name;</p><p>Ø MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p><p>Ø 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><p>Ø 取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p><strong>单路排序（快）</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><p> 但是用单路有问题</p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。</p><p>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p><strong>优化策略</strong></p><p>Ø 增大sort_buffer_size参数的设置</p><p>Ø 增大max_length_for_sort_data参数的设置</p><p>Ø 减少select 后面的查询的字段。 禁止使用select * </p><p><strong>提高Order By的速度</strong> </p><p>\1. Order by时select * 是一个大忌。只Query需要的字段， 这点非常重要。在这里的影响是：</p><p>l 当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</p><p>l 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。 </p><p>\2. 尝试提高 sort_buffer_size</p><p>l 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL5.7和8.0，InnoDB存储引擎默认值是1048576字节，1MB。</p><p>SHOW VARIABLES LIKE ‘%sort_buffer_size%’;</p><p>​                               </p><p>\3. 尝试提高 max_length_for_sort_data</p><p>l 提高这个参数， 会增加用改进算法的概率。</p><p>SHOW VARIABLES LIKE ‘%max_length_for_sort_data%’; </p><p>#5.7默认1024字节</p><p>#8.0默认4096字节</p><p>l 但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="044-group-by-分组和order-by在索引使用上有什么区别？"><a href="#044-group-by-分组和order-by在索引使用上有什么区别？" class="headerlink" title="==044          group by 分组和order by在索引使用上有什么区别？=="></a>==044          group by 分组和order by在索引使用上有什么区别？==</h4><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><ul><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>group by没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。</li></ul><h3 id="045-如果表中有字段为null，又被经常查询该不该给这个字段创建索引？"><a href="#045-如果表中有字段为null，又被经常查询该不该给这个字段创建索引？" class="headerlink" title="==045      如果表中有字段为null，又被经常查询该不该给这个字段创建索引？=="></a>==045      如果表中有字段为null，又被经常查询该不该给这个字段创建索引？==</h3><p>应该创建索引，使用的时候尽量使用is null判断。</p><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span></span><br><span class="line"><span class="comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h4 id="046-有字段为null索引是否会失效？"><a href="#046-有字段为null索引是否会失效？" class="headerlink" title="046          有字段为null索引是否会失效？"></a>046          有字段为null索引是否会失效？</h4><blockquote><p>首先设定默认值， 走不走索引要看优化器的决定</p><p>大部分的is null  要走索引，但不是绝对的</p><p>大部分的is not null 不走索引，但也不是绝对的</p></blockquote><p>不一定会失效，每一条sql具体有没有使用索引 可以通过trace追踪一下</p><p>最好还是给上默认值</p><p>数字类型的给0，字符串给个空串“”，</p><p>参考上一题</p><h2 id="二-MySQL-内部技术架构"><a href="#二-MySQL-内部技术架构" class="headerlink" title="二 MySQL 内部技术架构"></a>二 MySQL 内部技术架构</h2><p><img src="./../assets/image-20221028155608009.png" alt="image-20221028155608009"></p><h3 id="047-Mysql内部支持缓存查询吗？"><a href="#047-Mysql内部支持缓存查询吗？" class="headerlink" title="047 Mysql内部支持缓存查询吗？"></a><img src="./../assets/29f7e85dea17e100b38b450d9949a330.png" alt="img">047 Mysql内部支持缓存查询吗？</h3><p>当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互</p><p>mysql5.7支持内部缓存，8.0之后就废弃掉了</p><h4 id="048-mysql8为何废弃掉查询缓存？"><a href="#048-mysql8为何废弃掉查询缓存？" class="headerlink" title="048     mysql8为何废弃掉查询缓存？"></a>048     mysql8为何废弃掉查询缓存？</h4><p>缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性</p><p>mysql缓存的限制</p><ol><li>mysql基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表</li><li>SQL必须完全一致才会导致cache命中</li><li>为了节省内存空间，太大的result set不会被cache (&lt; query_cache_limit)；</li><li>MySQL缓存在分库分表环境下是不起作用的；</li><li>执行SQL里有触发器,自定义函数时，MySQL缓存也是不起作用的；</li><li>在表的结构或数据发生改变时，基于该表相关cache立即全部失效。</li></ol><h4 id="049-替代方案是什么？"><a href="#049-替代方案是什么？" class="headerlink" title="049     替代方案是什么？"></a>049     替代方案是什么？</h4><p>应用层组织缓存，最简单的是使用redis，ehcached等</p><h3 id="050-Mysql内部有哪些核心模块组成，作用是什么？"><a href="#050-Mysql内部有哪些核心模块组成，作用是什么？" class="headerlink" title="050 Mysql内部有哪些核心模块组成，作用是什么？"></a>050 Mysql内部有哪些核心模块组成，作用是什么？</h3><p><img src="./../assets/image-20220627113443003.png" alt="image-20220627113443003"></p><p><strong>Connectors（客户端）</strong></p><p>MySQL服务器之外的客户端程序，与具体的语言相关，例如Java中的JDBC，图形用户界面SQLyog等。<code>本质上都是在TCP连接上通过MySQL协议和MySQL服务器进行通信。</code></p><p><strong>MySQL Server（服务器）</strong></p><p><strong>第1层：连接层</strong></p><ul><li>系统（客户端）访问 MySQL 服务器前，做的<code>第一件事就是建立 TCP 连接</code>。</li><li>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做<code>身份认证、权限获取</code>。<ul><li>用户名或密码不对<code>，会收到一个</code>Access denied for user<code>错误，客户端程序结束执行</code></li><li><code>用户名密码认证通过</code>，会从权限表<code>查出账号拥有的权限</code>与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul></li><li>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</li></ul><p><strong>第2层：服务层</strong></p><p><strong>Management Serveices &amp; Utilities： 系统管理和控制工具</strong></p><p><strong>SQL Interface：SQL接口：</strong></p><ul><li><code>接收用户的SQL命令，并且返回用户需要查询的结果。</code>比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul><p><strong>Parser：解析器：</strong></p><ul><li>在SQL命令传递到解析器的时候会被解析器验证和解析。解析器中SQL 语句进行<code>语法分析、语法解析</code>，并为其创建<code>语法树</code>。</li><li></li></ul><p><strong>语法分析</strong></p><p>语法分析主要是把输入转化成若干个tokens，包含key和非key。</p><p>在分析之后，会得到4个Token，其中有2个key，它们分别是SELECT、FROM。</p><div class="table-container"><table><thead><tr><th>key</th><th>非key</th><th>key</th><th>非key</th></tr></thead><tbody><tr><td>SELECT</td><td>age</td><td>FROM</td><td>user</td></tr></tbody></table></div><ul><li>典型的解析树如下：</li></ul><p><img src="./../assets/image-20220702002430362.png" alt="image-20220702002430362"></p><p><strong>Optimizer：查询优化器：</strong></p><ul><li>SQL语句在语法解析后、查询前会使用查询优化器对查询进行优化，<code>确定SQL语句的执行路径，生成一个执行计划</code>。</li></ul><p><strong>Caches &amp; Buffers： 查询缓存组件：</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、查询优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在不同客户端之间共享 。 </li></ul><p><strong>第3层：引擎层</strong></p><p>插件式存储引擎层（ Storage Engines），<code>负责MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信</code>。不同的存储引擎具有的功能不同，管理的表有不同的存储结构，采用的存取算法也不同，这样我们可以根据自己的实际需要进行选取。例如MyISAM引擎和InnoDB引擎。</p><p><strong>存储层</strong></p><p>所有的数据、数据库、表的定义、表的每一行的内容、索引，都是存在<code>文件系统</code> 上，以文件的方式存在，并完成与存储引擎的交互。</p><h3 id="051-一条sql发送给mysql后，内部是如何执行的？（说一下-MySQL-执行一条查询语句的内部执行过程？）"><a href="#051-一条sql发送给mysql后，内部是如何执行的？（说一下-MySQL-执行一条查询语句的内部执行过程？）" class="headerlink" title="051 一条sql发送给mysql后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）"></a>051 一条sql发送给mysql后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）</h3><p>1.5、查询流程说明</p><p><img src="./../assets/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image-20220627141453944"></p><p><strong>首先，</strong><code>MySQL客户端通过协议与MySQL服务器建连接，通过SQL接口发送SQL语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析。</code>也就是说，在解析查询之前，服务器会先访问查询缓存，如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</p><p><strong>接下来，</strong><code>MySQL解析器通过关键字将SQL语句进行解析，并生成一棵对应的解析树，</code>解析器使用MySQL语法规则验证和解析SQL语句。例如，它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确，引号能否前后匹配等；<code>预处理器则根据MySQL规则进一步检查解析树是否合法，</code>例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看是否有歧义等。<code>然后预处理器会进行查询重写，生成一棵新解析树。</code></p><p><strong>接下来，</strong><code>查询优化器将解析树转化成执行计划。</code>MySQL优化程序会对我们的语句做一些优化，如子查询转换为连接、表达式简化等等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等。我们可以使用EXPLAIN语句来查看某个语句的执行计划。</p><p><strong>最后，</strong><code>进入执行器阶段。</code>完成查询优化后，<code>查询执行引擎</code>会按照生成的执行计划调用存储引擎提供的接口执行SQL查询并将结果返回给客户端。在MySQL8以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存，再返回给客户端。</p><p><img src="./../assets/b44f857a9bdedcd6a2d53a3971fae7db.png" alt="img" /></p><h4 id="052-MySQL-提示“不存在此列”是执行到哪个节点报出的？"><a href="#052-MySQL-提示“不存在此列”是执行到哪个节点报出的？" class="headerlink" title="052 MySQL 提示“不存在此列”是执行到哪个节点报出的？"></a>052 MySQL 提示“不存在此列”是执行到哪个节点报出的？</h4><p>是在Parser：解析器 分析sql语法的时候检查的列。</p><h3 id="053-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？"><a href="#053-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？" class="headerlink" title="053 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？"></a>053 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？</h3><p>在优化器阶段<strong>Optimizer：查询优化器：</strong></p><h3 id="054-MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#054-MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="054 MySQL 支持哪些存储引擎？默认使用哪个？"></a>054 MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>查看MySQL提供什么存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure><p>下面的结果表示MySQL中默认使用的存储引擎是InnoDB，支持事务，行锁，外键，支持分布式事务(XA)，支持保存点(回滚)</p><p><img src="./../assets/image-20220703164220030.png" alt="image-20220703164220030"></p><p>也可以通过以下语句查看默认的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%default_storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220703170334348.png" alt="image-20220703170334348"></p><h3 id="055-Mysql8-0自带哪些存储引擎？分别是做什么的？"><a href="#055-Mysql8-0自带哪些存储引擎？分别是做什么的？" class="headerlink" title="055 Mysql8.0自带哪些存储引擎？分别是做什么的？"></a>055 Mysql8.0自带哪些存储引擎？分别是做什么的？</h3><p><code>1. InnoDB存储引擎</code></p><ul><li><p>InnoDB是MySQL的默认事务型引擎，它被设计用来<code>处理大量的短期(short-lived)事务</code>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p></li><li><p>除非有非常特别的原因需要使用其他的存储引擎，否则<code>应该优先考虑InnoDB引擎</code>。</p></li><li><p>数据文件结构：</p><ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li></ul></li></ul><ul><li>表名.ibd 存储数据和索引</li></ul><ul><li>InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</li></ul><p><code>2. MyISAM存储引擎</code></p><ul><li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但<code>MyISAM不支持事务和行级锁</code>，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p></li><li><p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用。</p></li><li><p>数据文件结构：</p><ul><li>表名.frm 存储表结构</li></ul></li></ul><ul><li>表名.MYD 存储数据</li></ul><ul><li>表名.MYI 存储索引</li></ul><ul><li>MyISAM只缓存索引，不缓存真实数据。</li></ul><p><code>3. Archive引擎</code></p><ul><li><code>Archive档案存储引擎只支持INSERT和SELECT操作</code>。</li><li>Archive表适合日志和数据采集（档案）类应用。</li><li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li></ul><p><code>4. Blackhole引擎</code></p><ul><li><code>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存</code>。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </li></ul><p><code>5. CSV引擎</code> </p><ul><li><code>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引</code>。</li><li>CSV引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li></ul><p><code>6. Memory引擎</code></p><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li><li>Memory表至少比MyISAM表要快一个数量级。</li></ul><p><code>7. Federated引擎</code></p><ul><li><code>Federated引擎是访问其他MySQL服务器的一个代理（跨库关联查询）</code>，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h3 id="056-MySQL-存储引擎架构了解吗？"><a href="#056-MySQL-存储引擎架构了解吗？" class="headerlink" title="056 MySQL 存储引擎架构了解吗？"></a>056 MySQL 存储引擎架构了解吗？</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html</a></p><p>下面是官方的InnoDB引擎结构图，主要分为内存结构和磁盘结构两大部分。</p><p><img src="./../assets/16701032-f8547d110ba34135.png" alt="img"></p><p><strong>内存区域</strong></p><p><strong>Buffer Pool</strong>:在InnoDB访问表记录和索引时会在Buffer Pool的页中缓存，以后使用可以减少磁盘IO操作，提升效率。主要用来缓存热的数据页和索引页。</p><p><strong>Log Buffer</strong>：用来缓存redolog</p><p><strong>Adaptive Hash Index</strong>：自适应哈希索引</p><p><strong>Change Buffer</strong>:它是一种应用在非唯一普通索引页（non-unique secondary index page）不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更（Buffer Changes），等未来数据被读取时，再将数据合并（Merge）恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。</p><p><strong>磁盘区域</strong></p><p>磁盘中的结构分为两大类：表空间和重做日志。</p><ul><li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</li><li>Redo日志：存储的就是 Log Buffer 刷到磁盘的数据。</li></ul><p>官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a></p><h4 id="057-能否单独为一张表设置存储引擎？"><a href="#057-能否单独为一张表设置存储引擎？" class="headerlink" title="057     能否单独为一张表设置存储引擎？"></a>057     能否单独为一张表设置存储引擎？</h4><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p><code>方法1：</code></p><p>设置默认存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p><code>方法2：</code></p><p>或者修改 my.cnf 文件：vim /etc/my.cnf<br>新增一行：default-storage-engine=MyISAM<br>重启MySQL：systemctl restart mysqld</p><p><code>方法3：</code></p><p>我们可以为 不同的表设置不同的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名( 建表语句; ) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h4 id="058-阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？"><a href="#058-阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？" class="headerlink" title="058     阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？"></a>058     阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？</h4><p>开发存储引擎并不难，难的是开发出来高效的有意义的存储引擎。</p><p>简单例子可以看一下官方源码中的示例，可以实现一个什么也没做的存储引擎。</p><p>有兴趣可以参考官方文档：<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/">https://dev.mysql.com/doc/dev/mysql-server/latest/</a></p><h3 id="059-MyISAM-和-InnoDB-的区别是什么？"><a href="#059-MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="059 MyISAM 和 InnoDB 的区别是什么？"></a>059 MyISAM 和 InnoDB 的区别是什么？</h3><p>外键 事务 锁</p><div class="table-container"><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>关注点</td><td>并发查询，节省资源、消耗少、简单业务</td><td>并发写、事务、多表关系、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr></tbody></table></div><h4 id="060-具体说一下如何做技术选型"><a href="#060-具体说一下如何做技术选型" class="headerlink" title="060     具体说一下如何做技术选型"></a>060     具体说一下如何做技术选型</h4><p>除非几乎没有写操作全部都是高频的读操作可以选择MyISAM作为表的存储引擎，其他业务可以一律使用InnoDB。</p><h2 id="三-mysql-事务"><a href="#三-mysql-事务" class="headerlink" title="三 mysql 事务"></a>三 mysql 事务</h2><h3 id="061-什么是数据库事务？事务的特性是什么？"><a href="#061-什么是数据库事务？事务的特性是什么？" class="headerlink" title="061 什么是数据库事务？事务的特性是什么？"></a>061 什么是数据库事务？事务的特性是什么？</h3><p><strong>事务</strong>：</p><ul><li><p>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；</p></li><li><p>这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；</p></li><li><p>事务是一组不可再分割的操作集合（工作逻辑单元）</p></li></ul><p>事务都有 <strong>ACID</strong> 特性</p><h4 id="062-什么是ACID？"><a href="#062-什么是ACID？" class="headerlink" title="062     什么是ACID？"></a>062     什么是ACID？</h4><p><strong>1 、原子性</strong>  atomicity</p><p>过程的保证</p><p><strong>只做一个步骤</strong></p><p>1 给钱</p><p>2 去买</p><p>3 交回来</p><p>事务是数据库的逻辑工作单位，事务中包含的各操作<strong>要么都做，要么都不做</strong> </p><p><strong>2 、一致性</strong>  consistency</p><p>结果的保证</p><p><strong>保证要吃完</strong> 刚张嘴挂了，失去一致性</p><p>事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。<br><strong>3 、隔离性</strong> isolation</p><p>并发事务互相干扰</p><p><strong>不被干扰</strong> 刚张嘴别人塞了东西</p><p>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。<br><strong>4 、持续性</strong> <strong>永久性</strong> durability</p><p><strong>保存</strong> 吃到肚子里</p><p>也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 </p><h3 id="063-并发事务会有哪些问题？"><a href="#063-并发事务会有哪些问题？" class="headerlink" title="063 并发事务会有哪些问题？"></a>063 并发事务会有哪些问题？</h3><p>多个事务并发执行一定会产生相互争夺资源的问题</p><h4 id="064-什么是脏读-065-丢失修改-066-不可重复读-067-幻读"><a href="#064-什么是脏读-065-丢失修改-066-不可重复读-067-幻读" class="headerlink" title="064    什么是脏读    065    丢失修改    066    不可重复读 067    幻读"></a>064    什么是脏读    065    丢失修改    066    不可重复读 067    幻读</h4><h4 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h4><p><strong>脏读（Dirty read）</strong></p><p>是一个事务在处理过程中读取了另外一个事务未提交的数据</p><p>当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“<strong>脏数据</strong>”，这种行为就是“<strong>脏读</strong>”，依据“<strong>脏数据</strong>”所做的操作可能是会出现问题的。</p><p><strong>修改丢失（Lost of modify）</strong></p><p><em>是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为*</em>修改丢失</p><p><strong>不可重复读（Unrepeatableread）</strong></p><p>*<em>指在一个事务内多<strong>次读取同一数据</strong>，在这个事务还没结束时，另外一个事务也访问了这个数据并<strong>对这个数据进行了修改</strong>，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为*</em>不可重复读。</p><p><strong>幻读（Phantom read）</strong></p><p>是指同一个事务内多次查询返回的结果集总数不一样（比如增加了或者减少了行记录）。</p><p>幻读与不可重复读类似，幻读是指一个事务<strong>读取了几行数据</strong>，这个事务还没结束，接着另外一个事务<strong>插入了一些数据</strong>，在随后的查询中，第一个事务读取到的数据就会<strong>比原本读取到的多</strong>，就好像发生了幻觉一样，所以称为*<em>幻读*</em>。</p><h4 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h4><h4 id="068-不可重复读和幻读有什么区别？"><a href="#068-不可重复读和幻读有什么区别？" class="headerlink" title="068 不可重复读和幻读有什么区别？"></a>068 不可重复读和幻读有什么区别？</h4><p>不可重复读 针对的是一份数据的修改</p><p>幻读 针对的是行数修改</p><h3 id="069-Mysql是如何避免事务并发问题的？"><a href="#069-Mysql是如何避免事务并发问题的？" class="headerlink" title="069 Mysql是如何避免事务并发问题的？"></a>069 Mysql是如何避免事务并发问题的？</h3><p>避免事务并发问题是需要付出性能代价的，此时和分布式系统设计一样（CAP定理及base理论），为了保证一致性就一定会牺牲性能，要做取舍</p><p>在mysql内部通过加锁的方式实现好了解决方案可供选择，就是配置事务隔离级别</p><h4 id="070-什么是事务隔离级别？"><a href="#070-什么是事务隔离级别？" class="headerlink" title="070    什么是事务隔离级别？"></a>070    什么是事务隔离级别？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务隔离级别                    脏读     不可重复读(被修改)    幻读（删减）</span><br><span class="line">读未提交（<span class="keyword">read</span>-<span class="keyword">uncommitted</span>）    是        是            是</span><br><span class="line">不可重复读（<span class="keyword">read</span>-<span class="keyword">committed</span>）    否        是            是</span><br><span class="line">可重复读（<span class="keyword">repeatable</span>-<span class="keyword">read</span>）     否        否            是</span><br><span class="line">串行化（<span class="keyword">serializable</span>）          否        否            否</span><br></pre></td></tr></table></figure><h4 id="071-默认的级别是什么？"><a href="#071-默认的级别是什么？" class="headerlink" title="071    默认的级别是什么？"></a>071    默认的级别是什么？</h4><p><code>MySQL InnoDB</code>存储引擎默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ）</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MySQL</span> <span class="number">5</span>.<span class="number">7</span> SELECT @@tx_isolation;</span><br><span class="line"><span class="attribute">MySQL</span> <span class="number">8</span>.<span class="number">0</span> SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h4 id="072-如何选择事务隔离级别？"><a href="#072-如何选择事务隔离级别？" class="headerlink" title="072    如何选择事务隔离级别？"></a>072    如何选择事务隔离级别？</h4><p>隔离级别越低，事务请求的锁越少相应性能也就越高，如没有特殊要求或有错误发生，使用默认的隔离级别即可，如果系统中有高频读写并且对一致性要求高那么就需要比较高的事务隔离级别甚至串行化。</p><h4 id="073-靠缓存可以提升高事务隔离级别的性能吗？"><a href="#073-靠缓存可以提升高事务隔离级别的性能吗？" class="headerlink" title="073 靠缓存可以提升高事务隔离级别的性能吗？"></a>073 靠缓存可以提升高事务隔离级别的性能吗？</h4><p>提升事务级别的目的本质是提供更高的数据一致性，如果前置有缓存，那么缓存只能提供高效读并不能保证数据及时一致性，相反的我们还需要对缓存管理有额外的开销。</p><h3 id="074-Mysql事务隔离是如何实现的？"><a href="#074-Mysql事务隔离是如何实现的？" class="headerlink" title="074 Mysql事务隔离是如何实现的？"></a>074 Mysql事务隔离是如何实现的？</h3><p>隔离的实现主要是读写锁和MVCC</p><h4 id="075-什么是一致性非锁定读和锁定读？"><a href="#075-什么是一致性非锁定读和锁定读？" class="headerlink" title="075    什么是一致性非锁定读和锁定读？"></a>075    什么是一致性非锁定读和锁定读？</h4><p><strong>锁定读</strong></p><p>使用到了读写锁</p><p>读写锁是最简单直接的的事务隔离实现方式</p><ul><li>每次读操作需要获取一个共享(读)锁，每次写操作需要获取一个写锁。</li><li>共享锁之间不会产生互斥，共享锁和写锁之间、以及写锁与写锁之间会产生互斥。</li><li>当产生锁竞争时，需要等待其中一个操作释放锁后，另一个操作才能获取到锁。</li></ul><p>锁机制，解决的就是<strong>多个事务同时更新数据</strong>，此时必须要有一个加锁的机制</p><ul><li>行锁（记录锁）：解决的就是<strong>多个事务同时更新一行数据</strong></li><li>间隙锁：解决的就是<strong>多个事务同时更新多行数据</strong></li></ul><p>下列操作属于锁定读</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">insert</span>、<span class="keyword">update</span>、<span class="keyword">delete</span></span><br></pre></td></tr></table></figure><p><strong>非锁定读</strong></p><p>v10 -&gt; age=18 </p><p>v11 -&gt;age=19</p><p>v12 -&gt;age=15</p><p>使用mvcc 多版本控制实现</p><h4 id="076-说一下MVCC内部细节"><a href="#076-说一下MVCC内部细节" class="headerlink" title="076    说一下MVCC内部细节"></a>076    说一下MVCC内部细节</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</a></p><p>Multi-Version Concurrency Control 多版本并发控制，<em>MVCC</em> 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问</p><p>InnoDB是一个多版本的存储引擎。它保存有关已更改行的旧版本的信息，以支持并发和回滚等事务特性。这些信息存储在一个称为回滚段的数据结构中的系统表空间或undo表空间中。参见第14.6.3.4节“撤消表空间”。InnoDB使用回滚段中的信息来执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取</p><p>MVCC 的实现依赖于：隐藏字段、Read View、undo log</p><p><strong>隐藏字段</strong></p><ul><li>A 6-byte <code>DB_TRX_ID</code> 用来标识最近一次对本行记录做修改 (insert 、update) 的事务的标识符 ，即最后一次修改本行记录的事务 id。 如果是 delete 操作， 在 InnoDB 存储引擎内部也属于一次 update 操作，即更新行中的一个特殊位 ，将行标识为己删除，并非真正删除。</li><li>A 7-byte <code>DB_ROLL_PTR</code> 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空.</li><li>A 6-byte <code>DB_ROW_ID</code> 如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引.</li></ul><p><strong>Read View</strong></p><p>不同的事务隔离级别中，当有事物在执行过程中修改了数据（更新版本号），在并发事务时需要判断一下版本链中的哪个版本是当前事务可见的。为此InnoDB有了ReadView的概念，使用ReadView来记录和隔离不同事务并发时此记录的哪些版本是对当前访问事物可见的。</p><p><strong>undo log</strong></p><p>除了用来回滚数据，还可以读取可见版本的数据。以此实现非锁定读</p><h4 id="077Mysql事务一致性，原子性是如何实现的？"><a href="#077Mysql事务一致性，原子性是如何实现的？" class="headerlink" title="077Mysql事务一致性，原子性是如何实现的？"></a>077Mysql事务一致性，原子性是如何实现的？</h4><p>首先是通过锁和mvcc实现了执行过程中的一致性和原子性</p><p>其次是在灾备方面通过Redo log实现，Redo log会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。</p><h4 id="078Mysql事务的持久性是如何实现的？"><a href="#078Mysql事务的持久性是如何实现的？" class="headerlink" title="078Mysql事务的持久性是如何实现的？"></a>078Mysql事务的持久性是如何实现的？</h4><p>使用Redo log保证了事务的持久性。当事务提交时，必须先将事务的所有日志写入日志文件进行持久化，就是我们常说的WAL(write ahead log)机制，如果出现断电重启便可以从redolog中恢复，如果redolog写入失败那么也就意味着修改失败整个事务也就直接回滚了。</p><h4 id="079-表级锁和行级锁有什么区别？"><a href="#079-表级锁和行级锁有什么区别？" class="headerlink" title="079  表级锁和行级锁有什么区别？"></a>079  表级锁和行级锁有什么区别？</h4><p> 表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用</p><p>行级锁：除了串行化（serializable）时 InnoDB使用的都是行级锁，只锁一行数据，其他行数据不影响，并发能力强。</p><h4 id="080-什么是行级锁？Mysql如何完成的？"><a href="#080-什么是行级锁？Mysql如何完成的？" class="headerlink" title="080    什么是行级锁？Mysql如何完成的？"></a>080    什么是行级锁？Mysql如何完成的？</h4><p>行级锁实现比较复杂不是单纯锁住一行数据，是由mvcc完成的。</p><h4 id="081-什么是共享锁（读锁）？"><a href="#081-什么是共享锁（读锁）？" class="headerlink" title="081    什么是共享锁（读锁）？"></a>081    什么是共享锁（读锁）？</h4><p>共享锁或S锁，其它事务可以继续加共享锁，但不能加排它锁</p><h4 id="082-什么是排它锁（写锁-独占锁）？"><a href="#082-什么是排它锁（写锁-独占锁）？" class="headerlink" title="082    什么是排它锁（写锁/独占锁）？"></a>082    什么是排它锁（写锁/独占锁）？</h4><p>排它锁或X锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁。</p><h4 id="083-什么是意向锁？"><a href="#083-什么是意向锁？" class="headerlink" title="083    什么是意向锁？"></a>083    什么是意向锁？</h4><p>它分为意向共享锁（IS）和意向排他锁（IX）</p><p>一个事务对一张表的某行添加共享锁前，必须获得对该表一个IS锁或者优先级更高的锁。<br>一个事务对一张表的某行添加排他锁之前，它必须对该表获取一个IX锁。</p><p>意向锁属于表锁，它不与innodb中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S锁和X锁）产生冲突</p><h4 id="084-InnoDB支持哪几种锁？"><a href="#084-InnoDB支持哪几种锁？" class="headerlink" title="084    InnoDB支持哪几种锁？"></a>084    InnoDB支持哪几种锁？</h4><p>表锁，行锁，间隙锁，Next-Key锁等</p><p>在Serializable中读加共享锁，写加排他锁，读写互斥</p><p>两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p><h4 id="085-当前读和快照读分别是什么？"><a href="#085-当前读和快照读分别是什么？" class="headerlink" title="085    当前读和快照读分别是什么？"></a>085    当前读和快照读分别是什么？</h4><p>当前读 ：在锁定读（使用锁隔离事物）的时候读到的是最新版本的数据</p><p>快照读：可重复读（repeatable-read）下 mvcc生效读取的是数据的快照，并不是最新版本的数据（未提交事物的数据）</p><h3 id="086-什么是XA协议？"><a href="#086-什么是XA协议？" class="headerlink" title="086 什么是XA协议？"></a>086 什么是XA协议？</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/xa.html">https://dev.mysql.com/doc/refman/8.0/en/xa.html</a></p><p><img src="./../assets/2021110810071449.png" alt="在这里插入图片描述"></p><ul><li>AP（Application Program）：应用程序，定义事务边界（定义事务开始和结束）并访问事务边界内的资源。</li><li>RM（Resource Manger）资源管理器: 管理共享资源并提供外部访问接口。供外部程序来访问数据库等共享资源。此外，RM还具有事务的回滚能力。</li><li>TM（Transaction Manager）事务管理器：TM是分布式事务的协调者，TM与每个RM进行通信，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li></ul><ul><li>应用程序AP向事务管理器TM发起事务请求</li><li>TM调用xa_open()建立同资源管理器的会话</li><li>TM调用xa_start()标记一个事务分支的开头</li><li>AP访问资源管理器RM并定义操作，比如插入记录操作</li><li>TM调用xa_end()标记事务分支的结束</li><li>TM调用xa_prepare()通知RM做好事务分支的提交准备工作。其实就是二阶段提交的提交请求阶段。</li><li>TM调用xa_commit()通知RM提交事务分支，也就是二阶段提交的提交执行阶段。</li><li>TM调用xa_close管理与RM的会话。<ul><li>这些接口一定要按顺序执行，比如xa_start接口一定要在xa_end之前。此外，这里千万要注意的是事务管理器只是标记事务分支并不执行事务，事务操作最终是由应用程序通知资源管理器完成的。另外，我们来总结下XA的接口</li></ul></li><li>xa_start:负责开启或者恢复一个事务分支，并且管理XID到调用线程</li><li>xa_end:负责取消当前线程与事务分支的关系</li><li>xa_prepare:负责询问RM 是否准备好了提交事务分支 xa_commit:通知RM提交事务分支</li><li>xa_rollback:通知RM回滚事务分支</li></ul><h4 id="087-什么是mysql-xa事务？"><a href="#087-什么是mysql-xa事务？" class="headerlink" title="087     什么是mysql xa事务？"></a>087     什么是mysql xa事务？</h4><p>mysql的xa事务分为两部分：</p><ol><li>InnoDB内部本地普通事务操作协调数据写入与log写入两阶段提交</li><li>外部分布式事务</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.7</span> SHOW <span class="keyword">VARIABLES</span> LIKE <span class="comment">&#x27;%innodb_support_xa%&#x27;</span>;</span><br><span class="line"><span class="number">8.0</span> 默认开启无法关闭</span><br></pre></td></tr></table></figure><p>XA 事务语法示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XA START &#x27;自定义事务id&#x27;;</span><br><span class="line"></span><br><span class="line">SQL语句...</span><br><span class="line"></span><br><span class="line">XA END &#x27;自定义事务id&#x27;;</span><br><span class="line">XA PREPARE &#x27;自定义事务id&#x27;;</span><br><span class="line">XA COMMIT\ROLLBACK &#x27;自定义事务id&#x27;;</span><br></pre></td></tr></table></figure><p>XA PREPARE 执行成功后，事务信息将被持久化。即使会话终止甚至应用服务宕机，只要我们将【自定义事务id】记录下来，后续仍然可以使用它对事务进行 rollback 或者 commit。</p><h4 id="088-xa事务与普通事务区别是什么？"><a href="#088-xa事务与普通事务区别是什么？" class="headerlink" title="088     xa事务与普通事务区别是什么？"></a>088     xa事务与普通事务区别是什么？</h4><p>xa事务可以跨库或跨服务器，属于分布式事务，同时xa事务还支撑了InnoDB内部日志两阶段记录</p><p>普通事务只能在单库中执行</p><h4 id="089-什么是2pc-3pc？"><a href="#089-什么是2pc-3pc？" class="headerlink" title="089     什么是2pc 3pc？"></a>089     什么是2pc 3pc？</h4><p>两阶段提交协议与3阶段提交协议，额外增加了参与的角色保证分布式事务完成更完善</p><h3 id="090-是否使用过select-for-update？会产生哪些操作？"><a href="#090-是否使用过select-for-update？会产生哪些操作？" class="headerlink" title="090 是否使用过select for update？会产生哪些操作？"></a>090 是否使用过select for update？会产生哪些操作？</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询库存 <span class="operator">=</span> <span class="number">100</span>  <span class="number">0</span> 扣减库存  <span class="operator">=</span> -<span class="number">1</span> <span class="number">99</span></span><br><span class="line">记录日志 <span class="operator">=</span> log</span><br><span class="line">提交  commit</span><br></pre></td></tr></table></figure><p>select本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用select for update 会让select语句产生一个排它锁(X), 这个锁和update的效果一样，会使两个事务无法同时更新一条记录。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">https://dev.mysql.com/doc/refman/8.0/en/select.html</a></p><ul><li><p>for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。</p></li><li><p>在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p></li><li><strong>InnoDB默认是行级别的锁，在筛选条件中当有明确指定主键或唯一索引列的时候，是行级锁。否则是表级别。</strong></li></ul><p>示例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> … <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> column_list][WAIT n|<span class="keyword">NOWAIT</span>][<span class="keyword">SKIP LOCKED</span>];</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> 会等待行锁释放之后，返回查询结果。</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">nowait</span> 不等待行锁释放，提示锁冲突，不返回结果</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> wait <span class="number">5</span> 等待<span class="number">5</span>秒，若行锁仍未释放，则提示锁冲突，不返回结果</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">skip locked</span> 查询返回查询结果，但忽略有行锁的记录</span><br></pre></td></tr></table></figure><h3 id="091说一下mysql死锁的原因和处理方法"><a href="#091说一下mysql死锁的原因和处理方法" class="headerlink" title="091说一下mysql死锁的原因和处理方法"></a>091说一下mysql死锁的原因和处理方法</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">事务 a</span><br><span class="line"></span><br><span class="line">表 t  <span class="attribute">id</span>=100 更新  加行锁</span><br><span class="line">表 t  <span class="attribute">id</span>=200 更新  已加锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">事务 b</span><br><span class="line"></span><br><span class="line">表 t  <span class="attribute">id</span>=200 更新 加行锁</span><br><span class="line">表 t  <span class="attribute">id</span>=100 更新 已加锁</span><br></pre></td></tr></table></figure><ul><li>死锁与锁等待是两个概念<ul><li>如未开启事务，多个客户端执行的insert操作</li></ul></li><li>当多个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生了死锁。</li></ul><p>排查：</p><ul><li>正在运行的任务<ul><li>show full processlist;  找到卡主的进程</li></ul></li><li>解开死锁<ul><li>UNLOCK TABLES ；</li></ul></li><li>查看当前运行的事务<ul><li>SELECT * FROM information_schema.INNODB_TRX;</li></ul></li><li>当前出现的锁<ul><li>SELECT * FROM information_schema.INNODB_LOCKS;</li></ul></li><li>观察错误日志</li><li>查看InnoDB锁状态<ul><li><code>show status like &quot;innodb_row_lock%&quot;;</code></li></ul></li></ul><p>lnnodb_row_lock_current_waits:当前正在等待锁定的数量;<br>lnnodb_row_lock_time :从系统启动到现在锁定的总时间长度，单位ms;<br>Innodb_row_lock_time_avg :每次等待所花平均时间;<br>Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间;<br>lnnodb_row_lock_waits :从系统启动到现在总共等待的次数。</p><ul><li>kill  id 杀死进程</li></ul><p>解决：</p><ul><li><p>死锁无法避免，上线前要进行严格的压力测试</p></li><li><p>快速失败</p><ul><li>innodb_lock_wait_timeout 行锁超时时间</li></ul></li><li>拆分sql，严禁大事务</li><li>充分利用索引，优化索引，尽量把有风险的事务sql使用上覆盖索，优化where条件前缀匹配，提升查询速度，引减少表锁</li><li>无法避免时：<ul><li>操作多张表时，尽量以相同的顺序来访问避免形成等待环路</li><li>单张表时先排序再操作</li><li>使用排它锁 比如 for update</li></ul></li></ul><h3 id="092-Mysql会产生几种日志？"><a href="#092-Mysql会产生几种日志？" class="headerlink" title="092 Mysql会产生几种日志？"></a>092 Mysql会产生几种日志？</h3><ul><li><strong>错误日志（error log）</strong></li></ul><p>error log主要记录MySQL在启动、关闭或者运行过程中的错误信息，在MySQL的配置文件my.cnf中，可以通过log-error=/var/log/mysqld.log 执行mysql错误日志的位置。</p><ul><li><strong>慢查询日志（slow query log）</strong></li></ul><p>0.1秒</p><p>Ø MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 </p><p>Ø long_query_time的默认值为10，意思是运行10秒以上的语句。 </p><p>Ø 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p><p>Ø 默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>Ø 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。</p><p> 在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p><ul><li><strong>一般查询日志（general log）</strong></li></ul><p>general log 记录了客户端连接信息以及执行的SQL语句信息，通过MySQL的命令</p><ul><li><p><strong>重写日志（redo log）</strong></p></li><li><p><strong>回滚日志（undo log）</strong></p></li><li><p><strong>二进制日志（bin log）</strong></p></li></ul><h4 id="093-bin-log作用是什么？"><a href="#093-bin-log作用是什么？" class="headerlink" title="093     bin log作用是什么？"></a>093     bin log作用是什么？</h4><p>MySQL的bin log日志是用来记录MySQL中增删改时的记录日志。</p><p>当你的一条sql操作对数据库中的内容进行了更新，就会增加一条bin log日志。查询操作不会记录到bin log中。</p><p>bin log最大的用处就是进行<strong>主从复制，以及数据库的恢复。</strong></p><h4 id="094-redo-log作用是什么？"><a href="#094-redo-log作用是什么？" class="headerlink" title="094    redo log作用是什么？"></a>094    redo log作用是什么？</h4><p>redo log是一种基于磁盘的数据结构，用来在MySQL宕机情况下将不完整的事务执行数据纠正，redo日志记录事务执行后的状态。</p><p>当事务开始后，redo log就开始产生，并且随着事务的执行不断写入redo log file中。redo log file中记录了xxx页做了xx修改的信息，我们都知道数据库的更新操作会在内存中先执行，最后刷入磁盘。</p><p>redo log就是为了恢复更新了内存但是由于宕机等原因没有刷入磁盘中的那部分数据。</p><h4 id="095-undo-log作用是什么？"><a href="#095-undo-log作用是什么？" class="headerlink" title="095     undo log作用是什么？"></a>095     undo log作用是什么？</h4><p>undo log主要用来回滚到某一个版本，是一种逻辑日志。</p><p>undo log记录的是修改之前的数据，比如：当delete一条记录时，undolog中会记录一条对应的insert记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过undo log中的记录内容并以此进行回滚。</p><p>undo log还可以提供多版本并发控制下的读取（MVCC）。</p><h3 id="096-Mysql日志是否实时写入磁盘？-097-bin-log刷盘机制是如何实现的？098-redo-log刷盘机制是如何实现的？-099-undo-log刷盘机制是如何实现的？"><a href="#096-Mysql日志是否实时写入磁盘？-097-bin-log刷盘机制是如何实现的？098-redo-log刷盘机制是如何实现的？-099-undo-log刷盘机制是如何实现的？" class="headerlink" title="096     Mysql日志是否实时写入磁盘？ 097         bin log刷盘机制是如何实现的？098         redo log刷盘机制是如何实现的？  099         undo log刷盘机制是如何实现的？"></a>096     Mysql日志是否实时写入磁盘？ 097         bin log刷盘机制是如何实现的？098         redo log刷盘机制是如何实现的？  099         undo log刷盘机制是如何实现的？</h3><p>磁盘写入固然是比较慢的。</p><p>参数：sync_binlog</p><p>binlog 写入策略：</p><p><strong>1、sync_binlog=0</strong> 的时候，表示每次提交事务binlog不会马上写入到磁盘，而是先写到page cache,相对于磁盘写入来说写page cache要快得多,不过在Mysql 崩溃的时候会有丢失日志的风险。</p><p><strong>2、sync_binlog=1</strong> 的时候，表示每次提交事务都会执行 fsync 写入到磁盘 ；</p><p><strong>3、sync_binlog的值大于1</strong> 的时候，表示每次提交事务都 先写到page cach，只有等到积累了N个事务之后才fsync 写入到磁盘，同样在此设置下Mysql 崩溃的时候会有丢失N个事务日志的风险。</p><p>很显然三种模式下，sync_binlog=1 是强一致的选择，选择0或者N的情况下在极端情况下就会有丢失日志的风险，具体选择什么模式还是得看系统对于一致性的要求。</p><p><img src="./../assets/16701032-f8547d110ba34135.png" alt="img"></p><p><strong>innodb_flush_log_at_trx_commit</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取值<span class="number">0</span>：每秒（一秒钟内提交的事务）写入磁盘  每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存。</span><br><span class="line">取值<span class="number">1</span>：有事务提交就立即刷盘     每次提交事务都立即调用操作系统fsync刷新IO缓存。</span><br><span class="line">取值<span class="number">2</span>：每次事务提交 都写给操作系统 由系统接管什么时候写入磁盘   每次都把redo <span class="keyword">log</span>写到系统的page <span class="keyword">cache</span>中，由系统接管什么时候写入磁盘</span><br></pre></td></tr></table></figure><p>时机顺序： </p><ul><li><p>1 开启事务</p></li><li><p>2 查询数据库中需要更新的字段，加载到内存中 形成数据<strong>脏页</strong></p></li><li><p>3 记录undo log到内存缓冲区（用于回滚和mvcc）并关联redo log   -&gt; 可刷盘</p></li><li><p>4 记录 redo log到内存缓冲区 （用于失败重放）准备提交事务           -&gt; 可刷盘</p></li><li><p>5 修改内存中的脏页数据</p></li><li><p>6 提交事务触发redolog刷盘</p></li><li><p>7 undo log 和脏页 刷盘</p></li><li><p>8 事务成功</p></li></ul><p>  <strong>redo log 与 binlog 的两阶段提交</strong></p><p>redo log 的写入拆成了两个步骤：prepare 和 commit</p><ul><li><p><strong>prepare</strong>：redolog写入log buffer，并fsync持久化到磁盘，在redolog事务中记录2PC的XID，在redolog事务打上prepare标识</p></li><li><p><strong>commit</strong>：binlog写入log buffer，并fsync持久化到磁盘，在binlog事务中记录2PC的XID，同时在redolog事务打上commit标识</p></li></ul><p><img src="./../assets/v2-a48d01fd3478ba4d68207fc7ce757658_r.jpg" alt="img"></p><h3 id="100-MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#100-MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="100 MySQL的binlog有有几种录入格式？分别有什么区别？"></a>100 MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>logbin格式：</p><ul><li>binlog_format=STATEMENT（默认）：数据操作的时间，同步时不一致 每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一 条sql语句和每一行的 数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致 master-slave 中的数据不一致( 如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会 出    现 问题)</li><li>binlog_format=ROW：批量数据操作时，效率低   不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样 了。而且不会出 现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的 问题。缺 点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li><li>binlog_format=MIXED：是以上两种level的混合使用，有函数用ROW，没函数用STATEMENT，但是无法识别系统变量</li></ul><h3 id="101-Mysql集群同步时为什么使用binlog？优缺点是什么？"><a href="#101-Mysql集群同步时为什么使用binlog？优缺点是什么？" class="headerlink" title="101 Mysql集群同步时为什么使用binlog？优缺点是什么？"></a>101 Mysql集群同步时为什么使用binlog？优缺点是什么？</h3><ul><li>binlog是mysql提供的日志，所有存储引擎都可用。</li><li>支持增量同步</li><li>binlog还可以供其他中间件读取，比如同步到hdfs中</li><li>如果复制表数据：<ul><li>不支持某个阶段回放</li><li>直接复制数据过程中一旦中断复制（比如断网），很难确定复制的offset</li></ul></li></ul><h2 id="四-Mysql开发"><a href="#四-Mysql开发" class="headerlink" title="四 Mysql开发"></a>四 Mysql开发</h2><h3 id="102-可以使用MySQL直接存储文件吗？"><a href="#102-可以使用MySQL直接存储文件吗？" class="headerlink" title="102 可以使用MySQL直接存储文件吗？"></a>102 可以使用MySQL直接存储文件吗？</h3><p>可以使用 BLOB (binary large object)，用来存储二进制大对象的字段类型。</p><p>TinyBlob 255 值的长度加上用于记录长度的1个字节(8位)<br>Blob 65K值的长度加上用于记录长度的2个字节(16位)<br>MediumBlob 16M值的长度加上用于记录长度的3个字节(24位)<br>LongBlob 4G 值的长度加上用于记录长度的4个字节(32位)。</p><h4 id="103-什么时候存，什么时候不存？"><a href="#103-什么时候存，什么时候不存？" class="headerlink" title="103    什么时候存，什么时候不存？"></a>103    什么时候存，什么时候不存？</h4><p>存：需要高效查询并且文件很小的时候</p><p>不存：文件比较大，数据量多或变更频繁的时候</p><h4 id="104-存储的时候有遇到过什么问题吗？"><a href="#104-存储的时候有遇到过什么问题吗？" class="headerlink" title="104    存储的时候有遇到过什么问题吗？"></a>104    存储的时候有遇到过什么问题吗？</h4><ol><li>上传数据过大sql执行失败 调整max_allowed_packet</li><li>主从同步数据时比较慢</li><li>应用线程阻塞</li><li>占用网络带宽</li><li>高频访问的图片无法使用浏览器缓存</li></ol><h4 id="105-Emoji乱码怎么办？"><a href="#105-Emoji乱码怎么办？" class="headerlink" title="105    Emoji乱码怎么办？"></a>105    Emoji乱码怎么办？</h4><p>使用utf8mb4</p><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，一般情况下使用utf8也就够了。</p><h3 id="106-如何存储ip地址？"><a href="#106-如何存储ip地址？" class="headerlink" title="106 如何存储ip地址？"></a>106 如何存储ip地址？</h3><ol><li>使用字符串</li><li>使用无符号整型</li></ol><ul><li>4个字节即解决问题</li><li>可以支持范围查询</li><li><strong>INET_ATON()</strong> 和 <strong>INET_NTOA()</strong> ipv6 使用 <strong>INET6_ATON()</strong> 和 <strong>INET6_NTOA()</strong></li></ul><h3 id="107-长文本如何存储？"><a href="#107-长文本如何存储？" class="headerlink" title="107 长文本如何存储？"></a>107 长文本如何存储？</h3><p>可以使用Text存储</p><p><strong>TINYTEXT(255长度)</strong></p><p><strong>TEXT(65535)</strong></p><p><strong>MEDIUMTEXT（int最大值16M）</strong></p><p><strong>LONGTEXT(long最大值4G)</strong></p><h4 id="108-大段文本如何设计表结构？"><a href="#108-大段文本如何设计表结构？" class="headerlink" title="108    大段文本如何设计表结构？"></a>108    大段文本如何设计表结构？</h4><ol><li>或将大段文本同时存储到搜索引擎</li><li>分表存储</li><li>分表后多段存储</li></ol><h4 id="109-大段文本查找时如何建立索引？"><a href="#109-大段文本查找时如何建立索引？" class="headerlink" title="109    大段文本查找时如何建立索引？"></a>109    大段文本查找时如何建立索引？</h4><ol><li>全文检索，模糊匹配最好存储到搜索引擎中</li><li>指定索引长度</li><li>分段存储后创建索引</li></ol><h4 id="110-有没有在开发中使用过TEXT-BLOB-数据类型"><a href="#110-有没有在开发中使用过TEXT-BLOB-数据类型" class="headerlink" title="110    有没有在开发中使用过TEXT,BLOB 数据类型"></a>110    有没有在开发中使用过TEXT,BLOB 数据类型</h4><p> BLOB 之前做ERP的时候使用过，互联网项目一般不用BLOB </p><p>TEXT  文献，文章，小说类，新闻，会议内容 等</p><h3 id="111-日期，时间如何存取？"><a href="#111-日期，时间如何存取？" class="headerlink" title="111  日期，时间如何存取？"></a>111  日期，时间如何存取？</h3><ol><li>使用 TIMESTAMP，DATETIME</li><li>使用字符串</li></ol><h4 id="112-TIMESTAMP，DATETIME-的区别是什么？"><a href="#112-TIMESTAMP，DATETIME-的区别是什么？" class="headerlink" title="112    TIMESTAMP，DATETIME 的区别是什么？"></a>112    TIMESTAMP，DATETIME 的区别是什么？</h4><p>跨时区的业务使用 TIMESTAMP，TIMESTAMP会有时区转换</p><p>1、两者的存储方式不一样:<br>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。<br>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</p><p>2、存储字节大小不同</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>MySQL 5.6.4之前需要存储</th><th>MySQL 5.6.4之后需要存储</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>5 bytes + 小数秒存储</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>4 bytes + 小数秒存储</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>分秒数精度</th><th>存储字节大小</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1,2</td><td>1 bytes</td></tr><tr><td>3,4</td><td>2 bytes</td></tr><tr><td>5,6</td><td>3 bytes</td></tr></tbody></table></div><p> 3、两者所能存储的时间范围不一样:<br>timestamp所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。<br>datetime所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</p><h4 id="113-为什么不使用字符串存储日期？"><a href="#113-为什么不使用字符串存储日期？" class="headerlink" title="113    为什么不使用字符串存储日期？"></a>113    为什么不使用字符串存储日期？</h4><p>字符串无法完成数据库内部的范围筛选</p><p>在大数据量存储优化索引时，查询必须加上时间范围</p><h4 id="114-如果需要使用时间戳-timestamp和int该如何选择？"><a href="#114-如果需要使用时间戳-timestamp和int该如何选择？" class="headerlink" title="114    如果需要使用时间戳 timestamp和int该如何选择？"></a>114    如果需要使用时间戳 timestamp和int该如何选择？</h4><p><strong>int</strong> 存储空间小，运算查询效率高，不受时区影响，精度低</p><p><strong>timestamp</strong> 存储空间小，可以使用数据库内部时间函数比如更新，精度高，需要注意时区转换，timestamp更易读</p><p>一般选择timestamp，两者性能差异不明显，本质上存储都是使用的int</p><h3 id="115-char与varchar的区别？如何选择？"><a href="#115-char与varchar的区别？如何选择？" class="headerlink" title="115    char与varchar的区别？如何选择？"></a>115    char与varchar的区别？如何选择？</h3><p>1.char的优点是存储空间固定（最大255），没有碎片，尤其更新比较频繁的时候，方便数据文件指针的操作，所以存储读取速度快。缺点是空间冗余，对于数据量大的表，非固定长度属性使用char字段，空间浪费。</p><p>2.varchar字段，存储的空间根据存储的内容变化，空间长度为L+size，存储内容长度加描述存储内容长度信息，优点就是空间节约，缺点就是读取和存储时候，需要读取信息计算下标，才能获取完整内容。</p><h3 id="116-财务计算有没有出现过错乱？"><a href="#116-财务计算有没有出现过错乱？" class="headerlink" title="116    财务计算有没有出现过错乱？"></a>116    财务计算有没有出现过错乱？</h3><p>第一类：锁包括多线程，数据库，UI展示后超时提交等</p><p>第二类：应用与数据库浮点运算精度丢失</p><ol><li>应用开发问题：多线程共享数据读写，</li><li>之前有过丢失精度的问题，使用decimal解决</li><li>使用乘法替换除法</li><li>使用事务保证acid特性</li><li>更新时使用悲观锁 SELECT … FOR UPDATE</li><li>数据只有标记删除</li><li>记录详细日志方便溯源</li></ol><h4 id="117-decimal与float-double的区别是什么？"><a href="#117-decimal与float-double的区别是什么？" class="headerlink" title="117        decimal与float,double的区别是什么？"></a>117        decimal与float,double的区别是什么？</h4><p>float：浮点型，4字节，32bit。</p><p>double：双精度实型，8字节，64位</p><p>decimal：数字型，128bit，不存在精度损失</p><p>对于声明语法DECIMAL(M,D)，自变量的值范围如下：</p><ul><li>M是最大位数（精度），范围是1到65。可不指定，默认值是10。</li><li>D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，默认值是0。</li></ul><p>例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在salary列中的值的范围是从-999.99到999.99。</p><h4 id="118-浮点类型如何选型？为什么？"><a href="#118-浮点类型如何选型？为什么？" class="headerlink" title="118        浮点类型如何选型？为什么？"></a>118        浮点类型如何选型？为什么？</h4><ul><li><p>需要不丢失精度的计算使用DECIMAL</p></li><li><p>仅用于展示没有计算的小数存储可以使用字符串存储</p></li><li>低价值数据允许计算后丢失精度可以使用float double</li><li>整型记录不会出现小数的不要使用浮点类型</li></ul><h3 id="119-预编译sql是什么？"><a href="#119-预编译sql是什么？" class="headerlink" title="119   预编译sql是什么？"></a>119   预编译sql是什么？</h3><p>完整解释：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/prepare.html">https://dev.mysql.com/doc/refman/8.0/en/prepare.html</a></p><p>PreparedStatement</p><h4 id="120-预编译sql有什么好处？"><a href="#120-预编译sql有什么好处？" class="headerlink" title="120        预编译sql有什么好处？"></a>120        预编译sql有什么好处？</h4><ul><li>预编译sql会被mysql缓存下来</li><li>作用域是每个session，对其他session无效，重新连接也会失效</li><li>提高安全性防止sql注入<ul><li>select * from user where id =?</li><li>“1;delete from user where id = 1”;</li></ul></li><li>编译语句有可能被重复调用，也就是说sql相同参数不同在同一session中重复查询执行效率明显比较高</li><li>mysql 5,8 支持服务器端的预编译</li></ul><h3 id="121-子查询与join哪个效率高？"><a href="#121-子查询与join哪个效率高？" class="headerlink" title="121    子查询与join哪个效率高？"></a>121    子查询与join哪个效率高？</h3><p>子查询虽然很灵活，但是执行效率并不高。</p><h4 id="122-为什么子查询效率低？"><a href="#122-为什么子查询效率低？" class="headerlink" title="122        为什么子查询效率低？"></a>122        为什么子查询效率低？</h4><p>在执行子查询的时候，MYSQL创建了临时表，查询完毕后再删除这些临时表</p><p>子查询的速度慢的原因是多了一个创建和销毁临时表的过程。<br>而join 则不需要创建临时表 所以会比子查询快一点</p><h4 id="123-join查询可以无限叠加吗？Mysql对join查询有什么限制吗？"><a href="#123-join查询可以无限叠加吗？Mysql对join查询有什么限制吗？" class="headerlink" title="123        join查询可以无限叠加吗？Mysql对join查询有什么限制吗？"></a>123        join查询可以无限叠加吗？Mysql对join查询有什么限制吗？</h4><p>建议join不超过3张表关联，mysql对内存敏感，关联过多会占用更多内存空间，使性能下降</p><p>Too many tables; MySQL can only use 61 tables in a join；</p><p>系统限制最多关联61个表</p><h4 id="124-join-查询算法了解吗？"><a href="#124-join-查询算法了解吗？" class="headerlink" title="124  join 查询算法了解吗？"></a>124  join 查询算法了解吗？</h4><ul><li>Simple Nested-Loop Join：SNLJ，简单嵌套循环连接</li><li>Index Nested-Loop Join：INLJ，索引嵌套循环连接</li><li>Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接</li></ul><h4 id="125-如何优化过多join查询关联？"><a href="#125-如何优化过多join查询关联？" class="headerlink" title="125        如何优化过多join查询关联？"></a>125        如何优化过多join查询关联？</h4><ul><li>适当使用冗余字段减少多表关联查询</li><li>驱动表和被驱动表（小表join大表）</li><li>业务允许的话 尽量使用inner join 让系统帮忙自动选择驱动表</li><li>关联字段一定创建索引</li><li>调整JOIN BUFFER大小</li></ul><h3 id="126-是否有过mysql调优经验？"><a href="#126-是否有过mysql调优经验？" class="headerlink" title="126    是否有过mysql调优经验？"></a>126    是否有过mysql调优经验？</h3><p>调优：</p><ol><li>sql调优</li><li>表（结构）设计调优</li><li>索引调优</li><li>慢查询调优</li><li>操作系统调优</li><li>数据库参数调优</li></ol><h4 id="127-开发中使用过哪些调优工具？"><a href="#127-开发中使用过哪些调优工具？" class="headerlink" title="127        开发中使用过哪些调优工具？"></a>127        开发中使用过哪些调优工具？</h4><p>官方自带：</p><ul><li>EXPLAIN </li><li>mysqldumpslow</li><li>show profiles 时间</li><li>optimizer_trace</li></ul><p>第三方：性能诊断工具，参数扫描提供建议，参数辅助优化</p><h4 id="128-如何监控线上环境中执行比较慢的sql？-129-如何分析一条慢sql？"><a href="#128-如何监控线上环境中执行比较慢的sql？-129-如何分析一条慢sql？" class="headerlink" title="128        如何监控线上环境中执行比较慢的sql？ 129        如何分析一条慢sql？"></a>128        如何监控线上环境中执行比较慢的sql？ 129        如何分析一条慢sql？</h4><p>开启慢查询日志，收集sql</p><p>Ø 默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>Ø 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。</p><p><strong>查看及开启</strong></p><ol><li>默认关闭</li></ol><p><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code></p><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的， </p><p>​                               </p><ol><li>开启：<code>set global     slow_query_log=1;</code> 只对窗口生效，重启服务失效</li></ol><ol><li>慢查询日志记录long_query_time时间</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br></pre></td></tr></table></figure><p>l 全局变量设置，对所有客户端有效。但，必须是设置后进行登录的客户端。</p><p>SET GLOBAL long_query_time=0.1;</p><p>l 对当前会话连接立即生效，对其他客户端无效。</p><p>SET SESSION long_query_time=0.1; #session可省略</p><p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，</p><p>在mysql源码里是判断大于long_query_time，而非大于等于。</p><ol><li><p>永久生效</p></li><li><ul><li>修改配置文件my.cnf（其它系统变量也是如此） </li><li>[mysqld]下增加或修改参数</li><li>slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 </li></ul></li></ol><p>slow_query_log =1</p><p>slow_query_log_file=/var/lib/mysql/localhost-slow.log</p><p>long_query_time=3</p><p>log_output=FILE</p><ol><li><ul><li>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，如果不设置，系统默认文件：[host_name]-slow.log</li></ul></li></ol><p><strong>case</strong></p><p>Ø 记录慢SQL并后续分析</p><p>SELECT * FROM emp;</p><p>SELECT * FROM emp WHERE deptid &gt; 1;</p><p>Ø 查询当前系统中有多少条慢查询记录或者直接看慢查询日志</p><p>/var/lib/mysql/localhost-slow.log</p><p>SHOW GLOBAL STATUS LIKE ‘%Slow_queries%’; </p><p> <strong>日志分析工具mysqldumpslow</strong></p><ol><li><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p></li><li><p>查看mysqldumpslow的帮助信息</p></li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a)   mysqldumpslow --help</span><br><span class="line"></span><br><span class="line">·    -a: 将数字抽象成N，字符串抽象成S</span><br><span class="line"></span><br><span class="line">·    -s: 是表示按照何种方式排序；</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> c:</span> 访问次数</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> l:</span> 锁定时间</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> r:</span> 返回记录</span><br><span class="line"></span><br><span class="line"> **t:** **查询时间**</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> al:</span>平均锁定时间</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> ar:</span>平均返回记录数</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"> at:</span>平均查询时间</span><br><span class="line"></span><br><span class="line">·    -t: 即为返回前面多少条的数据；</span><br><span class="line"></span><br><span class="line">·    -g: 后边搭配一个正则匹配模式，大小写不敏感的；</span><br><span class="line"></span><br><span class="line">  得到返回记录集最多的<span class="number">10</span>个SQL  mysqldumpslow  -s r -t <span class="number">10</span> <span class="keyword">/var/</span>lib<span class="keyword">/mysql/</span>localhost-slow.log  得到访问次数最多的<span class="number">10</span>个SQL  mysqldumpslow  -s c -t <span class="number">10</span> <span class="keyword">/var/</span>lib<span class="keyword">/mysql/</span>localhost-slow.log  得到按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句  mysqldumpslow  -s t -t <span class="number">10</span> -g  <span class="string">&quot;left join&quot;</span>  <span class="keyword">/var/</span>lib<span class="keyword">/mysql/</span>localhost-slow.log  另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况  mysqldumpslow  -s r -t <span class="number">10</span> <span class="keyword">/var/</span>lib<span class="keyword">/mysql/</span>localhost-slow.log | more  </span><br></pre></td></tr></table></figure><h4 id="130-如何查看当前sql使用了哪个索引？"><a href="#130-如何查看当前sql使用了哪个索引？" class="headerlink" title="130        如何查看当前sql使用了哪个索引？"></a>130        如何查看当前sql使用了哪个索引？</h4><p>可以使用EXPLAIN，选择索引过程可以使用 optimizer_trace</p><h4 id="131-索引如何进行分析和调优？"><a href="#131-索引如何进行分析和调优？" class="headerlink" title="131    索引如何进行分析和调优？"></a>131    索引如何进行分析和调优？</h4><h4 id="132-EXPLAIN关键字中的重要指标有哪些？"><a href="#132-EXPLAIN关键字中的重要指标有哪些？" class="headerlink" title="132    EXPLAIN关键字中的重要指标有哪些？"></a>132    EXPLAIN关键字中的重要指标有哪些？</h4><h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><h3 id="EXPLAIN是什么"><a href="#EXPLAIN是什么" class="headerlink" title="EXPLAIN是什么"></a>EXPLAIN是什么</h3><p>使用EXPLAIN关键字可以<code>模拟优化器执行SQL查询语句</code>，从而知道MySQL是如何处理你的SQL语句的。<code>分析你的查询语句或是表结构的性能瓶颈</code>。</p><h3 id="EXPLAIN的用法"><a href="#EXPLAIN的用法" class="headerlink" title="EXPLAIN的用法"></a>EXPLAIN的用法</h3><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="operator">+</span> <span class="keyword">SQL</span>语句</span><br></pre></td></tr></table></figure><p><strong>数据准备：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content1 <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, content2 <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_content1 <span class="keyword">ON</span> t4(content1);  <span class="comment">-- 普通索引</span></span><br><span class="line"></span><br><span class="line"># 以下新增<span class="keyword">sql</span>多执行几次，以便演示</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t1_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t2_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t3(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t3_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t4(content1, content2) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)), CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="各字段解释"><a href="#各字段解释" class="headerlink" title="各字段解释"></a>各字段解释</h3><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><ul><li><strong>单表：</strong>显示这一行的数据是关于哪张表的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710101402666.png" alt="image-20220710101402666"></p><ul><li><strong>多表关联：</strong>t1为驱动表，t2为被驱动表。</li></ul><p><code>注意：</code>内连接时，MySQL性能优化器会自动判断哪个表是驱动表，哪个表示被驱动表，和书写的顺序无关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220711122444380.png" alt="image-20220711122444380"></p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>表示查询中执行select子句或操作表的顺序</p><ul><li><strong>id相同：</strong>执行顺序由上至下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2, t3;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710000757241.png" alt="image-20220710000757241"></p><ul><li><strong>id不同：</strong>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t1.id <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> t2.id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.id <span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> t3.id <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> t3.content <span class="operator">=</span> <span class="string">&#x27;t3_434&#x27;</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710000950098.png" alt="image-20220710000950098"></p><p><code>注意：</code>查询优化器可能对涉及子查询的语句进行优化，<code>转为连接查询</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220711123408605.png" alt="image-20220711123408605"></p><ul><li><strong>id为NULL：</strong>最后执行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710001512891.png" alt="image-20220710001512891"></p><p><strong>小结：</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li><strong>SIMPLE：</strong>简单查询。查询中不包含子查询或者UNION。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710001930811.png" alt="image-20220710001930811"></p><ul><li><strong>PRIMARY：</strong>主查询。查询中若包含子查询，则最外层查询被标记为PRIMARY。</li><li><strong>SUBQUERY：</strong>子查询。在SELECT或WHERE列表中包含了子查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content<span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710002145309.png" alt="image-20220710002145309"></p><ul><li><strong>DEPENDENT SUBQUREY：</strong>如果包含了子查询，并且查询语句不能被优化器转换为连接查询，并且子查询是<code>相关子查询（子查询基于外部数据列）</code>，则子查询就是DEPENDENT SUBQUREY。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> t3.content);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710002444782.png" alt="image-20220710002444782"></p><ul><li><strong>UNCACHEABLE SUBQUREY：</strong>表示这个subquery的查询要受到外部系统变量的影响</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> @<span class="variable">@character_set_server</span>);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710002604613.png" alt="image-20220710002604613"></p><ul><li><strong>UNION：</strong>对于包含UNION或者UNION ALL的查询语句，除了最左边的查询是PRIMARY，其余的查询都是UNION。</li><li><strong>UNION RESULT：</strong>UNION会对查询结果进行查询去重，MYSQL会使用临时表来完成UNION查询的去重工作，针对这个临时表的查询就是”UNION RESULT”。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">UNION</span>  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710003049587.png" alt="image-20220710003049587"></p><ul><li><strong>DEPENDENT UNION：</strong>子查询中的UNION或者UNION ALL，除了最左边的查询是DEPENDENT SUBQUREY，其余的查询都是DEPENDENT UNION。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2 </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710110732730.png" alt="image-20220710110732730"></p><ul><li><strong>DERIVED：</strong>在包含<code>派生表（子查询在from子句中）</code>的查询中，MySQL会递归执行这些子查询，把结果放在临时表里。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> content, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> content</span><br><span class="line">) <span class="keyword">AS</span> derived_t1 <span class="keyword">WHERE</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>&lt;derived2&gt;</code>就是在id为2的查询中产生的派生表。</p><p><img src="./../assets/image-20220710153504037.png" alt="image-20220710153504037"></p><p><strong>补充：</strong>MySQL在处理带有派生表的语句时，优先尝试把派生表和外层查询进行合并，如果不行，再把派生表<code>物化掉（执行子查询，并把结果放入临时表）</code>，然后执行查询。下面的例子就是就是将派生表和外层查询进行合并的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;t1_832&#x27;</span>) <span class="keyword">AS</span> derived_t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710153921679.png" alt="image-20220710153921679"></p><ul><li><strong>MATERIALIZED：</strong>优化器对于包含子查询的语句，<code>如果选择将子查询物化后再与外层查询连接查询</code>，该子查询的类型就是MATERIALIZED。如下的例子中，查询优化器先将子查询转换成物化表，然后将t1和物化表进行连接查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710155650935.png" alt="image-20220710155650935"></p><h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h4><p>代表分区表中的命中情况，非分区表，该项为NULL</p><h4 id="type-☆"><a href="#type-☆" class="headerlink" title="type ☆"></a>type <strong>☆</strong></h4><blockquote><p><strong>说明：</strong></p><p>结果值从最好到最坏依次是： </p><p><code>system &gt; const &gt; eq_ref &gt; ref</code> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <code>range &gt; index &gt; ALL</code> </p><p><code>比较重要的包含：system、const 、eq_ref 、ref、range &gt; index &gt; ALL</code></p><p>SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，最好是 <code>consts</code>级别。（阿里巴巴<br>开发手册要求）</p></blockquote><ul><li><strong>ALL：</strong>全表扫描。Full Table Scan，将遍历全表以找到匹配的行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712065946659.png" alt="image-20220712065946659"></p><ul><li><strong>index：</strong>当使用<code>覆盖索引</code>，但需要扫描全部的索引记录时</li></ul><p><code>覆盖索引：</code>如果能通过读取索引就可以得到想要的数据，那就不需要读取用户记录，或者不用再做回表操作了。一个索引包含了满足查询结果的数据就叫做覆盖索引。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要读取聚簇索引部分的非叶子节点，就可以得到id的值，不需要查询叶子节点</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712065815768.png" alt="image-20220712065815768"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要读取二级索引，就可以在二级索引中获取到想要的数据，不需要再根据叶子节点中的id做回表操作</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, deptId <span class="keyword">FROM</span> t_emp;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712065922882.png" alt="image-20220712065922882"></p><ul><li><strong>range：</strong>只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712070042666.png" alt="image-20220712070042666"></p><ul><li><strong>ref：</strong>通过普通二级索引列与常量进行等值匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712070727963.png" alt="image-20220712070727963"></p><ul><li><strong>eq_ref：</strong>连接查询时通过主键或不允许NULL值的唯一二级索引列进行等值匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712070851089.png" alt="image-20220712070851089"></p><ul><li><strong>const：</strong>根据<code>主键</code>或者<code>唯一二级索引</code>列与<code>常数</code>进行匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712070944090.png" alt="image-20220712070944090"></p><ul><li><strong>system：</strong>MyISAM引擎中，当表中只有一条记录时。<code>（这是所有type的值中性能最高的场景）</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">int</span>) Engine<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220711125730163.png" alt="image-20220711125730163"></p><p><strong>其他不太常见的类型（了解）：</strong></p><ul><li><strong>index_subquery</strong>：利用<code>普通索引</code>来关联子查询，针对包含有IN子查询的查询语句。<code>content1是普通索引字段</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content1 <span class="keyword">FROM</span> t4 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t4.content2) <span class="keyword">OR</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712071057817.png" alt="image-20220712071057817"></p><ul><li><strong>unique_subquery</strong>：类似于index_subquery，利用<code>唯一索引</code>来关联子查询。<code>t2的id是主键，也可以理解为唯一的索引字段</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t2.content) <span class="keyword">OR</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712071138320.png" alt="image-20220712071138320"></p><ul><li><strong>index_merge</strong>：在查询过程中需要<code>多个索引组合使用</code>，通常出现在有 or 的关键字的sql中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220711132125501.png" alt="image-20220711132125501"></p><ul><li><strong>ref_or_null</strong>：当对普通二级索引进行等值匹配，且该索引列的值也可以是NULL值时。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> deptId <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220711131831315.png" alt="image-20220711131831315"></p><ul><li><strong>fulltext：</strong>全文索引。<code>一般通过搜索引擎实现，这里我们不展开。</code></li></ul><h4 id="possible-keys-和-keys-☆"><a href="#possible-keys-和-keys-☆" class="headerlink" title="possible_keys 和 keys ☆"></a>possible_keys 和 keys <strong>☆</strong></h4><ul><li><p><code>possible_keys</code>表示执行查询时可能用到的索引，一个或多个。 查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p></li><li><p><code>keys</code>表示实际使用的索引。如果为NULL，则没有使用索引。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710142152514.png" alt="image-20220710142152514"></p><h4 id="key-len-☆"><a href="#key-len-☆" class="headerlink" title="key_len ☆"></a>key_len <strong>☆</strong></h4><p>表示索引使用的字节数，根据这个值可以判断索引的使用情况，<code>检查是否充分利用了索引，针对联合索引值越大越好。</code></p><p><strong>如何计算：</strong></p><ol><li>先看索引上字段的类型+长度。比如：int=4 ; varchar(20) =20 ; char(20) =20 </li><li>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf8要乘 3，如果是utf8mb4要乘4，GBK要乘2</li><li>varchar这种动态字符串要加2个字节</li><li>允许为空的字段要加1个字节 </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> t_emp(age, `name`);</span><br><span class="line"><span class="comment">-- 测试1</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> `name` <span class="operator">=</span> <span class="string">&#x27;ab%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 测试2</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710130548971.png" alt="image-20220710130548971"></p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示与key中的索引进行比较的列或常量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ref=atguigudb.t1.id   关联查询时出现，t2表和t1表的哪一列进行关联</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ref=const  与索引列进行等值比较的东西是啥，const表示一个常数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220709211819944.png" alt="image-20220709211819944"></p><h4 id="rows-☆"><a href="#rows-☆" class="headerlink" title="rows ☆"></a>rows <strong>☆</strong></h4><p>MySQL认为它执行查询时必须检查的行数。值越小越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果是全表扫描，rows的值就是表中数据的估计行数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> empno <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果是使用索引查询，rows的值就是预计扫描索引记录行数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710131916240.png" alt="image-20220710131916240"></p><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>最后查询出来的数据占所有服务器端检查行数（rows）的<code>百分比</code>。值越大越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先根据二级索引deptId找到数据的主键，有3条记录满足条件，</span></span><br><span class="line"><span class="comment">-- 再根据主键进行回表，最终找到3条记录，有100%的记录满足条件</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个例子如果name列是索引列则 filtered = 100 否则filtered = 10(全表扫描)</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;风清扬&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220709212722601.png" alt="image-20220709212722601"></p><h4 id="Extra-☆"><a href="#Extra-☆" class="headerlink" title="Extra ☆"></a>Extra <strong>☆</strong></h4><p>包含不适合在其他列中显示但十分重要的额外信息。通过这些额外信息来<code>理解MySQL到底将如何执行当前的查询语句</code>。MySQL提供的额外信息有好几十个，这里只挑介绍比较重要的介绍。</p><ul><li><strong>Impossible WHERE</strong>：where子句的值总是false</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220709231638201.png" alt="image-20220709231638201"></p><ul><li><strong>Using where：</strong>使用了where，但在where上有字段没有创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;风清扬&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220709215122017.png" alt="image-20220709215122017"></p><ul><li><strong>Using temporary：</strong>使了用临时表保存中间结果</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> content <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710181100102.png" alt="image-20220710181100102"></p><ul><li><strong>Using filesort：</strong></li></ul><p>在对查询结果中的记录进行排序时，是可以使用索引的，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710172607190.png" alt="image-20220710172607190"></p><p>如果排序操作无法使用到索引，只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序（filesort），如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> content;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710172926396.png" alt="image-20220710172926396"></p><ul><li><strong>Using index：</strong>使用了覆盖索引，表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, content1 <span class="keyword">FROM</span> t4;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712071716131.png" alt="image-20220712071716131"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220712072055566.png" alt="image-20220712072055566"></p><ul><li><strong>Using index condition：</strong>叫作  <code>Index Condition Pushdown Optimization （索引下推优化）</code><ul><li><code>如果没有索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给server层，server层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 &gt; &#39;z&#39; AND content1 LIKE &#39;%a&#39;</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给server层。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- content1列上有索引idx_content1</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t4 <span class="keyword">WHERE</span> content1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> content1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710180257692.png" alt="image-20220710180257692"></p><p><strong>注意：</strong>如果这里的查询条件<code>只有content1 &gt; &#39;z&#39;</code>，那么找到满足条件的索引后也会进行一次索引下推的操作，判断content1 &gt; ‘z’是否成立（这是源码中为了编程方便做的冗余判断）</p><p><img src="./../assets/image-20220712012108900.png" alt="image-20220712012108900"></p><ul><li><strong>Using join buffer：</strong>在连接查询时，当被驱动表不能有效的利用索引时，MySQL会为其分配一块名为连接缓冲区（join buffer）的内存来加快查询速度</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t2.content;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710182356817.png" alt="image-20220710182356817"></p><p>下面这个例子就是被驱动表使用了索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp, t_dept <span class="keyword">WHERE</span> t_dept.id <span class="operator">=</span> t_emp.deptId;</span><br></pre></td></tr></table></figure><p><img src="./../assets/image-20220710182524371.png" alt="image-20220710182524371"></p><h3 id="133-MySQL数据库cpu飙升的话你会如何分析"><a href="#133-MySQL数据库cpu飙升的话你会如何分析" class="headerlink" title="133 MySQL数据库cpu飙升的话你会如何分析"></a>133 MySQL数据库cpu飙升的话你会如何分析</h3><p>重点是定位问题。</p><p>先</p><p><strong>1 使用top观察mysqld的cpu利用率</strong></p><ol><li><p>切换到常用的数据库</p></li><li><p>使用show full processlist;查看会话</p></li><li><p>观察是哪些sql消耗了资源，其中重点观察state指标</p></li><li><p>定位到具体sql</p></li></ol><p><strong>2 pidstat</strong> </p><ol><li>定位到线程</li><li>在PERFORMANCE_SCHEMA.THREADS中记录了thread_os_id 找到线程执行的sql</li><li>根据操作系统id可以到processlist表找到对应的会话</li><li>在会话中即可定位到问题sql</li></ol><p><strong>3 使用show profile观察sql各个阶段耗时</strong></p><p><strong>4 服务器上是否运行了其他程序</strong></p><p><strong>5 检查一下是否有慢查询</strong></p><p><strong>6 pref top</strong></p><p>使用pref 工具分析哪些函数引发的cpu过高来追踪定位</p><p><img src="./../assets/image-20221106160437906.png" alt="image-20221106160437906"></p><h3 id="134-有没有进行过分库分表？"><a href="#134-有没有进行过分库分表？" class="headerlink" title="134 有没有进行过分库分表？"></a>134 有没有进行过分库分表？</h3><h4 id="135-什么是分库分表？"><a href="#135-什么是分库分表？" class="headerlink" title="135     什么是分库分表？"></a>135     什么是分库分表？</h4><p><strong>垂直分库</strong></p><p>一个数据库由很多表的构成，每个表对应着<strong>不同的业务</strong>，垂直切分是指按照业务将表进行分类，分布到不同 的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：       </p><p>​                <img src="./../assets/111.jpg" alt="">   </p><p>系统被切分成了，用户，订单交易，支付几个模块。</p><p><strong>水平分表</strong></p><p>把一张表里的内容按照不同的规则 写到不同的库里</p><p>相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中，如图： </p><p><img src="./../assets/222.jpg" alt=""></p><h4 id="136-什么时候进行分库分表？有没有配合es使用经验？"><a href="#136-什么时候进行分库分表？有没有配合es使用经验？" class="headerlink" title="136     什么时候进行分库分表？有没有配合es使用经验？"></a>136     什么时候进行分库分表？有没有配合es使用经验？</h4><ol><li>能不分就不分</li><li>单机性能下降明显的时候</li><li>增加缓存（通常查询量比较大），细分业务</li><li>首先尝试主被集群，读写分离</li><li>尝试分库</li><li>尝试分表 -&gt; 冷热数据分离</li></ol><p>大数据量下可以配合es完成高效查询</p><h4 id="137-说一下实现分库分表工具的实现思路"><a href="#137-说一下实现分库分表工具的实现思路" class="headerlink" title="137     说一下实现分库分表工具的实现思路"></a>137     说一下实现分库分表工具的实现思路</h4><ol><li>伪装成mysql服务器，代理用户请求转发到真实服务器</li><li>基于本地aop实现，拦截sql，改写，路由和结果归集处理。</li></ol><h4 id="138-用过哪些分库分表工具？"><a href="#138-用过哪些分库分表工具？" class="headerlink" title="138     用过哪些分库分表工具？"></a>138     用过哪些分库分表工具？</h4><p><img src="./../assets/25723371_16499183725J8d.png" alt="img"></p><h4 id="139-分库分表后可能会有哪些问题？"><a href="#139-分库分表后可能会有哪些问题？" class="headerlink" title="139     分库分表后可能会有哪些问题？"></a>139     分库分表后可能会有哪些问题？</h4><p>经典的问题</p><ol><li>执行效率明显降低</li><li>表结构很难再次调整</li><li>引发分布式id问题</li><li>产生跨库join</li><li>代理类中间件网络io成为瓶颈</li></ol><h4 id="140-说一下读写分离常见方案？"><a href="#140-说一下读写分离常见方案？" class="headerlink" title="140     说一下读写分离常见方案？"></a>140     说一下读写分离常见方案？</h4><p><img src="./../assets/image-20221106171251532.png" alt="image-20221106171251532"></p><p><img src="./../assets/image-20221106171945037.png" alt="image-20221106171945037"></p><h3 id="141-为什么要使用视图？-什么是视图？"><a href="#141-为什么要使用视图？-什么是视图？" class="headerlink" title="141 为什么要使用视图？ 什么是视图？"></a>141 为什么要使用视图？ 什么是视图？</h3><p>视图定义：<br>1、视图是一个虚表，是从一个或几个基本表（或视图）导出的表。<br>2、只存放视图的定义，不存放视图对应的数据。<br>3、基表中的数据发生变化，从视图中查询出的数据也随之改变。<br>视图的作用：<br>1、视图能够简化用户的操作<br>2、视图使用户能以多种角度看待同一数据<br>3、视图对重构数据库提供了一定程度的逻辑独立性<br>4、视图能够对机密数据提供安全保护<br>5、适当的利用视图可以更清晰的表达查询</p><h3 id="142-什么是存储过程？有没有使用过？"><a href="#142-什么是存储过程？有没有使用过？" class="headerlink" title="142 什么是存储过程？有没有使用过？"></a>142 什么是存储过程？有没有使用过？</h3><p>项目中禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</p><h3 id="143-有没有使用过外键？有什么需要注意的地方？"><a href="#143-有没有使用过外键？有什么需要注意的地方？" class="headerlink" title="143 有没有使用过外键？有什么需要注意的地方？"></a>143 有没有使用过外键？有什么需要注意的地方？</h3><p>不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><h3 id="144-用过processlist吗？"><a href="#144-用过processlist吗？" class="headerlink" title="144 用过processlist吗？"></a>144 用过processlist吗？</h3><p>关键的就是state列，mysql列出的状态主要有以下几种：</p><ul><li>Checking table<br>正在检查数据表（这是自动的）。</li><li>Closing tables<br>正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</li><li>Connect Out<br>复制从服务器正在连接主服务器。</li><li>Copying to tmp table on disk<br>由于临时结果集大于tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。</li><li>Creating tmp table<br>正在创建临时表以存放部分查询结果。</li><li>deleting from main table<br>服务器正在执行多表删除中的第一部分，刚删除第一个表。</li><li>deleting from reference tables<br>服务器正在执行多表删除中的第二部分，正在删除其他表的记录。</li><li>Flushing tables<br>正在执行FLUSH TABLES，等待其他线程关闭数据表。</li><li>Killed<br>发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。</li><li>Locked<br>被其他查询锁住了。</li><li>Sending data<br>正在处理Select查询的记录，同时正在把结果发送给客户端。Sending data”状态的含义，原来这个状态的名称很具有误导性，所谓的“Sending data”并不是单纯的发送数据，而是包括“收集 + 发送 数据”。</li><li>Sorting for group<br>正在为GROUP BY做排序。</li><li>Sorting for order<br>正在为ORDER BY做排序。</li><li>Opening tables<br>这个过程应该会很快，除非受到其他因素的干扰。例如，在执Alter TABLE或LOCK TABLE语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。</li><li>Removing duplicates<br>正在执行一个Select DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。</li><li>Reopen table<br>获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。</li><li>Repair by sorting<br>修复指令正在排序以创建索引。</li><li>Repair with keycache<br>修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。</li><li>Searching rows for update<br>正在讲符合条件的记录找出来以备更新。它必须在Update要修改相关的记录之前就完成了。</li><li>Sleeping<br>正在等待客户端发送新请求.</li><li>System lock<br>正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求同一个表，那么可以通过增加—skip-external-locking参数来禁止外部系统锁。</li><li>Upgrading lock<br>Insert DELAYED正在尝试取得一个锁表以插入新记录。=</li><li>Updating<br>正在搜索匹配的记录，并且修改它们。</li><li>User Lock<br>正在等待GET_LOCK()。</li><li>Waiting for tables<br>该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, Alter TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE,或OPTIMIZE TABLE。</li><li>waiting for handler insert<br>Insert DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求。</li></ul><h3 id="145-某个表有数千万数据，查询比较慢，如何优化？说一下思路"><a href="#145-某个表有数千万数据，查询比较慢，如何优化？说一下思路" class="headerlink" title="145 某个表有数千万数据，查询比较慢，如何优化？说一下思路"></a>145 某个表有数千万数据，查询比较慢，如何优化？说一下思路</h3><ol><li>前端优化 减少查询<ol><li>合并请求:多个请求需要的数据尽量一条sql拿出来</li><li>会话保存：和用户会话相关的数据尽量一次取出重复使用</li><li>避免无效刷新</li></ol></li><li>多级缓存 不要触及到数据库<ol><li>应用层热点数据高速查询缓存（低一致性缓存）</li><li>高频查询大数据量镜像缓存（双写高一致性缓存）</li><li>入口层缓存（几乎不变的系统常量）</li></ol></li><li>使用合适的字段类型，比如varchar换成char</li><li>一定要高效使用索引。<ol><li>使用explain 深入观察索引使用情况</li><li>检查select 字段最好满足索引覆盖</li><li>复合索引注意观察key_len索引使用情况</li><li>有分组，排序，注意file sort，合理配置相应的buffer大小</li></ol></li><li>检查查询是否可以分段查询，避免一次拿出过多无效数据</li><li>多表关联查询是否可以设置冗余字段，是否可以简化多表查询或分批查询</li><li>分而治之：把服务拆分成更小力度的微服务</li><li>冷热数据分库存储</li><li>读写分离，主被集群 然后再考虑分库分表</li><li>等</li></ol><h3 id="146-count-列名-和-count-有什么区别？"><a href="#146-count-列名-和-count-有什么区别？" class="headerlink" title="146 count(列名)和 count(*)有什么区别？"></a>146 count(列名)和 count(*)有什么区别？</h3><p>count(<em>)是 SQL92 定义的<br>标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>说明：count(</em>)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p><h3 id="147-如果有超大分页改怎么处理？"><a href="#147-如果有超大分页改怎么处理？" class="headerlink" title="147 如果有超大分页改怎么处理？"></a>147 如果有超大分页改怎么处理？</h3><ul><li><p><code>select name from user limit 10000,10;</code>在 使用的时候并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行</p></li><li><p>通过索引优化的方案：</p><ul><li>如果主键自增可以 <code>select name from user where id &gt; 10000 limit 10;</code></li><li>延迟关联</li><li>需要order by时<ul><li>一定注意增加筛选条件，避免全表排序<ul><li>where  -》 order by -》 limit</li></ul></li><li>减少select字段</li><li>优化相关参数避免filesort</li></ul></li></ul></li><li><p>一般大分页情况比较少（很少有人跳转到几百万页去查看数据），实际互联网业务中多数还是按顺序翻页，可以使用缓存提升前几页的查询效率，实际上大多数知名互联网项目也都是这么做的</p></li></ul><p>在阿里巴巴《Java开发手册》中的建议：</p><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p><h3 id="148-mysql服务器毫无规律的异常重启如何排查问题？"><a href="#148-mysql服务器毫无规律的异常重启如何排查问题？" class="headerlink" title="148 mysql服务器毫无规律的异常重启如何排查问题？"></a>148 mysql服务器毫无规律的异常重启如何排查问题？</h3><p>首先是查看mysql和系统日志来定位错误</p><p><strong>最常见的是关闭swap分区后OOM问题：</strong></p><p>mysql 分为应用进程和守护进程</p><p>当应用进程内存占用过高的时候操作系统可能会kill掉进程，此时守护进程又帮我们重启了应用进程，运行一段时间后又出现OOM如此反复</p><p>可以排查以下几个关键点</p><ul><li>运行时内存占用率</li><li>mysql buffer相关参数</li><li>mysql 网络连接相关参数</li></ul><p><strong>异常关机或kill -9 mysql 后导致表文件损坏</strong></p><ul><li>直接使用备份</li><li>配置 innodb_force_recovery 跳过启动恢复过程</li></ul><h4 id="149-mysql-线上修改表结构有哪些风险"><a href="#149-mysql-线上修改表结构有哪些风险" class="headerlink" title="149 mysql 线上修改表结构有哪些风险?"></a>149 mysql 线上修改表结构有哪些风险?</h4><p>针对ddl命令，有以下几种方式</p><ul><li>copy table  锁原表，创建临时表并拷贝数据</li><li>inplace 针对索引修改删除的优化，不需要拷贝所有数据</li><li>Online DDL 细分DDL命令来决定是否锁表</li></ul><ul><li>可能会锁表，导致无法读写</li><li>ORM中的映射失效</li><li>索引失效</li></ul><p>建议：建个新表，导入数据后重命名</p><h3 id="150-什么是mysql多实例部署？"><a href="#150-什么是mysql多实例部署？" class="headerlink" title="150 什么是mysql多实例部署？"></a>150 什么是mysql多实例部署？</h3><p>指的是在一台主机上部署多个实例</p><p>主要目的是压榨服务器性能</p><p>缺点是互相影响</p>]]></content>
    
    
    <summary type="html">mysql review</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>test_review</title>
    <link href="https://www.fomal.cc/posts/ee9a86e8.html"/>
    <id>https://www.fomal.cc/posts/ee9a86e8.html</id>
    <published>2024-10-01T02:40:35.000Z</published>
    <updated>2024-10-04T10:39:27.728Z</updated>
    
    <content type="html"><![CDATA[<p>帮我详细介绍一下等价类划分，并用实际通俗易懂的例子来讲解下边的语句概述：</p><p><a href="https://www.yuque.com/tuobaaxiu/inyebp/ubhagqr51ggqabe8?singleDoc#">https://www.yuque.com/tuobaaxiu/inyebp/ubhagqr51ggqabe8?singleDoc#</a> 《测试开发八股整理》 密码: ehg0</p><p>==回归测试是什么意思==</p><p>回归测试（Regression Testing）是软件测试中的一种类型，旨在确保在软件修改或更新之后，原本正常运行的功能依然保持正常。它的主要目的是验证代码更改没有引入新的缺陷或问题，并且原有功能不受影响。回归测试通常在以下情况下进行：</p><ol><li><strong>修复了一个或多个缺陷</strong>：在开发人员修复缺陷后，回归测试会验证这些修复是否影响了系统的其他功能。</li><li><strong>添加新功能或修改现有功能</strong>：在新功能或功能变更后，回归测试确保新旧功能能够正确协同工作。</li><li><strong>性能或安全性优化</strong>：对于性能或安全方面的优化，回归测试也会确保优化不会破坏现有的功能。</li></ol><h3 id="回归测试的执行方式"><a href="#回归测试的执行方式" class="headerlink" title="回归测试的执行方式"></a>回归测试的执行方式</h3><ul><li><strong>手动回归测试</strong>：测试人员基于现有的测试用例集，手动重新执行所有或部分测试用例。</li><li><strong>自动化回归测试</strong>：通过自动化测试工具（如Selenium、JUnit等）执行测试，能够提高效率，尤其是在频繁更新的项目中。</li></ul><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><strong>测试范围</strong>：虽然理想情况下，回归测试应该覆盖所有功能，但实际中会根据风险、功能的重要性等因素来选择部分测试用例进行执行。</li><li><strong>测试频率</strong>：回归测试通常在每次代码更新、补丁、修复或功能改动后进行，以确保系统的整体稳定性。</li></ul><p>总结来说，回归测试是为了保证在软件变更后，现有功能依旧正常工作，不会因新的改动引发新的问题。</p><p>软件测试结果的测量单位是？</p><p>软件测试结果的测量单位通常没有一个固定的标准单位，但测试结果常通过一系列指标来衡量和评估。这些指标有助于测试团队和项目干系人了解软件质量、测试进展和缺陷状况。以下是常见的用于衡量软件测试结果的指标及其对应的“单位”：</p><h3 id="1-缺陷（Bug）相关单位"><a href="#1-缺陷（Bug）相关单位" class="headerlink" title="1. 缺陷（Bug）相关单位"></a>1. <strong>缺陷（Bug）相关单位</strong></h3><ul><li><strong>缺陷数量（Number of Bugs）</strong>：报告或发现的缺陷总数，单位是”个”。</li><li><strong>缺陷密度（Defect Density）</strong>：每千行代码（KLOC）或每个功能点（Function Point）中的缺陷数，单位是“缺陷数/千行代码”或“缺陷数/功能点”。</li><li><strong>缺陷修复率（Defect Fix Rate）</strong>：修复的缺陷数量与报告的缺陷数量的比例，通常以百分比表示，单位为“%”。</li><li><strong>缺陷分类</strong>：按照严重程度（如致命、严重、一般、轻微）或优先级分类的缺陷数量，单位是”个”。</li></ul><h3 id="2-测试进度相关单位"><a href="#2-测试进度相关单位" class="headerlink" title="2. 测试进度相关单位"></a>2. <strong>测试进度相关单位</strong></h3><ul><li><strong>测试用例执行数量（Number of Test Cases Executed）</strong>：执行的测试用例总数，单位是”个”。</li><li><strong>测试通过率（Test Pass Rate）</strong>：通过的测试用例数与总测试用例数的比率，通常以百分比表示，单位为“%”。</li><li><strong>测试覆盖率（Test Coverage）</strong>：测试用例覆盖代码、功能、需求的比率，通常以百分比表示，单位为“%”。</li><li><strong>测试执行时间（Test Execution Time）</strong>：测试的总执行时间，单位是“小时”或“分钟”。</li></ul><h3 id="3-软件质量相关单位"><a href="#3-软件质量相关单位" class="headerlink" title="3. 软件质量相关单位"></a>3. <strong>软件质量相关单位</strong></h3><ul><li><strong>失败率（Failure Rate）</strong>：在给定时间段内系统或软件失败的次数，单位是“次/小时”或“次/天”。</li><li><strong>平均修复时间（Mean Time to Repair, MTTR）</strong>：从发现缺陷到修复缺陷所需的平均时间，单位是“小时”或“天”。</li><li><strong>平均无故障时间（Mean Time Between Failures, MTBF）</strong>：两次故障之间的平均时间，单位是“小时”或“天”。</li></ul><h3 id="4-其他相关单位"><a href="#4-其他相关单位" class="headerlink" title="4. 其他相关单位"></a>4. <strong>其他相关单位</strong></h3><ul><li><strong>资源使用率（Resource Utilization）</strong>：测试过程中，CPU、内存等系统资源的使用比例，单位是“%”。</li><li><strong>测试覆盖代码行数（Lines of Code Covered）</strong>：自动化测试中，覆盖的代码行数，单位是“行”。</li></ul><p>==软件测试的QPS和TPS的区别==</p><p>在软件测试中，<strong>QPS（Queries Per Second）</strong>和<strong>TPS（Transactions Per Second）</strong>是两个常用的性能指标，分别用于衡量系统处理请求或事务的能力。尽管它们都是性能测试中常用的单位，但适用于不同的场景，区别如下：</p><h3 id="1-QPS（Queries-Per-Second）"><a href="#1-QPS（Queries-Per-Second）" class="headerlink" title="1. QPS（Queries Per Second）"></a>1. <strong>QPS（Queries Per Second）</strong></h3><ul><li><strong>定义</strong>：QPS表示系统每秒能够处理的请求数量，通常用于衡量一个系统或服务（尤其是网络服务、数据库查询、API接口等）的并发处理能力。</li><li><strong>适用场景</strong>：QPS通常用于Web应用、API服务、数据库等场景，重点在于每秒处理的<strong>请求</strong>数。例如，在搜索引擎中，QPS衡量每秒处理的查询请求数。</li><li><strong>计算方式</strong>：QPS = 请求的总数 / 时间（以秒为单位）</li><li><strong>重点</strong>：QPS更关注的是单个请求的处理能力，且这些请求不一定包含多个操作。一个请求通常是一个较小的操作，如一次HTTP请求或一次数据库查询。</li></ul><h3 id="2-TPS（Transactions-Per-Second）"><a href="#2-TPS（Transactions-Per-Second）" class="headerlink" title="2. TPS（Transactions Per Second）"></a>2. <strong>TPS（Transactions Per Second）</strong></h3><ul><li><strong>定义</strong>：TPS表示系统每秒能够处理的事务数量。一个事务通常是由多个步骤组成的操作集合，涉及多次请求、读写数据库、业务逻辑处理等。</li><li><strong>适用场景</strong>：TPS一般用于复杂的业务系统中，特别是在金融系统、电子商务系统等有明确事务定义的场景。事务通常包含一组相关的操作，比如银行转账包括检查账户余额、扣款、加款等多个步骤。</li><li><strong>计算方式</strong>：TPS = 事务的总数 / 时间（以秒为单位）</li><li><strong>重点</strong>：TPS更关注的是一个完整的事务处理过程，而每个事务可能包含多个请求，因此它评估的是系统在处理多步操作时的吞吐量。</li></ul><h3 id="两者的主要区别"><a href="#两者的主要区别" class="headerlink" title="两者的主要区别"></a><strong>两者的主要区别</strong></h3><ol><li><p><strong>概念层次不同</strong>：</p><ul><li><strong>QPS</strong>：衡量的是单个请求的处理能力，较为简单的操作。</li><li><strong>TPS</strong>：衡量的是一组操作（即事务）的处理能力，一个事务可能包含多个请求。</li></ul></li><li><p><strong>适用场景不同</strong>：</p><ul><li><strong>QPS</strong>：适用于Web请求、API调用、数据库查询等单一请求场景。</li><li><strong>TPS</strong>：适用于包含多个步骤或操作的业务事务场景，通常是具有复杂逻辑的系统，如金融、交易系统等。</li></ul></li><li><p><strong>复杂度不同</strong>：</p><ul><li><strong>QPS</strong>：通常较为简单，只涉及一次请求和响应。</li><li><strong>TPS</strong>：更复杂，事务由多步操作组成，需要更长的时间来完成。</li></ul></li></ol><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul><li><p><strong>QPS例子</strong>：一个用户向搜索引擎发送查询请求，系统返回查询结果。此处一个查询就是一次请求，若该搜索引擎每秒能处理1000个查询请求，则它的QPS为1000。</p></li><li><p><strong>TPS例子</strong>：一个银行转账事务，包括用户验证、扣除转账金额、增加接收账户余额、记录日志等操作。这是一组事务操作，若系统每秒能处理100个完整的转账操作，则它的TPS为100。</p></li></ul><p>总的来说，<strong>QPS</strong>主要关注请求处理能力，而<strong>TPS</strong>则侧重事务处理的整体效率。</p><p>==帮我详细介绍一下等价类划分，并用实际通俗易懂的例子来讲解下边的语句概述：==<br>==等价类划分：把可能的数据输⼊集合分为若⼲⼦集，每个⼦集中的⼦集内的元素对于揭露程序中的错误都是等效==<br>==的，在每个等价类中取的数据⽤来测试，⽐较有代表性。 先划分等价类，“有效等价类”和“⽆效等价类”，根据划分==<br>==的等价类编写测试。==</p><h3 id="等价类划分简介"><a href="#等价类划分简介" class="headerlink" title="等价类划分简介"></a>等价类划分简介</h3><p><strong>等价类划分</strong>是一种常用的软件测试设计技术，它通过将可能的数据输入划分为多个子集（即等价类），每个等价类中的数据被认为是等效的，这意味着它们在测试中能揭示相同类型的错误。因此，在每个等价类中只需选择一个有代表性的数据进行测试，而不需要逐一测试每个可能的输入。这样做可以大大减少测试用例的数量，同时保持较高的测试覆盖率。</p><p>等价类划分主要分为两类：</p><ol><li><strong>有效等价类</strong>：这类输入是合法的、符合需求规范的。例如，输入在规定范围内的数据。</li><li><strong>无效等价类</strong>：这类输入是不合法的、不符合需求规范的。例如，输入超出规定范围的非法数据。</li></ol><h3 id="等价类划分的主要步骤"><a href="#等价类划分的主要步骤" class="headerlink" title="等价类划分的主要步骤"></a>等价类划分的主要步骤</h3><ol><li>分析输入条件，识别可能的输入范围。</li><li>将输入范围划分为多个等价类（包括有效和无效等价类）。</li><li>从每个等价类中选择一个测试数据作为代表进行测试。</li></ol><h3 id="实际通俗易懂的例子"><a href="#实际通俗易懂的例子" class="headerlink" title="实际通俗易懂的例子"></a>实际通俗易懂的例子</h3><p>假设我们在测试一个用户年龄输入的功能，要求是：</p><ul><li>年龄的输入必须是 0 到 120 之间的整数值，且必须是整数。</li></ul><h4 id="1-有效等价类的划分"><a href="#1-有效等价类的划分" class="headerlink" title="1. 有效等价类的划分"></a>1. <strong>有效等价类的划分</strong></h4><ul><li>合法的年龄输入范围是 0 到 120 之间的整数。</li><li><p>这里可以将输入划分为以下几个有效等价类：</p><ul><li>0 到 120 之间的整数（有效输入，符合要求）。</li></ul><p><strong>有效等价类划分</strong>：</p></li><li>[0, 120]：比如选择一个代表性的数值，如“25”作为测试数据。</li></ul><h4 id="2-无效等价类的划分"><a href="#2-无效等价类的划分" class="headerlink" title="2. 无效等价类的划分"></a>2. <strong>无效等价类的划分</strong></h4><ul><li><p>不合法的输入可以从以下几方面考虑：</p><ul><li>小于 0 的数值。</li><li>大于 120 的数值。</li><li>非整数（如小数或字符串）。</li></ul><p><strong>无效等价类划分</strong>：</p></li><li>小于 0 的输入：例如 -1（代表所有小于 0 的数）。</li><li>大于 120 的输入：例如 130（代表所有大于 120 的数）。</li><li>非整数：如 25.5 或“abc”（代表非整数或非数字的输入）。</li></ul><h4 id="3-测试用例设计"><a href="#3-测试用例设计" class="headerlink" title="3. 测试用例设计"></a>3. <strong>测试用例设计</strong></h4><p>根据上面的等价类划分，我们可以设计出以下几种测试用例：</p><ul><li><p><strong>有效等价类</strong>：</p><ol><li>输入年龄为 25（取自有效等价类 0 到 120 范围内的一个数）。<ul><li>预期结果：输入有效，系统接受该输入。</li></ul></li></ol></li><li><p><strong>无效等价类</strong>：</p><ol><li>输入年龄为 -1（取自小于 0 的无效等价类）。<ul><li>预期结果：输入无效，系统拒绝该输入。</li></ul></li><li>输入年龄为 130（取自大于 120 的无效等价类）。<ul><li>预期结果：输入无效，系统拒绝该输入。</li></ul></li><li>输入年龄为 25.5（取自非整数的无效等价类）。<ul><li>预期结果：输入无效，系统拒绝该输入。</li></ul></li><li>输入年龄为 “abc”（取自非数字的无效等价类）。<ul><li>预期结果：输入无效，系统拒绝该输入。</li></ul></li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过<strong>等价类划分</strong>，我们能够有效减少测试用例数量，同时确保覆盖了所有可能的输入情况。在每个等价类中，只需要选择一个有代表性的测试数据，这样既节省了测试资源，又确保了测试的代表性和全面性。</p><p>==帮我详细介绍一下边界值分析，并用实际通俗易懂的例子来讲解下边的语句概述： 边界值分析：选取指定数据集中的边界值进⾏测试。上点，内点，离点==</p><h3 id="边界值分析简介"><a href="#边界值分析简介" class="headerlink" title="边界值分析简介"></a>边界值分析简介</h3><p><strong>边界值分析</strong>是一种常用的测试设计技术，专门用来发现那些在输入数据的边界附近容易出现的错误。很多系统中的缺陷往往出现在输入的极限（即边界）处，因此对边界条件进行测试非常重要。通过测试边界值，我们可以更容易找到隐藏的缺陷。</p><p>边界值分析通常与<strong>等价类划分</strong>一起使用，它的核心思想是选择那些接近边界的输入点进行测试，包括<strong>上点</strong>（即最大边界）、<strong>下点</strong>（即最小边界）以及其<strong>边界内点</strong>和<strong>边界外点</strong>。</p><h3 id="边界值类型"><a href="#边界值类型" class="headerlink" title="边界值类型"></a>边界值类型</h3><p>在进行边界值分析时，我们通常会选择以下几个位置的值进行测试：</p><ol><li><strong>上点</strong>：接近边界的最大值或最小值，比如最大合法值或最小合法值。</li><li><strong>内点</strong>：在合法输入范围内接近边界但不等于边界的值。</li><li><strong>离点</strong>：超出边界的值，即非法值。它们超出最大或最小合法值的范围，用来验证系统如何处理非法输入。</li></ol><h3 id="实际通俗易懂的例子-1"><a href="#实际通俗易懂的例子-1" class="headerlink" title="实际通俗易懂的例子"></a>实际通俗易懂的例子</h3><p>假设我们在测试一个系统要求用户输入一个 1 到 100 之间的整数值，边界值分析可以帮助我们设计更具针对性的测试用例。</p><h4 id="边界值分析步骤"><a href="#边界值分析步骤" class="headerlink" title="边界值分析步骤"></a><strong>边界值分析步骤</strong></h4><ol><li><strong>确定边界范围</strong>：合法输入范围为 1 到 100 之间的整数。</li><li><strong>选择边界值</strong>：我们需要选择靠近这个范围边界的输入值进行测试。</li></ol><h4 id="测试值类型的选择"><a href="#测试值类型的选择" class="headerlink" title="测试值类型的选择"></a><strong>测试值类型的选择</strong></h4><ol><li><strong>上点</strong>：最大合法值和最小合法值。</li><li><strong>内点</strong>：在合法范围内，但接近边界的值。</li><li><strong>离点</strong>：超出边界的非法值。</li></ol><h4 id="具体的测试用例设计："><a href="#具体的测试用例设计：" class="headerlink" title="具体的测试用例设计："></a>具体的测试用例设计：</h4><div class="table-container"><table><thead><tr><th>边界值类型</th><th>测试值</th><th>说明</th></tr></thead><tbody><tr><td>下点</td><td>1</td><td>最小合法值</td></tr><tr><td>内点</td><td>2</td><td>接近下边界但在范围内</td></tr><tr><td>离点</td><td>0</td><td>小于最小值（非法值）</td></tr><tr><td>上点</td><td>100</td><td>最大合法值</td></tr><tr><td>内点</td><td>99</td><td>接近上边界但在范围内</td></tr><tr><td>离点</td><td>101</td><td>大于最大值（非法值）</td></tr></tbody></table></div><h3 id="边界值解释"><a href="#边界值解释" class="headerlink" title="边界值解释"></a><strong>边界值解释</strong></h3><ol><li><p><strong>下点测试值：1</strong></p><ul><li>这是输入的最小合法值，用来验证系统是否正确接受最小合法输入。</li><li>预期结果：系统应该接受输入。</li></ul></li><li><p><strong>内点测试值：2</strong></p><ul><li>这是紧挨着最小合法值的一个数，用来验证在最小值附近但仍合法的输入是否被正确处理。</li><li>预期结果：系统应该接受输入。</li></ul></li><li><p><strong>离点测试值：0</strong></p><ul><li>这是一个非法值（小于最小合法值），用于测试系统是否能够正确拒绝超出下边界的输入。</li><li>预期结果：系统应该拒绝输入并返回错误提示。</li></ul></li><li><p><strong>上点测试值：100</strong></p><ul><li>这是输入的最大合法值，用来验证系统是否正确接受最大合法输入。</li><li>预期结果：系统应该接受输入。</li></ul></li><li><p><strong>内点测试值：99</strong></p><ul><li>这是紧挨着最大合法值的一个数，用来验证在最大值附近但仍合法的输入是否被正确处理。</li><li>预期结果：系统应该接受输入。</li></ul></li><li><p><strong>离点测试值：101</strong></p><ul><li>这是一个非法值（大于最大合法值），用于测试系统是否能够正确拒绝超出上边界的输入。</li><li>预期结果：系统应该拒绝输入并返回错误提示。</li></ul></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过<strong>边界值分析</strong>，我们能够设计出覆盖输入边界条件的测试用例，确保系统在边界处能够正确处理各种输入。这种方法特别适合测试系统中的<strong>极限条件</strong>，比如输入最大值、最小值、以及超出边界的值。通过对上点、内点和离点的精细测试，能有效发现很多边界处理上的潜在问题，从而提高测试的全面性和有效性。</p><p>==帮我详细介绍一下测试⽤例的组成元素，并用实际通俗易懂的例子来讲解下边的语句概述： 测试⽤例的组成元素 ⽤例编号 ⽤例标题 功能模块名称 前置条件 输⼊数据 操作步骤 预期结果 优先级 执⾏结果 编写⼈ 执⾏⼈ 其他补充项==</p><h3 id="测试用例的组成元素"><a href="#测试用例的组成元素" class="headerlink" title="测试用例的组成元素"></a>测试用例的组成元素</h3><p><strong>测试用例</strong>是软件测试中非常重要的文档，它详细描述了在特定条件下如何测试某个功能模块，预期结果是什么，以及实际执行结果是否符合预期。为了确保测试用例的可执行性、可维护性以及可追踪性，测试用例通常包含一些必要的组成元素。每个元素都扮演着特定的角色，帮助测试人员明确测试的目标、步骤和结果。</p><h3 id="测试用例的主要组成元素"><a href="#测试用例的主要组成元素" class="headerlink" title="测试用例的主要组成元素"></a>测试用例的主要组成元素</h3><ol><li><p><strong>用例编号</strong>：每个测试用例的唯一标识符，便于区分和管理。通常以某种编号规则来编写，比如模块编号+序号。</p><ul><li><strong>例子</strong>：<code>TC-001</code>，<code>LOGIN-001</code></li></ul></li><li><p><strong>用例标题</strong>：简要描述该测试用例的目标或目的，让人一目了然。通常是测试的简要总结。</p><ul><li><strong>例子</strong>：测试用户登录时输入正确的用户名和密码</li></ul></li><li><p><strong>功能模块名称</strong>：明确指出该测试用例所属的功能模块或子模块，便于测试人员定位测试范围。</p><ul><li><strong>例子</strong>：登录模块</li></ul></li><li><p><strong>前置条件</strong>：测试执行前必须满足的条件，确保测试能正常进行。包括系统状态、用户登录、环境配置等。</p><ul><li><strong>例子</strong>：用户已经注册且账号已激活，浏览器正常运行。</li></ul></li><li><p><strong>输入数据</strong>：测试过程中需要的输入，包括用户提供的数据或系统要求的输入。这是测试时要输入的具体值或条件。</p><ul><li><strong>例子</strong>：用户名：”testuser”，密码：”password123”</li></ul></li><li><p><strong>操作步骤</strong>：详细描述如何执行测试，包括每个步骤的操作细节，确保测试人员按步骤进行。</p><ul><li><strong>例子</strong>：<ol><li>打开浏览器并访问登录页面</li><li>输入用户名和密码</li><li>点击“登录”按钮</li></ol></li></ul></li><li><p><strong>预期结果</strong>：描述在执行上述操作后，系统应该表现出的正确行为或状态，便于判断测试是否通过。</p><ul><li><strong>例子</strong>：系统显示欢迎页面并登录成功，跳转到用户主页。</li></ul></li><li><p><strong>优先级</strong>：表明该测试用例的重要程度，帮助测试人员根据优先级安排测试顺序。通常分为高、中、低。</p><ul><li><strong>例子</strong>：高优先级（关键的核心功能）</li></ul></li><li><p><strong>执行结果</strong>：记录测试的实际执行结果，表明测试是否通过。如果测试未通过，需要描述实际出现的结果。</p><ul><li><strong>例子</strong>：实际结果：登录成功，显示用户主页（通过）</li></ul></li><li><p><strong>编写人</strong>：该测试用例的编写者姓名，便于追踪用例的来源。</p><ul><li><strong>例子</strong>：张三</li></ul></li><li><p><strong>执行人</strong>：实际执行该测试用例的测试人员姓名，便于跟踪谁负责了测试执行。</p><ul><li><strong>例子</strong>：李四</li></ul></li><li><p><strong>其他补充项</strong>：有时测试用例还需要额外的信息，例如环境要求（如操作系统、浏览器版本）、测试时间、备注等。</p><ul><li><strong>例子</strong>：操作系统：Windows 10，浏览器：Chrome 96.0</li></ul></li></ol><h3 id="实际通俗易懂的例子-2"><a href="#实际通俗易懂的例子-2" class="headerlink" title="实际通俗易懂的例子"></a>实际通俗易懂的例子</h3><p>假设我们要测试一个简单的登录功能，下面是一个完整的测试用例示例：</p><div class="table-container"><table><thead><tr><th><strong>元素</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>用例编号</strong></td><td>TC-LOGIN-001</td></tr><tr><td><strong>用例标题</strong></td><td>测试用户使用正确的用户名和密码登录</td></tr><tr><td><strong>功能模块名称</strong></td><td>登录模块</td></tr><tr><td><strong>前置条件</strong></td><td>用户已注册并激活账号，系统正常运行，网络连接正常。</td></tr><tr><td><strong>输入数据</strong></td><td>用户名：”testuser”，密码：”password123”</td></tr><tr><td><strong>操作步骤</strong></td><td>1. 打开浏览器并访问登录页面<br>2. 输入用户名和密码<br>3. 点击登录按钮</td></tr><tr><td><strong>预期结果</strong></td><td>登录成功，系统跳转到用户主页并显示欢迎消息。</td></tr><tr><td><strong>优先级</strong></td><td>高优先级</td></tr><tr><td><strong>执行结果</strong></td><td>登录成功，系统跳转到主页，显示欢迎消息。（通过）</td></tr><tr><td><strong>编写人</strong></td><td>张三</td></tr><tr><td><strong>执行人</strong></td><td>李四</td></tr><tr><td><strong>其他补充项</strong></td><td>操作系统：Windows 10，浏览器：Chrome 96.0</td></tr></tbody></table></div><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong>用例编号</strong>：这个编号唯一标识了该测试用例，让我们在测试报告或问题追踪中容易查找。</li><li><strong>用例标题</strong>：说明这个用例的目标是测试用户能否通过正确的用户名和密码登录系统。</li><li><strong>功能模块名称</strong>：明确该测试用例针对的是登录模块，便于理解和管理。</li><li><strong>前置条件</strong>：在执行测试之前，确保用户已注册且系统正常运行，这样测试才能顺利进行。</li><li><strong>输入数据</strong>：列出了用户名和密码这两个输入值，这些是测试过程中实际使用的数据。</li><li><strong>操作步骤</strong>：详细列出了测试的具体步骤，确保测试人员能够准确复现测试场景。</li><li><strong>预期结果</strong>：描述了成功登录后的系统行为，这个结果用来对比实际测试的输出，判断是否通过。</li><li><strong>优先级</strong>：标明这是一个高优先级的用例，因为登录是系统中的关键功能，需优先测试。</li><li><strong>执行结果</strong>：记录测试的实际输出，如果与预期结果一致，则通过。</li><li><strong>编写人和执行人</strong>：帮助追踪用例编写者和执行者，便于后续的沟通和管理。</li><li><strong>其他补充项</strong>：记录了测试环境的具体信息，比如操作系统和浏览器版本，这有助于定位环境相关的问题。</li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>测试用例的组成元素使得测试过程更具条理和可追踪性，保证测试的全面性和可执行性。每个元素都扮演着特定的角色，确保测试的目标明确、步骤清晰、结果可验证，从而帮助测试团队发现并解决软件中的问题。</p><p>==开发过程中 按下f12后常看到的后端和服务器的状态码及其解析==</p><p>在Web开发过程中，按下F12（通常用于打开浏览器的开发者工具）时，可以看到HTTP请求和响应的详细信息，其中最常见的是<strong>HTTP状态码</strong>。这些状态码由服务器返回，用于表示客户端请求的处理结果。它们通常由三位数字组成，并根据其含义分为不同的类别。</p><p>下面是常见的HTTP状态码及其详细解析：</p><h3 id="1xx：信息性响应"><a href="#1xx：信息性响应" class="headerlink" title="1xx：信息性响应"></a>1xx：信息性响应</h3><p>1xx类状态码表示请求已经接收，服务器正在继续处理请求。通常在浏览器中很少见，主要用于协议底层的处理。</p><ul><li><strong>100 Continue</strong>：客户端应继续发送请求的剩余部分。服务器已经收到请求的初始部分，客户端可以继续传输。</li><li><strong>101 Switching Protocols</strong>：服务器接受了客户端请求，正在切换协议，如从HTTP切换到WebSocket。</li></ul><h3 id="2xx：成功"><a href="#2xx：成功" class="headerlink" title="2xx：成功"></a>2xx：成功</h3><p>2xx类状态码表示请求已成功处理。</p><ul><li><strong>200 OK</strong>：请求成功，服务器返回了请求的资源。通常表示GET或POST请求成功执行，并返回了预期的内容。<ul><li><strong>例子</strong>：用户成功访问某个网页或提交表单。</li></ul></li><li><strong>201 Created</strong>：请求成功，并且服务器创建了新的资源。通常在POST请求中返回，表示新数据已成功创建。<ul><li><strong>例子</strong>：用户注册成功，创建了新账号。</li></ul></li><li><strong>204 No Content</strong>：请求成功，但服务器没有返回任何内容。通常用于更新操作，比如PUT或DELETE请求，没有需要返回的数据。<ul><li><strong>例子</strong>：更新某个资源后，无需返回具体内容。</li></ul></li></ul><h3 id="3xx：重定向"><a href="#3xx：重定向" class="headerlink" title="3xx：重定向"></a>3xx：重定向</h3><p>3xx类状态码表示需要进一步的操作才能完成请求，通常是重定向到其他URL。</p><ul><li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新的URL，客户端应使用新的URL进行后续请求。<ul><li><strong>例子</strong>：旧网页地址永久变更，访问该地址时会被引导至新地址。</li></ul></li><li><strong>302 Found</strong>（以前是“Moved Temporarily”）：请求的资源临时在另一个URL，客户端应该继续使用原始URL进行后续请求。<ul><li><strong>例子</strong>：网站维护时，用户可能会被临时重定向到另一个页面。</li></ul></li><li><strong>304 Not Modified</strong>：客户端有缓存的资源版本，服务器告诉客户端缓存仍然有效，未对资源做任何修改，无需重新下载。<ul><li><strong>例子</strong>：浏览器请求一个页面，发现该页面自上次请求以来没有改变，直接从缓存加载。</li></ul></li></ul><h3 id="4xx：客户端错误"><a href="#4xx：客户端错误" class="headerlink" title="4xx：客户端错误"></a>4xx：客户端错误</h3><p>4xx类状态码表示客户端的请求有错误，服务器无法处理。</p><ul><li><strong>400 Bad Request</strong>：请求格式不正确，服务器无法理解请求。可能是参数错误或请求数据有问题。<ul><li><strong>例子</strong>：用户提交的表单中有非法字符或格式不符合要求。</li></ul></li><li><strong>401 Unauthorized</strong>：请求未授权，通常是需要用户进行身份验证。<ul><li><strong>例子</strong>：用户尝试访问需要登录的页面，但没有提供正确的凭证。</li></ul></li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行。通常是由于用户权限不足。<ul><li><strong>例子</strong>：用户试图访问某些权限不足的管理页面。</li></ul></li><li><strong>404 Not Found</strong>：请求的资源不存在或未找到。<ul><li><strong>例子</strong>：用户输入了一个不存在的URL，或者请求了已被删除的页面。</li></ul></li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，服务器允许GET请求，但客户端尝试使用POST请求。<ul><li><strong>例子</strong>：向不允许POST操作的页面发送POST请求。</li></ul></li></ul><h3 id="5xx：服务器错误"><a href="#5xx：服务器错误" class="headerlink" title="5xx：服务器错误"></a>5xx：服务器错误</h3><p>5xx类状态码表示服务器处理请求时出错，通常是服务器端的问题。</p><ul><li><strong>500 Internal Server Error</strong>：服务器遇到无法处理的错误，无法完成请求。这是最常见的服务器错误，表示服务器内部逻辑有问题。<ul><li><strong>例子</strong>：服务器代码异常崩溃，导致无法响应请求。</li></ul></li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理时，从上游服务器收到无效响应。<ul><li><strong>例子</strong>：反向代理服务器或负载均衡器无法从上游服务器获得有效响应。</li></ul></li><li><strong>503 Service Unavailable</strong>：服务器临时过载或正在维护，无法处理请求。<ul><li><strong>例子</strong>：服务器正在更新或由于流量过大而拒绝请求。</li></ul></li><li><strong>504 Gateway Timeout</strong>：服务器作为网关或代理时，等待上游服务器响应超时。<ul><li><strong>例子</strong>：反向代理服务器等待后端服务器响应时间过长，导致超时错误。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你访问一个网站并按下F12后，在“网络”（Network）选项卡中可以看到这些状态码：</p><ul><li>你请求访问某个网页，状态码显示 <strong>200 OK</strong>，这意味着页面成功加载。</li><li>你输入了错误的页面地址，返回 <strong>404 Not Found</strong>，表明请求的资源不存在。</li><li>你尝试登录但输入了错误的密码，可能会看到 <strong>401 Unauthorized</strong>，提示需要正确的身份验证。</li><li>如果服务器遇到了问题，可能会返回 <strong>500 Internal Server Error</strong>，表示服务器内部有错误。</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>HTTP状态码是客户端和服务器通信中重要的反馈机制，按下F12查看这些状态码可以帮助开发者快速定位问题。不同的状态码代表不同的处理结果，了解它们能够有效帮助调试和优化Web应用。</p><h1 id="待学习"><a href="#待学习" class="headerlink" title="待学习"></a>待学习</h1><h1 id="selenium流程、获取元素⽅法"><a href="#selenium流程、获取元素⽅法" class="headerlink" title="selenium流程、获取元素⽅法"></a>selenium流程、获取元素⽅法</h1><p>先import，然后webdriver模拟打开⼀个浏览器（初始化），获取特定的⽹址，然后通过获取元素模拟⿏标点击⻚<br>⾯上的按钮（或者其他动作，⽐如在特定的⽂本框输⼊特定的内容），（最后quit()⼀下）<br>获取元素⽅法：xpath，css选择器，⽂本内容…..等等，⽐如find_element_by_xpath、<br>find_element_by_css_selector、find_element_by_link_text</p><blockquote><p>行业  </p><p>外包 自言</p><p>工资</p><p>稳定性</p><p>是否离家近</p><p>单双休（加班）</p></blockquote><p><img src="./../assets/image-20241002084007526.png" alt="image-20241002084007526"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;帮我详细介绍一下等价类划分，并用实际通俗易懂的例子来讲解下边的语句概述：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/tuobaaxiu/inyebp/ubhagqr51ggqabe8?singleDoc#&quot;&gt;https://www.yuqu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Un_technology</title>
    <link href="https://www.fomal.cc/posts/261d6e2f.html"/>
    <id>https://www.fomal.cc/posts/261d6e2f.html</id>
    <published>2024-09-27T23:40:11.000Z</published>
    <updated>2024-09-29T01:18:51.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非技术岗"><a href="#非技术岗" class="headerlink" title="非技术岗"></a>非技术岗</h1><blockquote><p>产品经理</p><p>产品与解决方案工程师</p><p>技术支持工程师</p></blockquote><h1 id="非技术岗面试复盘"><a href="#非技术岗面试复盘" class="headerlink" title="非技术岗面试复盘"></a>非技术岗面试复盘</h1><p>第一个点是是自己展示的自己的技术特点过于强或者想走技术的路线过去强烈，</p><p>尤其是面试官给出了两个方向，一个是研发，另一个是对于产品相关，但自己仍然在表述是，表示自己想要走技术路线</p><p>应该在表述时，表明：</p><p>自己想要走技术，但这里并不是指纯技术路线，而是向产品方向靠拢。我对产品的兴趣以及跟人打交道的乐趣要更大于自己在技术突破上的欢乐。</p><blockquote><p>自己在开发过程中碰到问题</p></blockquote>]]></content>
    
    
    <summary type="html">非技术岗面试复盘</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ACM-model</title>
    <link href="https://www.fomal.cc/posts/7ab4171.html"/>
    <id>https://www.fomal.cc/posts/7ab4171.html</id>
    <published>2024-09-24T00:30:02.000Z</published>
    <updated>2024-09-28T01:10:11.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACM-模式"><a href="#ACM-模式" class="headerlink" title="ACM 模式"></a>ACM 模式</h1><blockquote><p>参与了几次笔试，58同城、4399、中通快递的笔试，有几个题目是考察的用acm模式完成代码编写，所以单独拿出一个章节来练习强化一下，防止后边出现类似的题目再次被绊倒。</p></blockquote><p>在ACM模式下，输入输出指的是程序竞赛或算法竞赛中，<strong>程序与外部环境进行交互的方式，通常要求标准化、高效处理</strong>。ACM（Association for Computing Machinery）程序竞赛通常遵循严格的输入输出规范，</p><p>ACM 模式更加关注标准输入输出+效率上的关注</p><blockquote><p>时间和空间复杂度上掌控要求更高一点</p></blockquote><p>与公司测评的区别</p><blockquote><p>公司测试的题目更加关注对于准确性和程序的稳定性要求，比如     测试用例的目标不仅是验证<strong>程序的正确性</strong>，还包括<strong>业务逻辑的完整性</strong>和对特殊情况的处理能力。公司更看重你的代码是否能在真实业务环境中稳定工作，因此要求不仅限于通过测试，可能还包括代码的可读性、可维护性和扩展性。</p><p><strong>公司笔试</strong>：</p><ul><li><strong>自己设计测试用例</strong>：你可能需要自己设计输入数据和期望的输出结果，特别是一些边界情况、极端数据、以及可能导致错误的特殊输入。测试用例设计不仅仅关注常规输入，还会考虑异常输入、性能瓶颈等问题。</li><li><strong>输入输出数据的灵活性</strong>：不仅仅是数字、字符串等简单数据，可能还包括复杂的业务逻辑和异常处理。比如你可能要处理空指针、数据格式不对等情况，确保程序健壮性。</li></ul></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设公司笔试要求你写一个函数，计算两个数字的和，编写测试用例验证正确性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试常规情况</span></span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试边界情况</span></span><br><span class="line"><span class="keyword">assert</span> add(-<span class="number">1</span>, -<span class="number">1</span>) == -<span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">1000000</span>, <span class="number">2000000</span>) == <span class="number">3000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试异常情况（如果需要处理非整数输入）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 通过</span></span><br></pre></td></tr></table></figure><h3 id="非核心代码模式的具体含义"><a href="#非核心代码模式的具体含义" class="headerlink" title="非核心代码模式的具体含义"></a>非核心代码模式的具体含义</h3><ol><li><strong>核心代码 vs. 非核心代码</strong><ul><li><strong>核心代码</strong>：指的是实现题目要求的主要功能或算法部分，比如解决一个算法问题的主要逻辑。</li><li><strong>非核心代码</strong>：指的是围绕核心功能的辅助代码，比如如何处理输入、格式化输出，或如何搭建一个测试框架来验证核心代码的正确性。这类代码可能与题目的业务逻辑或算法无关，但对整体程序的运行至关重要。</li></ul></li><li><strong>非核心代码的常见任务</strong><ul><li><strong>输入输出处理</strong>：从文件、数据库、或者API中获取输入数据，并将结果输出到指定的格式或终端。例如，将输入数据转换成函数参数的形式，或者对输出结果进行格式化。</li><li><strong>数据准备</strong>：在核心逻辑运行之前，预先生成或组织好数据，比如处理输入数据、初始化对象、构建数据结构等。</li><li><strong>测试用例编写</strong>：编写单元测试或集成测试，测试核心代码是否按预期工作。这种情况下，你可能需要设计各种输入条件并检查输出。</li><li><strong>异常处理</strong>：确保系统在异常情况下的健壮性，比如处理输入数据中的错误格式、空数据、或者系统崩溃等场景。</li></ul></li><li><strong>非核心代码模式的应用场景</strong><ul><li><strong>公司笔试或面试</strong>：公司笔试题目中，可能会提供一部分核心代码（如核心算法的实现），要求你为其编写相应的测试用例，或者通过不同的输入输出形式来验证其正确性。这种模式下，你的任务并不是优化算法或修改核心逻辑，而是确保输入输出过程和系统的健壮性。</li><li><strong>编程竞赛</strong>：在某些竞赛中，题目可能会要求选手处理数据输入输出，算法本身可能并不复杂，但需要在特定的格式下完成任务。</li></ul></li></ol><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你参加一个公司笔试，题目给你一个已经写好的核心函数，要求你编写代码来进行测试和验证输入输出。核心函数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码：实现了两个数相加的功能</span></span><br><span class="line">def <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">int</span>, <span class="attr">b</span>: <span class="keyword">int</span>) -&gt; <span class="keyword">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你的任务是在非核心代码模式下编写以下部分：</p><ul><li>处理输入，调用<code>add</code>函数。</li><li>输出结果。</li><li>编写测试用例来验证这个<code>add</code>函数。</li></ul><h3 id="非核心代码示例"><a href="#非核心代码示例" class="headerlink" title="非核心代码示例"></a>非核心代码示例</h3><h4 id="1-输入输出处理"><a href="#1-输入输出处理" class="headerlink" title="1. 输入输出处理"></a>1. 输入输出处理</h4><figure class="highlight plaintext"><figcaption><span>main():</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    # 从标准输入读取两个整数</span><br><span class="line">    a, b = map(int, input().split())</span><br><span class="line">    </span><br><span class="line">    # 调用核心函数 add</span><br><span class="line">    result = add(a, b)</span><br><span class="line">    </span><br><span class="line">    # 输出结果</span><br><span class="line">    print(f&quot;The sum of &#123;a&#125; and &#123;b&#125; is: &#123;result&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 运行程序</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="2-编写测试用例"><a href="#2-编写测试用例" class="headerlink" title="2.编写测试用例"></a>2.编写测试用例</h4><figure class="highlight plaintext"><figcaption><span>test_add():</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    assert add(1, 2) == 3</span><br><span class="line">    assert add(-1, 1) == 0</span><br><span class="line">    assert add(0, 0) == 0</span><br><span class="line">    assert add(100, 200) == 300</span><br><span class="line"></span><br><span class="line"># 运行测试</span><br><span class="line">test_add()</span><br><span class="line">print(&quot;All test cases passed!&quot;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="==总结=="></a>==总结==</h3><p>==<strong>非核心代码模式</strong>要求你关注围绕核心功能的辅助代码，而非核心逻辑本身。这通常意味着你需要处理输入输出、测试用例、数据准备或异常处理等方面的工作。==</p><h4 id="重点1"><a href="#重点1" class="headerlink" title="重点1"></a>重点1</h4><p>当你从控制台或其他输入源读取数字（比如 <code>int</code> 或 <code>double</code> 类型）后，如果你接下来要读取字符串，通常需要调用 <code>in.nextLine()</code> 进行换行操作。这是因为读取数字的 <code>in.nextInt()</code> 或 <code>in.nextDouble()</code> 之类的方法不会读取行结束符（换行符），导致后续的 <code>in.nextLine()</code> 直接读取到空行。如果你不手动调用 <code>in.nextLine()</code> 进行换行，可能会导致无法正确读取你期望的字符串内容。</p><h4 id="重点2"><a href="#重点2" class="headerlink" title="重点2"></a>重点2</h4><p>最后给出了对应的模板解析：</p><p><a href="https://blog.csdn.net/qq_39295220/article/details/116785551">【ACM模式】牛客网ACM机试模式Python&amp;Java&amp;C++主流语言OJ输入输出案例代码总结-CSDN博客</a></p><p>上边的参考了下边的链接</p><p><a href="https://blog.csdn.net/jl6667/article/details/115439428">ACM模式自己写输入输出_acm模型写输入输出-CSDN博客</a></p><p><img src="../assets/image-20240924145402072.png" alt="image-20240924145402072"></p><blockquote><p>剑指offer 42连续子数组的最大和——ACM模式</p></blockquote><p>详细展示出了ACM与核心代码模式之间的区别：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="comment">//自己写输入输出。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new </span><span class="class title_">Scanner</span>(System.<span class="property">in</span>);</span><br><span class="line">        System.<span class="property">out</span>.<span class="property">println</span>(<span class="string">&quot;在下面一行中以空格为间隙输入元素:&quot;</span>);</span><br><span class="line">        <span class="comment">//得出的是string类型</span></span><br><span class="line">        <span class="built_in">String</span>[] <span class="built_in">str</span> = sc.<span class="property">nextLine</span>().<span class="property">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//将String类型数组转成Integer类型数组。</span></span><br><span class="line">        <span class="type">int</span>[] nums=<span class="keyword">new </span><span class="class title_">int</span>[<span class="built_in">str</span>.<span class="property">length</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            nums[i]=Integer.<span class="property">valueOf</span>(<span class="built_in">str</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="property">out</span>.<span class="property">println</span>(<span class="string">&quot;结果是：&quot;</span>+<span class="title function_">maxSubArray</span>(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span>(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">//1.定义dp数组</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new </span><span class="class title_">int</span>[n];</span><br><span class="line">        <span class="comment">//3.base case</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//可以通过具体的数字列明观察各个数之间的关系</span></span><br><span class="line">            <span class="comment">//得出状态转移方程，这个状态转移方程一定要能够体现出来i项和i-1项之间的区别。</span></span><br><span class="line">            dp[i]=Math.<span class="property">max</span>(   (Math.<span class="property">max</span>(dp[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]) +nums[i]),  nums[i] );</span><br><span class="line">            <span class="comment">//这里还要再添加和它本身的一个对比，比如[-2,1],最大子序列和为它本身即1.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历dp数组找出max元素</span></span><br><span class="line">        <span class="type">int</span> <span class="built_in">max</span>=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">                <span class="built_in">max</span>=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重点3"><a href="#重点3" class="headerlink" title="重点3"></a>重点3</h4><p>对于不同的数据结构之间的转换</p><p><a href="https://segmentfault.com/a/1190000042310202#comment-area">Java] ACM 模式刷题模板——面试时手动构建链表、二叉树 - 个人文章 - SegmentFault 思否</a></p><p>个人看完代码之后，感觉数组的转换有些不对的地方</p><p> ==str.length() -2应该改成 str.length() - 1==</p><p>==只看了数组和链表，二叉树没看==</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] <span class="title function_">StringToIntArray</span>(<span class="built_in">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">      <span class="built_in">String</span>[] parts = <span class="built_in">str</span>                <span class="comment">//根据“,”分割成字符串数组</span></span><br><span class="line">          .<span class="property">substring</span>(<span class="number">1</span>, <span class="built_in">str</span>.<span class="property">length</span>() - <span class="number">1</span>)</span><br><span class="line">          .<span class="property">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="type">int</span>[] nums = <span class="keyword">new </span><span class="class title_">int</span>[parts.<span class="property">length</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; parts.<span class="property">length</span>; i ++) </span><br><span class="line">          nums[i] = Integer.<span class="property">parseInt</span>(parts[i]);    <span class="comment">//转为整型数组</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="重点4"><a href="#重点4" class="headerlink" title="重点4"></a>重点4</h4><p>对于不同的数据结构和转换详细讲解【==待学习==】</p><p><a href="https://blog.csdn.net/KingGue/article/details/123335283">ACM模式下输入输出总结（Java）_java acm输入输出-CSDN博客</a></p><p><a href="https://openatomworkshop.csdn.net/664ee41eb12a9d168eb70d6a.html?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-9-135202188-blog-123821153.235^v43^pc_blog_bottom_relevance_base4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-9-135202188-blog-123821153.235^v43^pc_blog_bottom_relevance_base4#devmenu1">ACM模式Java输入输出模板_java_Miraclo_acc-开放原子开发者工作坊 (csdn.net)</a></p><p><a href="https://zhuanlan.zhihu.com/p/438909352">ACM模式之输入输出（Java/Python例题） - 知乎 (zhihu.com)</a></p><p>==<a href="https://zhuanlan.zhihu.com/p/392440391">Java刷ACM模式的各类输入输出构造 - 知乎 (zhihu.com)</a>==</p><blockquote><p>题解总结</p><p><a href="https://blog.csdn.net/qq_41855453/article/details/131542412?spm=1001.2101.3001.6650.15&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-131542412-blog-123821153.235^v43^pc_blog_bottom_relevance_base4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-131542412-blog-123821153.235^v43^pc_blog_bottom_relevance_base4">ACM模式常见输入输出专题（Java版）_java acm输入输出-CSDN博客</a></p></blockquote><p><strong>==卡码网==</strong> </p><p><a href="https://kamacoder.com/">卡码网KamaCoder</a></p><p>专门用来练习输入输出的网站</p><p><a href="https://github.com/youngyangyang04/kamacoder-solutions/blob/main/problems/0002.A%2BB问题II.md">kamacoder-solutions/problems/0002.A+B问题II.md at main · youngyangyang04/kamacoder-solutions · GitHub</a></p><p><a href="https://programmercarl.com/qita/acm.html">如何练习ACM模式输入输出模式 | 如何准备笔试 | 卡码网 | 代码随想录 (programmercarl.com)</a></p><blockquote><p>下边的链接讲解的蛮清晰的，利用牛客的a+b 题目和相应的题解</p><p><a href="https://blog.csdn.net/weixin_44052055/article/details/120117628?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522FBB8C9DC-3A91-4B7F-8265-EFC65A75C082%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=FBB8C9DC-3A91-4B7F-8265-EFC65A75C082&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120117628-null-null.nonecase&amp;utm_term=acm&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/weixin_44052055/article/details/120117628?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522FBB8C9DC-3A91-4B7F-8265-EFC65A75C082%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=FBB8C9DC-3A91-4B7F-8265-EFC65A75C082&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120117628-null-null.nonecase&amp;utm_term=acm&amp;spm=1018.2226.3001.4450</a></p></blockquote><p>详细解析了 hasNext（） nextInt()   hasNextLine()区别</p><p><strong>采用has xxxx的话，后面也要用next xxxx。比如前面用hasNextLine，那么后面要用 nextLine 来处理输入。</strong></p><blockquote><p><a href="https://fmy1024.cn/?cdk=3643fOvKdReDFDDa&amp;url=https%3A%2F%2Fblog.csdn.net%2Fweixin_44052055%2Farticle%2Fdetails%2F120054907">csdn (fmy1024.cn)</a>]</p><p>在线解析csdn会员文章</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class InOutTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span>. 多组空格分割的两个整数</span><br><span class="line">        <span class="regexp">//</span> eg：每行输入两个数求和</span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())&#123; <span class="regexp">//</span> <span class="keyword">while</span>处理多个case</span><br><span class="line"><span class="regexp">//</span>            int a = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            int b = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            System.out.println(a + b);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">2</span>. 第一行组数接空格分割的两个正整数 （行数限制）</span><br><span class="line">        <span class="regexp">//</span> eg: 输出a+b的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        int num = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">for</span> (int i =<span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>            int a = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            int b = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            System.out.println(a + b);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">3</span>. 空行分割的两个正整数，<span class="number">0</span> <span class="number">0</span> 结束 （结束符限制）</span><br><span class="line">        <span class="regexp">//</span> eg: 输出a+b的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">10</span> <span class="number">20</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())&#123;</span><br><span class="line"><span class="regexp">//</span>            int a = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            int b = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(a + b);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span>. 每行第一个为个数后带空格分割整数，<span class="number">0</span>结束 （结束符限制,每行有个数限制）</span><br><span class="line">        <span class="regexp">//</span> 输入数据包括多组。</span><br><span class="line">        <span class="regexp">//</span> 每组数据一行,每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>), n为<span class="number">0</span>的时候结束输入。</span><br><span class="line">        <span class="regexp">//</span> 接下来n个正整数,即需要求和的每个正整数。</span><br><span class="line">        <span class="regexp">//</span> eg: 每组数据输出求和的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">0</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())&#123;</span><br><span class="line"><span class="regexp">//</span>            int n = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="regexp">//</span>            int sum = <span class="number">0</span>;</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>                sum += <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(sum);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">5</span>. 第一行组数接第一个个数接空格分开的整数 （行数限制,每行有个数限制）</span><br><span class="line">        <span class="regexp">//</span> 输入的第一行包括一个正整数t(<span class="number">1</span> &lt;= t &lt;= <span class="number">100</span>), 表示数据组数。</span><br><span class="line">        <span class="regexp">//</span> 接下来t行, 每行一组数据。</span><br><span class="line">        <span class="regexp">//</span> 每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">        <span class="regexp">//</span> 接下来n个正整数, 即需要求和的每个正整数。</span><br><span class="line">        <span class="regexp">//</span> eg: 每组数据输出求和的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        int num = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>            int n = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            int sum = <span class="number">0</span>;</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="regexp">//</span>                sum += <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(sum);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line">        <span class="regexp">//</span> <span class="number">6</span>. 每行第一个为个数后带空格分割整数 (无结束限制,每行有个数限制)</span><br><span class="line">        <span class="regexp">//</span> 输入数据有多组, 每行表示一组输入数据。</span><br><span class="line">        <span class="regexp">//</span> 每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">        <span class="regexp">//</span> 接下来n个正整数, 即需要求和的每个正整数。</span><br><span class="line">        <span class="regexp">//</span> eg: 每组数据输出求和的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNextInt())&#123;</span><br><span class="line"><span class="regexp">//</span>            int num = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            int sum = <span class="number">0</span>;</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>                sum += <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(sum);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">7</span>. 多组空格分隔的正整数 (无结束限制,每行无个数限制,需要当作字符串处理)</span><br><span class="line">        <span class="regexp">//</span> 输入数据有多组, 每行表示一组输入数据。</span><br><span class="line">        <span class="regexp">//</span> 每行不定有n个整数，空格隔开。(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">        <span class="regexp">//</span> eg: 每组数据输出求和的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNextLine())&#123;   <span class="regexp">//</span> 直接读一行字符串</span><br><span class="line"><span class="regexp">//</span>            String[] s = <span class="keyword">in</span>.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            int sum = <span class="number">0</span>;</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>                sum += Integer.parseInt(s[i]);</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(sum);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 扩展：第一行组数接空格分开的多个整数 (有行数限制,每行无个数限制,需要当作字符串处理)</span><br><span class="line">        <span class="regexp">//</span> eg: 每组数据输出求和的结果</span><br><span class="line">        <span class="regexp">//</span> <span class="number">3</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int num = <span class="keyword">in</span>.nextInt();</span><br><span class="line">        <span class="keyword">in</span>.nextLine();  <span class="regexp">//</span> 跳过行数所在行</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num; i++ )&#123;</span><br><span class="line">            String[] s = <span class="keyword">in</span>.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; s.length; j++)&#123;</span><br><span class="line">                sum += Integer.parseInt(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">8</span>. 第一行个数第二行字符串</span><br><span class="line">        <span class="regexp">//</span> 输入有两行，第一行n</span><br><span class="line">        <span class="regexp">//</span> 第二行是n个空格隔开的字符串</span><br><span class="line">        <span class="regexp">//</span> eg: 输出一行排序后的字符串，空格隔开，无结尾空格</span><br><span class="line">        <span class="regexp">//</span> <span class="number">5</span></span><br><span class="line">        <span class="regexp">//</span> c d a bb e</span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        int num = <span class="keyword">in</span>.nextInt();</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">in</span>.nextLine();</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())&#123;</span><br><span class="line"><span class="regexp">//</span>            String[] s = <span class="keyword">in</span>.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            Arrays.sort(s);</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line"><span class="regexp">//</span>                System.out.print(s[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">9</span>. 多行空格分开的字符串</span><br><span class="line">        <span class="regexp">//</span> 多个测试用例，每个测试用例一行。</span><br><span class="line">        <span class="regexp">//</span> 每行通过空格隔开，有n个字符，n＜<span class="number">100</span></span><br><span class="line">        <span class="regexp">//</span> eg: 对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</span><br><span class="line">        <span class="regexp">//</span> a c bb</span><br><span class="line">        <span class="regexp">//</span> f dddd</span><br><span class="line">        <span class="regexp">//</span> nowcoder</span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNextLine())&#123;</span><br><span class="line"><span class="regexp">//</span>            String[] s = <span class="keyword">in</span>.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            Arrays.sort(s);</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span> (String c:s)&#123;</span><br><span class="line"><span class="regexp">//</span>                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println();</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> <span class="number">10</span>. 多行逗号分开的字符串 （逗号和空格的区别就是最后一个字符输完的时候<span class="string">&quot;,&quot;</span>还是<span class="string">&quot; &quot;</span> ）</span><br><span class="line">        <span class="regexp">//</span> 多个测试用例，每个测试用例一行。</span><br><span class="line">        <span class="regexp">//</span> 每行通过,隔开，有n个字符，n＜<span class="number">100</span></span><br><span class="line">        <span class="regexp">//</span> eg: 对于每组用例输出一行排序后的字符串，用<span class="string">&#x27;,&#x27;</span>隔开，无结尾空格</span><br><span class="line">        <span class="regexp">//</span> a,c,bb</span><br><span class="line">        <span class="regexp">//</span> f,dddd</span><br><span class="line">        <span class="regexp">//</span> nowcoder</span><br><span class="line"><span class="regexp">//</span>        Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNextLine()) &#123;</span><br><span class="line"><span class="regexp">//</span>            String[] s = <span class="keyword">in</span>.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            Arrays.sort(s);</span><br><span class="line"><span class="regexp">//</span>            int l = s.length;</span><br><span class="line"><span class="regexp">//</span>            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; l - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="regexp">//</span>                System.out.print(s[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="regexp">//</span>            &#125;</span><br><span class="line"><span class="regexp">//</span>            System.out.println(s[l-<span class="number">1</span>]);</span><br><span class="line"><span class="regexp">//</span>        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ACM-模板"><a href="#ACM-模板" class="headerlink" title="ACM 模板"></a>ACM 模板</h3><blockquote><p><a href="https://blog.csdn.net/qq_40222433/article/details/138311329?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-2-138311329-blog-123821153.235^v43^pc_blog_bottom_relevance_base4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-2-138311329-blog-123821153.235^v43^pc_blog_bottom_relevance_base4">Java语言中ACM模式输入输出- 1（大厂 笔试题必备知识）_java acm模式-CSDN博客</a></p><p>==这个是对与模板的补充，待看==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数据输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//读数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numLen</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] numArr = <span class="keyword">new</span> <span class="title class_">int</span>[numLen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextInt() &amp;&amp; i &lt; numLen)&#123;</span><br><span class="line">            numArr[i] = in.nextInt();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">strLen</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.nextLine(); <span class="comment">//数字到字符串要换行</span></span><br><span class="line">        String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[strLen];</span><br><span class="line">        <span class="comment">//或者 strArr[] = in.nextLine().split(&quot; &quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine() &amp;&amp; j &lt; strLen)&#123;</span><br><span class="line">            strArr[j] = in.nextLine();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 处理</span></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> solution.process(numArr, strArr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//四舍五入输出小数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>,<span class="number">3.555</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面类似 LeetCode 的核心代码模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(Arrays.toString(nums));</span><br><span class="line">        sb.append(<span class="string">&quot; &amp;&amp; &quot;</span>);</span><br><span class="line">        sb.append(Arrays.toString(strs));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/dlhjw1412/article/details/123821153</span></span><br></pre></td></tr></table></figure><h1 id="笔试准备"><a href="#笔试准备" class="headerlink" title="笔试准备"></a>笔试准备</h1><p>笔试必刷题：</p><p><a href="https://www.nowcoder.com/exam/company?currentTab=recommand&amp;jobId=100&amp;selectStatus=0&amp;tagIds=175%2C768%2C11200%2C11203%2C142700">牛客网公司真题<em>免费模拟题库</em>企业面试|笔试真题 (nowcoder.com)</a></p><p><img src="../assets/image-20240924182218783.png" alt="image-20240924182218783"></p>]]></content>
    
    
    <summary type="html">练习acm输入输出模式，而非核心代码模式</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>job_selectivity</title>
    <link href="https://www.fomal.cc/posts/afaefb1a.html"/>
    <id>https://www.fomal.cc/posts/afaefb1a.html</id>
    <published>2024-09-22T12:50:48.000Z</published>
    <updated>2024-09-29T01:18:33.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-22-周天"><a href="#9-22-周天" class="headerlink" title="9.22_周天"></a>9.22_周天</h1><p>中通快递集团招聘  笔试筛选  一挂</p><p>小米   笔试评估中</p><p>4399  笔试被刷</p><p>奥飞娱乐 -测评  9.20查看</p><h2 id="9-23日"><a href="#9-23日" class="headerlink" title="9.23日"></a>9.23日</h2><blockquote><p>完成海康威视测评</p></blockquote><h1 id="9-24日"><a href="#9-24日" class="headerlink" title="9.24日"></a>9.24日</h1><blockquote><p>19：00  完成数字马力的在线笔试</p></blockquote><p>选择（单选 19个 ）多选13个  编程题 两道</p><blockquote><p>都是核心代码模式，只需要完善对应的核心功能即可</p><p>第一道是 编程题目</p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为日标值 target的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 输入：nums =[2,7,11,15] target =9 输出:[0,1]解释:因为 nums[0]+nums[1]==9，返回[0，1] 示例 2: 输入:nums=[3,2,4]，target =6 输出:[1,2] 示例 3: 输入:nums=[3,3]，target =6输出:[0,1]</p><p>第二道是sql语句题目</p><p>==被卡住，没有ac==</p></blockquote><p>数据库实现: S 表保存着学生关系，有两列，其中SNO 为学号，SNAME 为姓名C 表保存着课程关系，有三列，其中CNO 为课程号，CNAME 为课程名 CTEACHER 为老师 SC表保存着选课关系，有三列，其中SNO为学号，CNO为课程号，SCORE为成绩 </p><p>找出没有选“小易”老师课程的所有学生姓名</p><p>列出有三门(包括三门)以上课程分数&gt;90的学生姓名及其平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入为下边</span><br><span class="line"><span class="keyword">CREATE</span> TABLÉ <span class="string">&#x27;SSNO varchar(100) COLLATE utf8mb4 bin DEFAULT&quot; COMMENT&#x27;</span>学号”SNAME <span class="type">varchar</span>(<span class="number">255</span>)<span class="keyword">COLLATE</span> utf8mb4 bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT &quot;姓名)ENGINE=InnODB AUTO INCREMENT=146 DEFAULT CHARSET=utf8mb4COLLATE=utf8mb4 bin ROW FORMAT=DYNAMIC COMMENT=&#x27;学生关系&#x27;</span><br><span class="line">CREATE TABLE &#x27;C(CNO varchar(100) COLLATE utf8mb4 bin DEFAULT&quot; COMMENT <span class="string">&#x27;课程号&#x27;</span>CNAME&quot; varchar(255) COLLATE utf8mb4 bin DEFAULT NULL COMMENT &#x27;课程名&#x27;CTEACHER varchar(255)COLLATE utf8mb4 bin DEFAULT NULL COMMENT &#x27;老师)ENGINE=InnODB AUTO INCREMENT=146 DEFAULT CHARSET=utf8mb4COLLATE=utf8mb4 bin ROW FORMAT=DYNAMIC COMMENT=&#x27;课程关系&quot;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;SC&#x27;</span>(SNO <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span>&quot; COMMENT&#x27;学号&#x27;CNO varchar(100) COLLATE utf8mb4 bin DEFAULT&quot; COMMENT <span class="string">&#x27;课程号”SCORE bigint(100) NOT NULL DEFAULT &#x27;</span>O<span class="string">&#x27; COMMENT &#x27;</span>成绩”)ENGINE<span class="operator">=</span>InNODB AUTO INCREMENT<span class="operator">=</span><span class="number">146</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4COLLATE<span class="operator">=</span>utf8mb4 bin <span class="type">ROW</span> FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;选课关系&quot;</span></span><br><span class="line"><span class="string">INSERT INTO &#x27;</span>SC<span class="string">&#x27;(&#x27;</span>SNO<span class="string">&#x27;, &#x27;</span>CNO<span class="string">&#x27;, SCORE&quot;) VALUES ( &#x27;</span><span class="number">2</span><span class="string">&#x27;, &#x27;</span><span class="number">11</span><span class="string">&#x27;, 120);INSERT INTO &#x27;</span>S(SNO,<span class="string">&#x27;SNAME&quot;) VALUES (&quot;2&#x27;</span>,<span class="string">&#x27;易&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> C(CNO,CNAME<span class="string">&#x27;,CTEACHER’) VALUES (&#x27;</span><span class="number">11</span><span class="string">&#x27;,&#x27;</span>小易<span class="string">&#x27;,&quot;物理老师”);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出 </span></span><br><span class="line"><span class="string">SMAME</span></span><br><span class="line"><span class="string">小易</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出没有选“小易”老师课程的学生姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S.SNAME</span><br><span class="line"><span class="keyword">FROM</span> S S</span><br><span class="line"><span class="keyword">WHERE</span> S.SNO <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> SC.SNO</span><br><span class="line">    <span class="keyword">FROM</span> SC SC</span><br><span class="line">    <span class="keyword">JOIN</span> C C <span class="keyword">ON</span> SC.CNO = C.CNO</span><br><span class="line">    <span class="keyword">WHERE</span> C.CTEACHER = <span class="string">&#x27;小易&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出有三门以上课程分数 &gt; 90 的学生姓名及其平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    S.SNAME,</span><br><span class="line">    AVG(SC.SCORE) <span class="keyword">AS</span> AverageScore</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    S S</span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">    SC SC <span class="keyword">ON</span> S.SNO = SC.SNO</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    SC.SCORE &gt; <span class="number">90</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    S.SNAME</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">    COUNT(<span class="keyword">DISTINCT</span> SC.CNO) &gt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h3><blockquote><p>科技股份有限公司</p></blockquote>]]></content>
    
    
    <summary type="html">投递/完成对应要求后的结果查询记录</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>my_resume</title>
    <link href="https://www.fomal.cc/posts/fca410bb.html"/>
    <id>https://www.fomal.cc/posts/fca410bb.html</id>
    <published>2024-09-21T01:36:24.000Z</published>
    <updated>2024-09-29T01:18:43.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简历项目与问答准备"><a href="#简历项目与问答准备" class="headerlink" title="简历项目与问答准备"></a>简历项目与问答准备</h1><h2 id="测试开发工程师-整体性提问"><a href="#测试开发工程师-整体性提问" class="headerlink" title="测试开发工程师(整体性提问)"></a>测试开发工程师(整体性提问)</h2><blockquote><p>下边是一些对应的整体的概述提问</p></blockquote><h3 id="1-项目经验相关的问题"><a href="#1-项目经验相关的问题" class="headerlink" title="1. 项目经验相关的问题"></a>1. <strong>项目经验相关的问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>你在“室内空气环境数据监测与控制系统”项目中的具体贡献是什么？<ul><li>先简要介绍一下项目背景、在介绍一下我做的主要贡献<ul><li>背景：毕业设计项目，linux嵌入式软件——开发板（硬件公司合作）+师哥的软件系统</li><li>STM32开发板（数据控制，串口处理，命令转发）+WiFi模块+各类传感器</li><li></li></ul></li></ul></li><li>你在项目中如何实现前后端分离，以及如何进行云端数据处理？</li><li>硬件集成方面，你使用了哪些技术和协议？你如何处理数据采集与传输？</li></ul></li><li><strong>应对策略</strong>：<ul><li>描述项目时尽量具体，提到技术栈时要结合你使用的SpringBoot、MyBatis、MySQL和Vue等技术，强调如何解决了项目中的具体问题。</li><li>针对硬件部分，重点说明你如何配置STM32开发板、使用esp8266wifi模块进行数据传输，特别是在传输协议（如MQTT）的使用上。</li></ul></li></ul><h3 id="2-实习经验相关的问题"><a href="#2-实习经验相关的问题" class="headerlink" title="2. 实习经验相关的问题"></a>2. <strong>实习经验相关的问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>在红笔部门的管理工作中，你是如何统筹和协调300+实习生的？<ul><li>飞书工具</li><li>技术文档说明书【培训过程改进】</li><li>技术管理——系统管理,利用教师批改系统完成工作</li><li>分组，小组长管理培训，业绩考核与奖惩机制</li></ul></li><li>你在“军体拳视频人体行为识别系统”中负责了哪些算法研究与模型训练？如何参与STGCNs模型的训练？</li></ul></li><li><strong>应对策略</strong>：<ul><li>强调你在数据管理和开发方面的贡献，特别是在项目管理和团队合作中的经验。对于算法部分，具体说明你如何应用深度学习技术，提到如何使用STGCN进行人体行为识别，并描述你的数据采集与处理过程。</li></ul></li></ul><h3 id="3-技术技能相关的问题"><a href="#3-技术技能相关的问题" class="headerlink" title="3. 技术技能相关的问题"></a>3. <strong>技术技能相关的问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>你熟悉SpringBoot、MyBatis等技术栈，能否详细讲解一下你在实际项目中的应用场景？</li><li>你提到熟悉Java集合和常见的排序算法（如快速排序、堆排序），请你讲解一下这些算法的复杂度以及如何选择合适的算法？</li></ul></li><li><strong>应对策略</strong>：<ul><li>通过具体项目中的例子展示你如何应用这些技术，比如讲解SpringBoot和MyBatis如何用于开发和数据持久化。</li><li>针对排序算法，除了复杂度分析，还可以提到实际应用中的选择依据（如根据数据集规模、数据分布选择合适的算法）。</li></ul></li></ul><h3 id="4-数据库与优化相关的问题"><a href="#4-数据库与优化相关的问题" class="headerlink" title="4. 数据库与优化相关的问题"></a>4. <strong>数据库与优化相关的问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>你在数据库优化方面有什么实际经验？如何处理数据库性能问题？</li><li>请解释MySQL中的事务隔离级别以及如何避免死锁？</li></ul></li><li><strong>应对策略</strong>：<ul><li>针对数据库优化，可以提到你在项目中如何通过索引优化查询性能、如何设计合理的表结构。</li><li>对于事务和锁机制，结合实际项目中的场景讲解你如何运用事务隔离级别来保证数据一致性，避免并发问题。</li></ul></li></ul><h3 id="5-测试相关的问题"><a href="#5-测试相关的问题" class="headerlink" title="5. 测试相关的问题"></a>5. <strong>测试相关的问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>你如何进行系统测试？如何保证测试覆盖率和有效性？</li><li>你在项目中如何进行单元测试、集成测试以及系统测试？</li></ul></li><li><strong>应对策略</strong>：<ul><li>重点描述你在项目中的测试工作，提到具体的测试框架和工具（如JUnit、TestNG），并结合项目中遇到的问题如何通过自动化测试、手动测试等方法确保系统稳定性。</li></ul></li></ul><h3 id="6-深度学习相关问题"><a href="#6-深度学习相关问题" class="headerlink" title="6. 深度学习相关问题"></a>6. <strong>深度学习相关问题</strong></h3><ul><li><strong>提问点</strong>：<ul><li>你提到使用了PyTorch，请你详细讲解一下在“人体行为识别系统”项目中如何利用深度学习库进行模型训练和测试？</li><li>STGCNs模型的优点和挑战是什么？你在训练过程中遇到了哪些困难，如何解决的？</li></ul></li><li><strong>应对策略</strong>：<ul><li>结合PyTorch的使用，说明你如何搭建模型、处理数据并进行训练。可以提到使用的模型架构、训练方法和优化策略。</li><li>针对STGCNs的挑战，可以谈谈模型复杂性、训练时间和数据标注的困难，并说明如何通过优化模型结构和数据处理来应对这些问题。</li></ul></li></ul><h3 id="快速准备面试的策略："><a href="#快速准备面试的策略：" class="headerlink" title="快速准备面试的策略："></a><strong>快速准备面试的策略</strong>：</h3><ol><li><strong>技术概念复习</strong>：重点复习简历中提到的技术栈，如SpringBoot、MyBatis、Java集合与算法、数据库优化等知识点，确保在面试中能够快速准确地回答。</li><li><strong>项目经历梳理</strong>：针对每个项目，准备一个简洁的项目概述，重点描述你在项目中的贡献和所使用的技术，特别是与测试相关的部分。</li><li><strong>常见问题模拟</strong>：提前准备好项目管理、测试策略、算法优化等问题的回答，确保回答时逻辑清晰、具体、有条理。</li></ol><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-项目经验相关问题"><a href="#1-项目经验相关问题" class="headerlink" title="1. 项目经验相关问题"></a>1. <strong>项目经验相关问题</strong></h3><p><strong>问题：</strong>你在“室内空气环境数据监测与控制系统”项目中的具体贡献是什么？<br><strong>回答：</strong> “在这个项目中，我负责了整个系统的搭建和业务流程的实现。具体来说，我主要承担了软硬件系统的开发，包括基于SpringBoot、MyBatis和MySQL的后端开发，以及Vue的前端搭建。在硬件集成方面，我使用了STM32开发板和esp8266wifi模块进行空气数据的采集与传输，采用了自定义的协议和MQTT通信，实现了数据的实时采集和用户设备管理功能。通过这个项目，我积累了丰富的全栈开发经验，特别是软硬件结合项目中的挑战。”</p><h3 id="2-实习经验相关问题"><a href="#2-实习经验相关问题" class="headerlink" title="2. 实习经验相关问题"></a>2. <strong>实习经验相关问题</strong></h3><p><strong>问题：</strong>在红笔部门的管理工作中，你是如何统筹和协调300+实习生的？<br><strong>回答：</strong> “作为实习组长，我主要负责统筹和协调300多位实习生的工作安排与任务分配。通过搭建有效的项目管理系统，我制定了清晰的工作流程，确保每位实习生都能高效完成任务。我还负责与其他部门进行协调，定期评估实习生的工作表现，并通过优化工作安排提升整体的效率。这个过程中，我学会了如何管理大型团队，并通过团队协作完成复杂的任务。”</p><p><strong>问题：</strong>你在“军体拳视频人体行为识别系统”中负责了哪些算法研究与模型训练？<br><strong>回答：</strong> “在这个项目中，我参与了行为识别系统的算法设计与模型训练工作。主要负责的是基于STGCNs（时空图卷积网络）的模型搭建与本地训练，模型用于识别并分析军体拳训练中的动作。我还参与了数据处理和标注，编写了数据采集与处理方案，确保数据的准确性和模型训练的有效性。通过这个项目，我深入了解了深度学习在行为识别中的应用，特别是在时空图卷积网络的设计和优化方面。”</p><p>教师批改系统已有，自己的学生的作业，同时给自己的老师</p><p>【涉及到教师的工作分配、作业任务量的管理、】需要完成批改的作业处理系统: </p><p>在线处理——上传作业——教师批改——反馈交流</p><p>【作业池】————【红笔老师池】</p><blockquote><p>老师批改管理系统</p></blockquote><h3 id="3-技术技能相关问题"><a href="#3-技术技能相关问题" class="headerlink" title="3. 技术技能相关问题"></a>3. <strong>技术技能相关问题</strong></h3><p><strong>问题：</strong>你熟悉SpringBoot、MyBatis等技术栈，能否详细讲解一下你在实际项目中的应用场景？<br><strong>回答：</strong> “在实际项目中，我使用SpringBoot作为后台框架，结合MyBatis实现了数据的持久化处理。比如在‘室内空气监测系统’项目中，SpringBoot处理了数据请求与设备控制的逻辑，而MyBatis则负责对MySQL数据库的访问与操作。我还设计了用户管理、权限分配等功能，通过SpringBoot的AOP机制增强了业务的安全性与扩展性。”</p><p><strong>问题：</strong>你提到熟悉Java集合和常见的排序算法，请你讲解一下这些算法的复杂度以及如何选择合适的算法？<br><strong>回答：</strong> “我熟悉Java集合框架中的常用数据结构以及相应的排序算法。比如快速排序的平均时间复杂度为O(n log n)，适合处理大量无序数据；而堆排序也是O(n log n)，但由于堆的结构，它的空间复杂度较低，更适合在内存有限的情况下使用。在实际应用中，我会根据数据规模和应用场景来选择合适的排序算法。例如，在处理小规模数据时，插入排序的实现可能会更加高效，而对于大规模数据，快速排序或堆排序会更合适。”</p><h3 id="4-数据库与优化相关问题"><a href="#4-数据库与优化相关问题" class="headerlink" title="4. 数据库与优化相关问题"></a>4. <strong>数据库与优化相关问题</strong></h3><p><strong>问题：</strong>你在数据库优化方面有什么实际经验？如何处理数据库性能问题？<br><strong>回答：</strong> “在项目中，我通过以下几种方式进行数据库优化：首先是通过合理设计索引来加快查询速度，尤其是在查询频繁的字段上建立合适的复合索引。其次是优化SQL语句，避免使用不必要的嵌套查询或过多的联表操作。在MySQL中，我还使用了缓存机制来减少数据库的压力，利用事务隔离级别来防止数据的脏读与幻读。通过这些优化措施，我有效提高了系统的响应速度和稳定性。”</p><p><strong>问题：</strong>请解释MySQL中的事务隔离级别以及如何避免死锁？<br><strong>回答：</strong> “MySQL中的事务隔离级别分为四种：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。其中，‘可重复读’是MySQL的默认级别，它可以防止脏读和不可重复读。为了避免死锁，我会尽量减少事务的持有时间，保证在同一事务中按照固定顺序访问表，避免长时间占用资源。另外，我会通过监控和调整锁机制来降低死锁的风险。”</p><h3 id="5-测试相关问题"><a href="#5-测试相关问题" class="headerlink" title="5. 测试相关问题"></a>5. <strong>测试相关问题</strong></h3><p><strong>问题：</strong>你如何进行系统测试？如何保证测试覆盖率和有效性？<br><strong>回答：</strong> “在项目开发过程中，我会根据功能模块进行单元测试、集成测试和系统测试。在单元测试方面，我使用JUnit和TestNG框架来验证每个模块的功能是否符合预期，确保关键功能点没有问题。为了保证测试覆盖率，我会通过覆盖率工具来统计代码覆盖率，确保核心功能模块的覆盖率达到80%以上。在系统测试阶段，我会进行性能测试、压力测试和兼容性测试，以确保系统在不同负载下的稳定性。”</p><p><strong>问题：</strong>你在项目中如何进行单元测试、集成测试以及系统测试？<br><strong>回答：</strong> “我通常会先进行单元测试，确保每个模块的逻辑正确，测试工具主要使用JUnit。在集成测试中，关注各模块之间的接口调用和数据传递，确保模块协作正常。最后的系统测试则包括整体功能的验证，以及性能、负载和安全性方面的测试，特别是涉及到数据库和多线程的场景，我会使用模拟多用户并发的场景来确保系统的可靠性。”</p><h3 id="6-深度学习相关问题-1"><a href="#6-深度学习相关问题-1" class="headerlink" title="6. 深度学习相关问题"></a>6. <strong>深度学习相关问题</strong></h3><p><strong>问题：</strong>请你详细讲解一下在“人体行为识别系统”项目中如何利用深度学习库进行模型训练和测试？<br><strong>回答：</strong> “在这个项目中，我使用了PyTorch库来搭建行为识别的深度学习模型。数据的预处理步骤包括对原始视频数据进行关键点提取，然后使用STGCNs模型进行时空特征的捕捉。在模型训练时，我设置了多种优化器和学习率调度策略，以提高模型的精度。对于模型的测试，我会使用交叉验证的方法，确保模型在不同数据集上的泛化能力，并且通过不断调整模型参数，提升了模型的识别准确率。”</p><p><strong>问题：</strong>STGCNs模型的优点和挑战是什么？你在训练过程中遇到了哪些困难，如何解决的？<br><strong>回答：</strong> “STGCNs模型的优点在于它能够有效地捕捉时空特征，特别是在行为识别场景中，可以同时考虑时间维度和空间维度的依赖关系。挑战在于模型较为复杂，训练时间较长，而且需要大量的数据标注。在训练过程中，我遇到的主要困难是模型容易过拟合。为了解决这一问题，我通过正则化和数据增强技术（如随机旋转、缩放）来增加数据的多样性，进而提高模型的泛化能力。”</p><p>这些回答示范可以帮助你更好地应对面试中的问题，建议你提前熟悉内容，并根据实际项目经验稍作调整，确保面试时回答自信流畅。祝你面试成功！</p><h1 id="深入测试开发技术"><a href="#深入测试开发技术" class="headerlink" title="深入测试开发技术"></a>深入测试开发技术</h1><p>请你结合我的简历，请你从java测试开发工程师的角度，从开始面试到问答和追问环节，全程针对测试技术来展开，完成提问-回答-追问再回答的过程模拟，给出问题分析和详细回答吧~</p><h2 id="个人独立开发者项目"><a href="#个人独立开发者项目" class="headerlink" title="个人独立开发者项目"></a>个人独立开发者项目</h2><p>可以先简单介绍一下你之前的项目经验和你在测试方面的贡献吗？</p><p><strong>你</strong>： “您好，感谢您的时间。我之前的项目经验主要集中在Java开发和测试上，例如‘室内空气环境数据监测与控制系统’的项目中，我负责了从后端开发到集成测试的全流程。在项目中，我使用SpringBoot和MyBatis进行开发，同时我负责系统的测试，确保功能模块的稳定性和性能表现。在测试方面，我主要使用JUnit进行单元测试，同时也使用了模拟工具进行集成测试和系统测试，保证系统各模块之间的正常交互和数据流通。”</p><h3 id="提问-1："><a href="#提问-1：" class="headerlink" title="提问 1："></a><strong>提问 1：</strong></h3><p><strong>面试官</strong>：你提到了单元测试和集成测试，可以详细解释一下你在这两方面是如何进行的？特别是你是如何确保测试==覆盖率==的？</p><p><strong>你</strong>： “在==单元测试==方面，我主要使用JUnit框架，针对每个功能模块进行详细的测试。例如，在空气监测系统中，每个传感器数据采集模块都有相应的单元测试，确保在各种输入情况下都能返回预期结果。为保证覆盖率，我使用了代码覆盖率工具（例如JaCoCo）来分析哪些代码未被测试，确保关键的业务逻辑和边界情况都被覆盖。</p><p>在==集成测试==中，我主要关注模块之间的数据流和接口调用。例如，前后端数据传输是否正常、数据库访问是否按预期进行。在集成测试中，我使用了Mock工具模拟数据库或第三方API的行为，确保每个模块在独立运行和相互依赖时都能正常工作。”</p><h3 id="追问-1：Mock"><a href="#追问-1：Mock" class="headerlink" title="追问 1：Mock"></a><strong>追问 1：</strong>Mock</h3><p><strong>面试官</strong>：在==集成测试==中，你提到了使用Mock工具。你能具体讲一下使用什么Mock工具，以及你如何决定什么时候该使用Mock，什么时候需要进行真实环境下的测试？</p><p><strong>你</strong>： “在项目中，我主要使用了Mockito作为Mock工具。Mock的使用场景主要是在测试时需要隔离外部依赖或者第三方服务的时候。例如，当我们测试空气监测系统的API层时，我会Mock掉数据库层，以确保不必连接真实数据库，同时又能测试API的业务逻辑和错误处理机制。</p><p>决定何时使用Mock取决于测试的目的。如果目的是测试某个模块的功能而不依赖其他模块（例如，测试某个API是否正确处理传入数据），那么Mock是合适的。如果需要测试系统在真实环境下的表现，比如性能测试或者与第三方系统的集成性测试，我会使用真实的数据库和API进行全面测试。”</p><h3 id="提问-2："><a href="#提问-2：" class="headerlink" title="==提问 2：=="></a><strong>==提问 2：==</strong></h3><p><strong>面试官</strong>：对于系统性能测试，你有过哪些实际经验？你是如何进行性能测试的，特别是在Java Web应用中如何进行负载测试？</p><p><strong>你</strong>： “在性能测试方面，我曾使用过JMeter进行Java Web应用的负载测试。具体来说，JMeter可以模拟多个用户并发访问系统，帮助我们评估系统的响应时间和吞吐量。在‘室内空气监测系统’项目中，我使用JMeter模拟了大量用户同时访问系统的数据展示功能，并记录了系统的响应时间。</p><p>为了提高性能，我通过分析瓶颈，优化了数据库查询和API调用。特别是在并发高峰期，我调整了数据库的索引结构，使用了连接池优化了数据库访问速度，从而提升了系统的响应能力。”</p><h3 id="追问-2：-sql-并发情况处理"><a href="#追问-2：-sql-并发情况处理" class="headerlink" title="追问 2：==sql  并发情况处理=="></a><strong>追问 2：</strong>==sql  并发情况处理==</h3><p><strong>面试官</strong>：你刚才提到你优化了数据库查询和API调用，可以具体说一下是通过什么手段优化的？在面对慢查询时，你是如何进行排查和改进的？</p><p><strong>你</strong>： “首先，我通过分析查询日志和性能监控工具（如MySQL的慢查询日志）发现了性能瓶颈。在一些高频查询的情况下，我发现数据库没有合适的索引，导致查询速度变慢。为了解决这个问题，我在涉及大量查询的字段上创建了复合索引，同时优化了SQL语句，减少了不必要的联表操作。</p><p>另外，我还通过在应用层引入缓存机制，减少了频繁的数据库访问。通过引入Redis缓存，在短时间内存储热门数据，大大减轻了数据库的负载压力。此外，我还优化了API的调用逻辑，通过异步处理和批量操作减少了网络请求的次数和延迟。”</p><h3 id="提问-4：sql"><a href="#提问-4：sql" class="headerlink" title="提问 4：sql"></a><strong>提问 4：sql</strong></h3><p><strong>面试官</strong>：在简历中你提到你使用过MyBatis进行项目的开发工作。在与数据库交互的过程中，你是如何进行SQL注入测试的？能否介绍一下你的防护措施？</p><p><strong>你</strong>： “在使用MyBatis进行项目开发时，我非常关注SQL注入的风险。为了预防SQL注入，我严格遵循参数化查询的最佳实践，使用MyBatis中的<code>#&#123;&#125;占位符</code>来处理SQL语句中的用户输入，避免使用<code>$&#123;&#125;</code>这种直接拼接SQL的方式。此外，我还确保输入的数据进行了严格的校验和过滤，不允许直接执行包含用户输入的动态SQL。</p><p>在测试SQL注入时，我会设计一些恶意输入，比如插入<code>&#39; OR 1=1 --</code>这样的测试数据，通过JUnit进行单元测试，确保应用能够正确处理并返回预期的错误响应。通过这种方式，我验证了系统的安全性。”</p><h3 id="追问-4："><a href="#追问-4：" class="headerlink" title="==追问 4：=="></a>==<strong>追问 4：</strong>==</h3><p>==<strong>面试官</strong>：除了防护SQL注入，你有没有使用过其他安全测试工具或者方法来确保系统的安全性？==</p><p>==<strong>你</strong>： “除了防护SQL注入，我还使用了OWASP ZAP这样的开源安全工具来进行自动化安全扫描，检测系统中是否存在常见的Web应用漏洞。通过ZAP，我能够模拟XSS攻击、CSRF攻击等常见威胁，并通过修复漏洞来提高系统的安全性。==</p><p>==此外，我还进行了手动渗透测试，特别是对认证和授权模块进行了重点测试，确保不同用户的权限边界清晰，避免未授权访问。在项目的开发过程中，我会定期进行这些安全测试，特别是在上线前进行全面的安全评估。”==</p><h3 id="提问-3：多线程测试"><a href="#提问-3：多线程测试" class="headerlink" title="==提问 3：多线程测试=="></a><strong>==提问 3：多线程测试==</strong></h3><p><strong>面试官</strong>：在单元测试中，如何处理一些比较难以测试的场景，例如多线程操作或异步调用？</p><p><strong>你</strong>： “在处理多线程操作和异步调用时，单元测试确实会更加复杂。对于多线程操作，我通常会确保线程安全性，例如在操作共享资源时，我会使用Java中的同步机制，或者使用线程安全的数据结构。在测试时，我会通过JUnit中的<code>CountDownLatch</code>等工具来确保多个线程都已经执行完毕，然后检查最终的结果是否符合预期。</p><p>对于异步调用，我会使用JUnit的<code>CompletableFuture</code>来处理异步结果的测试，确保测试程序不会因为异步调用的延迟而直接返回。在某些情况下，我还会使用Mockito的<code>doAnswer</code>方法来模拟异步行为并测试其结果。”</p><hr><h3 id="追问-3："><a href="#追问-3：" class="headerlink" title="追问 3："></a><strong>追问 3：</strong></h3><p><strong>面试官</strong>：那在多线程测试中，你有没有遇到过死锁问题？你是如何排查和解决的？</p><p><strong>你</strong>： “在之前的项目中，我确实遇到过一次死锁问题。通过使用线程监控工具（如JVisualVM），我发现某些线程在竞争同一资源时陷入了死锁。解决的办法是分析代码中锁的顺序，确保所有线程按相同的顺序获取锁，避免循环等待。</p><p>另外，我重构了部分代码，减少了锁的粒度，避免不必要的长时间锁定资源。在测试时，我会使用较高的并发量模拟这种场景，确保经过优化后，死锁问题不再发生。”</p><h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>“面试官您好，我叫马增龙，我求职的岗位是XXXXX。我将于2025年毕业于山东师范大学，目前正在攻读电子信息专业的硕士学位，方向是计算机技术。我一直对技术驱动的项目充满热情，并且在校期间有多次实习和相关的项目经验，这些经历使我积累了丰富的实践经验。</p><p>对于实习和项目经历，主要分为技术与管理、算法实习和个人软硬件系统项目三个方面：</p><p>在学而思实习期间，以实习生进入研发部门，然后调入到新项目中，参与并完成了红笔部门的构建与扩张，同时作为技术组长与研发部门对接，完成整个作业批改系统的上线与搭建。</p><p>第二段远程实习，我参与了军体拳行为识别与评价系统的实现，主要参与数据和模型训练的工作。</p><p>最后自己以独立开发者的身份完成了一个个人项目，室内空气环境数据监测与控制系统，同时包含软件端、硬件端和云端的系统实现。</p><p>在完成实习和项目学习的基础上，我的校内课程成绩也名列前茅。本科毕业时我GPA进入专业前10%，也获取到了保研名额，毕业时获取到优秀毕业生、优秀学生等奖项。读研期间，我扎根于自己的方向，热爱技术和科研，扩展自己的可能性。我热爱写博客，读研两年左右，我搭建个人博客写下将近39w字的个人技术博客，有很强的学习和动手能力；喜欢看书和运动，有良好的身体素质和抗压能力，热情开朗，善于与人沟通。</p><p>好，以上便是我的个人介绍，感谢各位的聆听和时间，敬请大家的批评指正。</p><h4 id="自我介绍需要注意的点："><a href="#自我介绍需要注意的点：" class="headerlink" title="自我介绍需要注意的点："></a><strong>自我介绍需要注意的点：</strong></h4><ol><li><strong>突出核心技能</strong>：强调了你的Java开发和测试经验，提到具体工具（如JUnit、Mockito、JMeter、Docker、Jenkins等）来展示你的技术深度。</li><li><strong>结合项目经验</strong>：重点提到两个实习项目，具体描述你在其中的角色和贡献，展示你在实际项目中的能力。</li><li><strong>展示团队合作和管理能力</strong>：通过提到你在学而思的管理经验，展现了你的领导力和协调能力。</li><li><strong>引导面试官</strong>：你在自我介绍中提到了测试、性能优化、数据库管理等多个方向，面试官可能会根据这些内容提出进一步的问题，从而引导面试的重点话题。</li></ol><p>这份自我介绍既突出了你的技术背景，又能够引导面试官朝着你的优势领域展开提问，使你更容易展示自己的实力。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在我之前的实习经历中，我参与了多个关键项目的开发和测试工作。比如，在北京学而思的实习期间，我作为技术组长，负责后台系统的开发和测试，管理了团队的代码质量，制定了详细的测试策略，使用JUnit和Mockito等工具进行了单元测试和集成测试，确保了系统的稳定性和安全性。此外，我还参与了权限分配和数据库优化的工作，并通过性能测试工具如JMeter进行了压力测试，有效提升了系统的性能表现。</span><br><span class="line"></span><br><span class="line">同时，我还在‘军体拳视频人体行为识别系统’项目中负责了数据采集、算法研究和模型测试。通过对模型的测试和优化，我对深度学习在实际应用中的测试流程有了更深刻的理解。我还善于通过自动化工具管理测试环境，使用Docker和Jenkins简化了部署流程。</span><br><span class="line"></span><br><span class="line">我擅长快速学习和解决问题，尤其是在面对复杂系统时，能够迅速找到问题的根源并提出解决方案。在团队合作方面，我具有良好的沟通和组织能力，能够有效统筹团队工作，并推动项目顺利进行。</span><br><span class="line"></span><br><span class="line">总的来说，我相信我的开发和测试能力，加上对技术的深入理解和团队管理经验，能够为贵公司带来价值。我也很期待能在这次面试中展示更多我的技能和经验。”</span><br><span class="line"></span><br><span class="line">技术范围比较广泛：</span><br><span class="line"><span class="bullet">1.</span> 软硬件系统项目</span><br><span class="line"><span class="bullet">2.</span> 技术与管理项目</span><br><span class="line"><span class="bullet">3.</span> 算法项目</span><br></pre></td></tr></table></figure><h2 id="为什么转到测试上来"><a href="#为什么转到测试上来" class="headerlink" title="为什么转到测试上来"></a><strong>为什么转到测试上来</strong></h2><p>了解你为什么从事测试岗位而不是继续走Java开发的方向。你可以结合自己在开发过程中对<strong>软件质量</strong>的关注，以及<strong>测试对于整个开发流程的重要性</strong>来回答。以下是一个有针对性的回答模板：</p><p><strong>回答模板：</strong></p><p>“感谢您的问题。我在简历中的确参与了很多Java开发的项目，这些经历让我对软件开发有了深入的理解。然而，随着我在项目中越来越多地接触到软件测试相关的工作，我意识到<strong>测试对于整个开发流程的重要性</strong>。一个好的软件不仅需要出色的开发，还需要严密的测试来保证它的稳定性和可扩展性。</p><p>在实际项目中，我深刻体会到<strong>开发和测试是相辅相成的</strong>。在开发过程中，我会主动编写单元测试和集成测试，使用JUnit和Mockito等工具确保代码质量。在这些过程中，我逐渐发现自己对测试的严谨性和系统化的设计产生了浓厚的兴趣。特别是在做性能优化和安全性测试时，我意识到测试不仅仅是为了找出问题，更是为了<strong>提升系统的整体质量</strong>，这让我非常有成就感。</p><p>因此，我选择了软件测试这个方向，因为我希望能够更加专注于<strong>提升软件质量</strong>，帮助团队及早发现潜在问题，并通过测试保障产品的稳定性和用户体验。我相信我在开发中的经验将帮助我更好地理解系统架构，从而在测试中能更有针对性地设计测试用例，识别潜在问题。”</p><hr><h4 id="回答的核心要点："><a href="#回答的核心要点：" class="headerlink" title="回答的核心要点："></a><strong>回答的核心要点：</strong></h4><ol><li><strong>从开发到测试的过渡</strong>：解释你从开发转向测试的原因，表明你对质量保障的重视。</li><li><strong>开发和测试的互补性</strong>：强调你在开发过程中已经积累了丰富的测试经验，并且认识到测试的重要性。</li><li><strong>个人兴趣</strong>：表明你对测试工作的兴趣和热情，尤其是你发现测试能够带来系统性的改进。</li><li><strong>结合开发经验的优势</strong>：指出你的开发背景能够帮助你更好地理解系统，从而设计出更有效的测试策略。</li></ol><p>通过这种方式，面试官会明白你选择测试岗位是基于你对质量和测试工作的认同，而不是因为开发方面的不足。</p><blockquote><p>加入保证用户质量的回答</p></blockquote><p><strong>回答模板：</strong></p><p>“感谢您的问题。我在简历中的确有很多Java开发相关的项目经验，这让我对软件的设计和实现有了深入的理解。然而，随着我逐渐参与更多的开发工作，我发现自己对软件质量、特别是<strong>用户体验</strong>的提升越来越关注。在实际项目中，我意识到软件不仅仅是要代码正确、性能优秀，还必须要确保它在最终用户手中能够无缝使用，这让我对<strong>测试岗位</strong>产生了浓厚的兴趣。</p><p>在开发过程中，我负责过用户管理和权限分配等功能模块的开发和测试，这些模块的准确性直接关系到用户的使用感受。在执行功能测试时，我不只是关注代码的正确性，还特别留意<strong>用户的使用路径和潜在痛点</strong>。我常常通过设计不同场景的测试用例，模拟用户的操作，确保无论是正常使用还是极端情况下，系统都能给用户提供良好的反馈和体验。</p><p>测试不仅是为了找出技术问题，更是为了从用户的角度出发，保证软件的<strong>稳定性</strong>和<strong>可用性</strong>。所以我选择了转向软件测试这个方向，因为我希望通过我的工作，帮助开发团队及早发现那些可能会影响用户体验的细节问题，并通过全面的测试来提升产品的用户满意度。结合我在开发中的背景，我可以更好地理解用户需求和系统逻辑，从而设计出<strong>更贴近用户真实场景</strong>的测试用例。”</p><hr><h4 id="回答的核心要点：-1"><a href="#回答的核心要点：-1" class="headerlink" title="回答的核心要点："></a><strong>回答的核心要点：</strong></h4><ol><li><strong>用户体验的关注</strong>：强调测试岗位的重要性不仅在于技术问题的解决，还在于确保最终用户的使用体验。</li><li><strong>实际项目中的用户视角</strong>：通过具体项目展示你在测试过程中如何考虑用户的操作路径和感受。</li><li><strong>结合用户视角与开发背景的优势</strong>：指出你不仅能从开发角度进行测试设计，还能站在用户的立场来审视系统。</li><li><strong>提升用户满意度</strong>：强调你希望通过测试工作帮助提升用户的满意度，这也是你选择转向测试岗位的重要原因。</li></ol><p>通过这种方式，面试官能够看到你对软件测试有更全面的理解，尤其是在<strong>用户体验</strong>方面的重视。这种回答能够很好地展示你不仅关注技术实现，更希望从用户角度出发，提升产品的整体质量和满意度。</p><h2 id="关于测试开发的未来规划"><a href="#关于测试开发的未来规划" class="headerlink" title="关于测试开发的未来规划"></a>关于测试开发的未来规划</h2><p>未来规划和工作方向时，你可以利用这个机会展示你的<strong>学习能力</strong>和<strong>对测试开发岗位的兴趣与信心</strong>。结合你过往经验和未来规划，展现你对持续学习和发展的态度。</p><h3 id="回答模板"><a href="#回答模板" class="headerlink" title="回答模板"></a>回答模板</h3><p>“关于我的未来规划，尽管我之前的项目主要以Java开发为主，但正是这些项目经验让我认识到<strong>软件质量保障</strong>和<strong>用户体验</strong>的重要性，这也是我选择测试开发作为未来工作方向的原因。我希望未来能在测试开发领域深入发展，并将自己在开发中的优势带入测试工作中，帮助团队不仅实现功能，还能确保产品的稳定性和用户体验。</p><p>我非常清楚测试开发岗位需要不断学习新的技术和工具，特别是针对自动化测试、性能测试以及安全性测试等方面，我会通过自学和团队合作来逐步掌握这些技能。我也非常适应<strong>快速学习</strong>，比如在过去的项目中，我通过自学掌握了SpringBoot、MyBatis等框架，并能独立完成项目的开发和测试工作。</p><p>我的规划是，在未来的工作中，<strong>通过持续学习和项目实践</strong>，快速弥补我在测试领域的知识空白。我已经开始深入学习与测试开发相关的知识和工具，如Selenium、Jenkins、JMeter等，确保能够快速上手并独立负责测试任务。我相信我的开发背景能让我在理解系统架构和设计时具有一定的优势，这将帮助我设计出更加有效的测试用例。</p><p>在工作中，我希望通过不断优化测试流程，帮助团队提升软件质量，并推动开发和测试的紧密结合。我相信测试开发不仅仅是发现问题，更是为了预防问题，提升整个产品的用户满意度。”</p><hr><h3 id="回答的关键点："><a href="#回答的关键点：" class="headerlink" title="回答的关键点："></a><strong>回答的关键点：</strong></h3><ol><li><strong>学习能力和适应性</strong>：展现你强大的学习能力，强调你在未来可以快速掌握与测试开发相关的知识。</li><li><strong>明确的工作方向</strong>：表明你对测试开发岗位的坚定选择，并结合你现有的开发经验，展示你对测试工作有长远的规划。</li><li><strong>开发背景的优势</strong>：突出你的Java开发经验如何帮助你更好地理解测试工作，尤其是系统架构的理解和测试用例的设计。</li><li><strong>未来的提升和贡献</strong>：表达你愿意在测试流程优化和质量提升方面贡献力量，明确你对岗位的长远价值。</li></ol><h2 id="个人反问"><a href="#个人反问" class="headerlink" title="个人反问"></a>个人反问</h2><p>您对这个岗位的求职者或者胜任者在展开具体工作时，有什么具体的要求吗？主要涉及到业务上和技术上的~</p><p>您最希望在这个岗位上工作的人是一个什么样的人？具备什么样的能力或者特性</p><p>您觉得我的简历或者刚刚面试过充过程中最大的问题是什么，应该怎样去改进呢~</p><h2 id="软测准备链接"><a href="#软测准备链接" class="headerlink" title="软测准备链接"></a>软测准备链接</h2><p><a href="https://www.yuque.com/tuobaaxiu/inyebp/ngxaas">https://www.yuque.com/tuobaaxiu/inyebp/ngxaas</a></p><p><a href="https://www.yuque.com/tuobaaxiu/inyebp/nugrfc">https://www.yuque.com/tuobaaxiu/inyebp/nugrfc</a></p><p>一面一分钟的自我介绍 一定要卡好时间喔</p><p>终面大家要去上海，但是会报销来回车费和住宿</p><p>二面是情景化面试朋友</p><p>薪资的话是没有绩效这一说的</p><blockquote><p>一分钟自我介绍准备</p></blockquote><p>1.2w的薪资构成是怎样的</p><p>你好，每进入一个流程前发邮件更新简历的</p><blockquote><p>销售简历 重置一下</p></blockquote><p>建议穿正装</p><p>一面三次机会呀，没开始一面的朋友好好准备一下吧</p><p>1.2w-1.5w/月，详情可以查看岗位JD朋友</p>]]></content>
    
    
    <summary type="html">个人简历侧开模拟问答</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>boss_and_job</title>
    <link href="https://www.fomal.cc/posts/c0bca80f.html"/>
    <id>https://www.fomal.cc/posts/c0bca80f.html</id>
    <published>2024-09-17T02:42:34.000Z</published>
    <updated>2024-09-24T10:21:43.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h1><p>第一场面试——与爱为舞的用户增长实习生面试</p><blockquote><p>公司个人了解： 主要招聘的技术岗位基本为社招，且需要相关的工作经验(大部分为算法、大模型岗位)</p><p>主要以实习生转正为基础，感觉直接秋招的岗位比较少</p></blockquote><p>AI +教育科技有限公司——23年成立</p><p>AIGC 岗位 实现AI 教师生态系统</p><p>简单来说，就是把在线教育的各个场景分别用AI进行替代，例如AI流量，AI销售，AI老师等</p><p>==用户增长实习生招聘要求==</p><p><img src="../assets/9dbc8a8f997e1f612a2a1686e74c4e7e.png" alt="A1069449F9A03E7E7757F8FED51B5D09.webp"></p><blockquote><p>数据分析、实验设计、投放策略</p><p>智能投放平台，协助业务同学，构建平台</p><p>内容策略完善，迭代内容产品</p><p>策略创新，获取新的客户需求点</p></blockquote><h2 id="公司了解"><a href="#公司了解" class="headerlink" title="公司了解"></a>公司了解</h2><p>爱度 ai度 ——非常喜欢</p><p>兴趣 阶段 效率 潜力 ——为什么要加上阶段 二字</p><p>怎样盈利/怎样落地呢？——为每一个用户生成一个个人的AI教育产品？？</p><blockquote><p>AIGC ——新东方，学而思，考虫网，飞驰学院</p><p>王一快——秘塔科技 写作猫</p><p>Chatgpt——搭建平台 搭载一个服务器</p><p>AI数据算法智能平台</p></blockquote><p> 那么多才能怕 </p><h2 id="用户增长java-招聘："><a href="#用户增长java-招聘：" class="headerlink" title="用户增长java 招聘："></a>用户增长java 招聘：</h2><p>1)业务介绍：通过小红书运营获取自然流，做IP打造，从而获取流量，对接哆啦平台</p><p> 2)岗位：Java（用户增长） </p><p>3)要求：做过小红书平台流量增长业务优先 </p><p>Java（用户增长）</p><p>5.负责在线教育公域获客场景底层系统开发，构建低成本大规模获客技术能力； </p><p>6.负责将公司底层AI能力系统化/工程化，赋能流量获客端业务； </p><p>7.负责公司流量端团队业务系统开发，提效工具开发； </p><p>8.负责系统架构设计/开发/优化工作，保障获客系统的高可用性/高稳定性/高并发支撑</p><p>数据工程实习生</p><p>数据库工程实习生</p><h1 id="9-12-9-20-号总结"><a href="#9-12-9-20-号总结" class="headerlink" title="9.12-9.20 号总结"></a>9.12-9.20 号总结</h1><h1 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h1><p>我现在在求职找工作，针对自己简历做技术面准备。你作为一个面试官，完成技术面试中的提问-解答-追问-解答过程模拟。阅读完我下边简历中的一个实习部分，对我的该部分进行所涉及到的技术上的提问，然后给出分析过程和解答。注意重点针对技术内容提问，并重点关注技术细节，因为有些技术我可能已经忘记了，所以需要你来模拟场景帮我回忆并重新学习，可以设计到技术的八股文，多问技术问题，并给出解答，然后继续追问该技术问题，最后再次给出分析和回答并用实例来概述工作。</p><p>你作为一个面试官，完成技术面试中的提问-解答-追问-解答过程模拟。阅读完我下边简历中的一个实习部分，对我的该部分进行所涉及到的技术上和业务上的提问，然后给出分析过程和解答。注意在提问时一定要针对我下边简历描述的内容来提问，包括对于实习时项目背景、每一条所列举的承担工作以及最后实习收获上做的业务和技术上进行提问，你在给出回答之后继续进行追问，多问技术问题，然后再次给出分析和回答并用实例来概述工作</p><p>请继续对于我上边的简历内容完成提问-解答-追问-解答的面试过程模拟，问题不要与上边重复，仍然重点关注简历内容的技术和业务上的重点进行展开</p><p>你作为一个面试官，帮我详细分析一下下边我简历里边可能会被问到的一些问题，包括技术上和业务内容上的问题。 下边是我的简历详细内容</p><p>你作为一个资深的java测试开发工程师，来担任面试官，完成技术面试中的提问-解答-追问-解答过程模拟。我会把我的简历发给你，你对我的简历进行所涉及到的技术上和业务上的提问，然后给出分析过程和解答。注意在提问时一定要针对我下边简历描述的内容来提问，包括对于实习时项目背景、每一条所列举的承担工作以及最后实习收获上做的业务和技术上进行提问，你在给出回答之后继续进行追问，多问技术问题，然后再次给出分析和回答并用实例来概述工作</p><p>你作为一个资深的java测试开发工程师，来担任面试官，我会把我的简历发给你，你来帮我从面试官的角度分析一下对我的简历在测试开发面试中，会从哪些地方来提问？我应该如何作答呢？</p><h3 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h3><ol><li>你作为一个资深的java测试开发工程师，来担任面试官，我会把我的简历发给你，你来帮我从面试官的角度分析一下对我的简历在测试开发面试中，会从哪些地方来提问？我应该如何作答呢？</li><li>这是我的个人简历，我下午有一个测试开发工程师面试，你来帮我从面试官的角度分析一下对我的简历在测试开发面试中，会从哪些地方来提问？我应该如何作答？我该怎样去快速准备来应对该面试？</li><li>针对你上边给出的这些提问，请你从java测试开发工程师的角度，结合我给你的我个人的简历，你帮我作答一下吧~</li><li>请你结合我的简历，请你从java测试开发工程师的角度，从开始面试到问答和追问环节，全程针对测试技术来展开，完成提问-回答-追问再回答的过程模拟，给出问题分析和详细回答吧~</li><li>请继续对于我上边的简历内容完成提问-解答-追问-解答的面试过程模拟，问题不要与上边重复，仍然重点关注简历的项目和实习经验的重点展开，主要针对测试开发技术</li><li>请继续对于我上边的简历内容完成提问-解答-追问-解答的面试过程模拟，问题不要与上边重复，这次重点针对测试开发技术，对我第一段实习经历中的业务和涉及到测试技术来展开问答</li></ol><blockquote><p>快速准备</p></blockquote><p>你现在是资深的测试开发工程师，作为面试官，你来看一下：这是我的个人测试开发的简历，但我现在基本没有学习过测试开发的知识点，也没有系统学习过测试开发的内容，如果我想要快速的用3天时间突击准备测试开发工程师的面试，我应该怎样准备呢？</p><p>请结合我的个人简历项目，从面试八股题、项目怎样加入侧开的技术引导面试官、如何快速准备等多个角度来帮我指导一下吧</p><p>请继续对于我上边的简历内容完成提问-解答-追问-解答的面试过程模拟，问题不要与上边重复，仍然重点关注简历的项目和实习经验的重点展开，主要针对测试开发技术</p><p>面试策略</p><p>熟识背诵mysql + 计算机网络的八股</p><blockquote><p>所有的问题都往数据层、mybatis层、网络层去讲，这样在那边详细解决</p></blockquote><h1 id="面试复盘-amp-amp-准备"><a href="#面试复盘-amp-amp-准备" class="headerlink" title="面试复盘&amp;&amp;准备"></a>面试复盘&amp;&amp;准备</h1><h1 id="笔试复盘-amp-amp-准备"><a href="#笔试复盘-amp-amp-准备" class="headerlink" title="笔试复盘&amp;&amp;准备"></a>笔试复盘&amp;&amp;准备</h1><p>ACM输入输出VS 在LeetCode上的核心代码模式</p><h1 id="简历栏目"><a href="#简历栏目" class="headerlink" title="简历栏目"></a>简历栏目</h1><blockquote><p>张文豪简历用的啥做的</p><p>秋招八股文: 常学习常更新，将新学的技术/背的八股文放到建立上去</p><p>版弄的⼲净简洁大方，</p><p> 之前看过⼀个同学的简历，很丰富、优秀的经历，写了两⻚，但排版有点乱，⾏距有点窄，挤在⼀起，会给我<br>⼀种没有条理的感觉。</p><p>3.简历和岗位匹配程度(能扯测试就扯上测试)<br>我和测开的关系⽐较少，<strong>简历上能写的就是专业技能</strong>，写⼀下⽬前掌握的测试知识和⼯具等等。有时间的跟着<br>B站做个项⽬，可以添加到项⽬经验⾥。<br>也可以在你参加的团<strong>队⽐赛或者项⽬中，个⼈职责写上开发和测试，虽然我都没做过测试，主要是想增加简历</strong><br><strong>和岗位的匹配度</strong>，⾯试有可能会问你在<strong>这个项⽬中做过什么测试，你可以按照⽬前所学知识展开说，⽐如⽬前</strong><br><strong>只学到功能测试，就结合项⽬说⼀下从哪些⻆度设计了测试⽤例，如果你学了⾃动化测试⼯具和性能测试⼯</strong><br><strong>具，也可以先想想怎么对⾃⼰的项⽬做测试。</strong></p></blockquote><p><img src="../assets/image-20240922093025445.png" alt="image-20240922093025445"></p><blockquote><p>关于项目经历，可以按照项目技术栈、项目简介/描述、完成模块/自己职责/负责模块/核心技术点三个部门去写。 技术栈：主要介绍项目使用到的技术栈有哪些，挑重点核心的技术写即可，占据一行。 项目简介/描述：主要介绍项目的背景和相关的功能模块，语句一定要精简！ 完成模块/自己职责/负责模块/核心技术点：比如使用xx解决了xx问题，可以分点列几点比较核心的，语句一定要精简！ 注意⚠️：对于开发环境可写可不写。 </p><p>作者：代码界的小白<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/0b9e69155feb414597e4c5df678f2c9b?sourceSSR=search">https://www.nowcoder.com/feed/main/detail/0b9e69155feb414597e4c5df678f2c9b?sourceSSR=search</a><br>来源：牛客网</p></blockquote><h4 id="技术简历"><a href="#技术简历" class="headerlink" title="技术简历"></a>技术简历</h4><blockquote><p>java软开、</p><p>软件测试开发、</p></blockquote><h4 id="非技术简历"><a href="#非技术简历" class="headerlink" title="非技术简历"></a>非技术简历</h4><p>技术支持/运维/售前售后  </p>]]></content>
    
    
    <summary type="html">个人成长&amp;&amp;公司深入了解</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>网站重建，梦想开启</title>
    <link href="https://www.fomal.cc/posts/c318edab.html"/>
    <id>https://www.fomal.cc/posts/c318edab.html</id>
    <published>2024-09-06T14:10:38.000Z</published>
    <updated>2024-09-07T14:14:37.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站重建，梦想开启"><a href="#网站重建，梦想开启" class="headerlink" title="网站重建，梦想开启"></a>网站重建，梦想开启</h1><h2 id="博客重启的巴拉巴拉（必备工具）"><a href="#博客重启的巴拉巴拉（必备工具）" class="headerlink" title="博客重启的巴拉巴拉（必备工具）"></a>博客重启的巴拉巴拉（必备工具）</h2><p><a href="https://blog.cuijiacai.com/blog-building/">https://blog.cuijiacai.com/blog-building/</a></p><p><a href="https://www.bilibili.com/video/BV1qD4y1z783/?vd_source=3d5976f4f96ce120bf88891647d386cb">超详细的个人博客搭建教程（无需服务器）- 从原理到实践手把手带你搭建属于自己的个人博客_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.788&amp;vd_source=3d5976f4f96ce120bf88891647d386cb">https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.788&amp;vd_source=3d5976f4f96ce120bf88891647d386cb</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">🐖抓到你啦～ (fomal.cc)</a></p><h1 id="重启操作教程"><a href="#重启操作教程" class="headerlink" title="重启操作教程"></a>重启操作教程</h1><p>熟能生巧</p><p>github 用git访问+chatgpt的回答帮助</p><ol><li>nodejs + nmp  安装+版本匹配<ol><li>删除nmp</li><li>更改下载源</li></ol></li><li>hexo 下载 单独安装配置up项目</li><li></li><li></li></ol><p><img src="../assets/image-20240906221418850.png" alt="image-20240906221418850"></p><h1 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h1><blockquote><p>2024年5月3日 gitee的page服务 被关闭，不在对外访问，导致自己的网站无法访问，也不能再继续写笔记和完成自己的博客l</p></blockquote><p>在2024年9.6日 重新为了封装简历，想着哪怕拿出一天的时间，全部花进去，用来把自己的博客后台迁移，从不能访问的gitee 迁移到github</p><p>花了一天的时间，从一开始7:00左右的信心满满，动力十足，到快到10：20左右，【在这期间成功的把之前的GitHub不能用git访问的问题解决了这个问题困扰了好久】然后跟我家美女一起改简历，搬到小教室里边，用自己的手机开热点，直到11：40左右，成功的能够跟之前一样，用hexo d 和hexo -g 完成数据往远端传输，搜着网页上说问题是网络不好</p><p>而且在用hexo d 传输的时候，蹦出一个网页，用来验证github的账号登录情况，这时候就知道能够完成数据传输了</p><p>当时是开着热点在小教室里，就没去吃饭，一直开着热点，给手机充电，期望能够成功，幸好最后成功传输上去了！！！</p><h4 id="但是页面确实不能正常展示，估计是渲染主题的问题，也有可能是nodejs-和hexo-版本问题，导致hexo下载主题失败"><a href="#但是页面确实不能正常展示，估计是渲染主题的问题，也有可能是nodejs-和hexo-版本问题，导致hexo下载主题失败" class="headerlink" title="但是页面确实不能正常展示，估计是渲染主题的问题，也有可能是nodejs 和hexo 版本问题，导致hexo下载主题失败"></a>但是页面确实不能正常展示，估计是渲染主题的问题，也有可能是nodejs 和hexo 版本问题，导致hexo下载主题失败</h4><p>npm  与 node 匹配 </p><p>下载使用的node.js 是12.19.0版本</p><h6 id="nodejs和npm版本不匹配：ERROR-npm-is-known-not-to-run-on-Node-js-v10-16-2"><a href="#nodejs和npm版本不匹配：ERROR-npm-is-known-not-to-run-on-Node-js-v10-16-2" class="headerlink" title="nodejs和npm版本不匹配：ERROR: npm is known not to run on Node.js v10.16.2"></a>nodejs和npm版本不匹配：ERROR: npm is known not to run on Node.js v10.16.2</h6><p><a href="https://blog.csdn.net/qq_41992943/article/details/124925758">nodejs和npm版本不匹配：ERROR: npm is known not to run on Node.js v10.16.2-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45056216/article/details/101163126">关于node js和 npm 版本不匹配的情况_linux中npm版本个nodejs版本不匹配解决方法-CSDN博客</a></p><p>删除node 重装</p><p>node 12.19.0 重装</p><p>更改 npd 源头</p><h6 id="npm报错：request-to-https-registry-npm-taobao-org-failed-reason-certificate-has-expired"><a href="#npm报错：request-to-https-registry-npm-taobao-org-failed-reason-certificate-has-expired" class="headerlink" title="npm报错：request to https://registry.npm.taobao.org failed, reason certificate has expired"></a>npm报错：request to <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a> failed, reason certificate has expired</h6><p><a href="https://blog.csdn.net/maoge_666/article/details/136038003">npm报错：request to https://registry.npm.taobao.org failed, reason certificate has expired-CSDN博客</a></p><p>hexo  重装——直接在新文件夹中安装</p><h6 id="win10系统使用npm安装hexo失败"><a href="#win10系统使用npm安装hexo失败" class="headerlink" title="win10系统使用npm安装hexo失败!"></a>win10系统使用npm安装hexo失败!</h6><p><a href="https://github.com/hexojs/hexo/issues/2741">win10系统使用npm安装hexo失败! · Issue #2741 · hexojs/hexo (github.com)</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> -<span class="selector-tag">g</span> hexo-cli    </span><br><span class="line">sudo npm install gulp-cli -<span class="selector-tag">g</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/hexojs/hexo-cli/issues/23">hexo-cli 安装后失败 ·问题 #23 ·hexojs/hexo-cli 命令 (github.com)</a></p><p>git上传文件和文件夹</p><h6 id="Github如何上传项目-超详细小白教程"><a href="#Github如何上传项目-超详细小白教程" class="headerlink" title="Github如何上传项目(超详细小白教程)"></a>Github如何上传项目(超详细小白教程)</h6><p><a href="https://blog.csdn.net/KevinRay_0854/article/details/140408003">Github如何上传项目(超详细小白教程)_github上传项目-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40413898/article/details/104287509#:~:text=git基本操作：将指定文件夹内容或代码文件推送到GitHub中的基本步骤 1 1、在GitHub中新建一个仓库 在创建仓库是，一些配置说明如下： Repository name%3A 仓库名称 Description,. ... 5 5、最终结果 将本地仓库与远程仓库连接 再次要推送文件时，需要与远程仓库进行交互，使用git remote指令。">git基本操作：将指定文件夹内容或代码文件推送到GitHub中的基本步骤_github推送文件夹视图工具-CSDN博客</a></p><h4 id="验证登录框"><a href="#验证登录框" class="headerlink" title="验证登录框"></a>验证登录框</h4><blockquote><p>为了方便下次再碰到这种问题，记录一下蹦出的网页情况</p></blockquote><p>网页蹦出来是个小的登录界面，可以直接打开链接，然后验证与github账号的关联，同时确定能够跟这个电脑设备关联上。</p><p>打开链接，是一个github页面，然后输入设备登录码！！！很重要的成功标志</p><blockquote><p>幸好chatgpt帮助 解决 git 访问github</p><ol><li>配置对应的github库，需要设置好远程库与用户名一致，然后后边加上github.io</li><li>先将up的模板放到github库中，详见配置教程</li><li>再将自己的test文件上传到对应的目录中，在进行hexo d 上传</li></ol></blockquote><h1 id="秋招文件收集"><a href="#秋招文件收集" class="headerlink" title="秋招文件收集"></a>秋招文件收集</h1><p>数据库项目</p><p><a href="https://articles.zsxq.com/id_gsuoxn7qnvip.html">轮子实战项目：手写数据库 MYDB (zsxq.com)</a></p><p><a href="https://blog.csdn.net/qq_40856284/article/details/121580249">一起写个数据库 —— 0. 项目结构和一些不得不说的话-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40856284/category_11504274.html">一起写个数据库_何人听我楚狂声的博客-CSDN博客</a></p><p>技术派</p><p><a href="https://paicoding.com/article/detail/472">如何将技术派写到简历上？-技术派 (paicoding.com)</a></p><p>PmHub</p><p><a href="https://www.yuque.com/canghe-u0ocv/laigeoffer-pmhub/mdoff4twogexi4ri">✅人人都是产品经理，打造竞争优势（🌟新人必看） (yuque.com)</a>   cgd9</p><p>八股学习</p><p><a href="https://javabetter.cn/sidebar/sanfene/nixi.html">面渣逆袭必看，面试题八股文Java基础、Java 集合框架、Java 并发编程、JVM、Spring、Redis、MyBatis、MySQL、操作系统、计算机网络、RocketMQ、分布式、微服务、设计模式、Linux👍 | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>面试题整理</p><p><a href="https://top.interviewguide.cn/">InterviewGuide大厂面试真题</a></p><h2 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h2><blockquote><p>刷面经</p><p><a href="https://www.yuque.com/snailclimb/mf2z3k/guh0u9hb3pr70rtk">大厂四年，2024 阿里、字节、蚂蚁、小红书面试经历分享 (yuque.com)</a>      《面试指北》cnk4</p></blockquote><p><a href="https://interviewguide.cn/notes/05-xiustar/02-campus_prepare/04-01-互联网面试总结.html">⭐阿秀三个多月、50余场面试经验浓缩为经验和总结 | 阿秀的学习笔记 (interviewguide.cn)</a></p><p>简历修改</p><p>优质简历样例——<a href="https://articles.zsxq.com/id_5p3fcdmwpw4h.html">精选简历：基本信息、教育背景、专业技能、工作经验、项目经历、实习经历、荣誉证书写的比较好的例子 (zsxq.com)</a></p><p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/182882241124882">知识星球 | 深度连接铁杆粉丝，运营高品质社群，知识变现的工具 (zsxq.com)</a></p><p>如何写好简历——<a href="https://www.yuque.com/itwanger/gykdzg/grvrtx?singleDoc=#e9486e82">如何写好简历？（完结） (yuque.com)</a>——王二</p><p>毒液   <a href="https://erdengk.top/archives/jian-li--mian-shi">简历、面试 | 我的知识海洋 (erdengk.top)</a></p><h2 id="知识星球常用"><a href="#知识星球常用" class="headerlink" title="知识星球常用"></a>知识星球常用</h2><p><a href="https://wx.zsxq.com/dweb2/index/favorites">收藏</a></p><p>秀哥资源——<a href="https://articles.zsxq.com/id_dmf00wjw9dtm.html">🏆资源沉淀 (zsxq.com)</a></p><p>秀哥问答——<a href="https://articles.zsxq.com/id_wm06pp9dnogj.html">📖知识图谱（星球问答文章精华） (zsxq.com)</a></p><p><a href="https://interviewguide.cn/notes/05-xiustar/03-resume/01-00-简历开篇词.html">简历远远比你想要的重要的多 | 阿秀的学习笔记 (interviewguide.cn)</a></p><p>公司列表  <a href="https://www.yuque.com/itwanger/gykdzg/yvq87dkkwtax2m3u">https://www.yuque.com/itwanger/gykdzg/yvq87dkkwtax2m3u</a> 面试指南 gqya</p><p>优质主题——<a href="https://articles.zsxq.com/id_v6xfrmw5637h.html">JavaGuide 知识星球优质主题汇总（2024-04-01） (zsxq.com)</a></p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p><a href="https://www.coze.cn/">扣子 - AI 智能体开发平台 (coze.cn)</a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote><p>测试八股文/测开八股文</p></blockquote><p>算法题目</p><p>数据库基础知识+ sql题目</p><p>项目梳理</p><p>java八股文</p>]]></content>
    
    
    <summary type="html">网站迁移，重新开始博客之路</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>社科人文认知突破</title>
    <link href="https://www.fomal.cc/posts/cea7f2ca.html"/>
    <id>https://www.fomal.cc/posts/cea7f2ca.html</id>
    <published>2024-09-06T13:11:52.770Z</published>
    <updated>2024-09-17T06:10:07.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="社科人文认知突破"><a href="#社科人文认知突破" class="headerlink" title="社科人文认知突破"></a>社科人文认知突破</h2><h2 id="社会科学入门"><a href="#社会科学入门" class="headerlink" title="社会科学入门"></a>社会科学入门</h2><p>是这么回事，学习社会科学，学习文科，其实用处没你想得那么大。<br><strong>你如果想靠这个挣钱呢，那还是很难的。</strong></p><h2 id="学文科的好处"><a href="#学文科的好处" class="headerlink" title="学文科的好处"></a>学文科的好处</h2><p><strong>但是呢，学这玩意用处很大的，一个是陶冶自身的情操。另一个能避免被政府欺骗。</strong>    </p><p>学文科的话，其实最重要的是多读书，多积累，然后能学会万事万物的联系。</p><p>这个万事万物的联系，说的比较笼统，就是<strong>你读一本书，能想到别的书之间和这本书的联系。</strong></p><p>比如你读唐代的历史书，能联系到北周的柱国，再联系到皇帝的更迭， 那恭喜你，你已经学会一点了。</p><p><strong>学文科的话，最高的水平是能做预测分析，其次是做事后分析。</strong></p><p>做预测分析这玩意属于有点是占卜，没有固定的套路，但是做事后分析，寻找历史的真相，其实如果多积累，多思考，总是能找到路径的。<strong>但是呢，这个时间可能需要很多年的积累。</strong><br>学文科另一个方面是<strong>有利于你炒股</strong>，如果你将来会看工信部的数据，懂得如何分析走向，不敢说带你走向暴富，但是穷应该是可以避免。</p><h2 id="文科的坏处"><a href="#文科的坏处" class="headerlink" title="文科的坏处"></a>文科的坏处</h2><p>上面说了那么多学文科的好处，我也要说说学文科的坏处，一方面是要<strong>花费非常多的时间，</strong><br>另一方面是<strong>没有很明显的进步提示</strong>，他不像学数学，学了一本就有一本的知识，而是你要在庞大的积累后，<br>才能实现质的飞跃。</p><p>除此之外，另一个问题是<strong>容易走火入魔</strong>。关于走火入魔，比较明显的例子就是各种魔怔念经人，佐佐右右托派。</p><p>因为你读一些书，你就是和作者在产生交流和对话，作者会讲他的思考模式，然后把你说服，<br><strong>如果你能力不行，就很容易被他说服。</strong>      比较明显的例子就是哈耶克 和佛利德曼的书。</p><h2 id="怎么学习社科人文"><a href="#怎么学习社科人文" class="headerlink" title="怎么学习社科人文"></a>怎么学习社科人文</h2><p>好了，我要正视开始讲学文科的事情了。<br>首先呢，<strong>你需要积累一定的历史，</strong>（方便在了解一系列的东西之后，能够分析出其发生的背景以及对应的因果关系，方便结合时势分析）（其实也可以不积累，但是不积累的话，在看一些东西的时候，不能结合时代背景去认知）。<br>第二是<strong>根据自己的爱好，去决定学什么。</strong><br>文科里面，我个人首推的是<strong>逻辑学导论</strong>。这本书会教你如何去正确的思考，会让你避免一些基础的逻辑推导错误。<br>第二 我是推荐看<strong>经济历史</strong>。经济历史对于人的收获是，你能理解说一些事，是如何演化过来的。<br>比如说我们曾经是社会主义，为啥会90年代破产， 为啥会cr ，为啥到现在又重新国进民退。<br>第三，我推荐是看<strong>历史类的书</strong>，历史类的书，其实我个人推荐是看法国人还有英国人写的书，<br>这两个国家的特点就是有丰富的国外交流经验，是认真的理解国外的，英国的博物学家是一群很不可思议的人，<br>19世纪的英国探险者能穿越喜马拉雅山跑到拉萨和当地的活佛交流，20世纪的劳伦斯一个人就能推翻伊拉克帝国，<br>瓦解德国在阿拉伯地区的努力，而法国在非洲的殖民，甚至一度让美国人都感到绝望。</p><p>​    </p><h3 id="个人体验share"><a href="#个人体验share" class="headerlink" title="个人体验share"></a>个人体验share</h3><p><strong>哲学类的书我不推荐看，因为这个很耗时间，容易学不到东西。</strong><br>关于道德类的讨论，还有国学这一块，旧文化毫无疑问是死掉了，现在什么复兴国学啊，<br>无非是对着一具僵尸祈祷。如果你们想学这个呢，可以<strong>大概扫扫孔子孟子荀子加王阳明的传习录，</strong><br><strong>不过心学讲的更多的是人的解放。</strong>扫一扫就行，学深了没啥意义，这玩意本质上是一种道德教化，<br>但是实际上来说，真有用的还是看人能不能敢于斗争。。。。<br>学文科没啥固定的套路，<strong>有用就用，没用扔掉，别变成那只腐臭文人，指挥掉书袋。</strong><br>今天就暂时写那么多。欢迎大家一起互相讨论。</p><blockquote><p>天道有感</p></blockquote><ol><li>传统文化 强势文化 弱势文化 ==》演变成应该以政治文化为主，以道德和传统文化作为人文性情掌控的加锁</li><li>逐渐去学习现在很多事情的运行规律，多去尝试体会理解事物发展的本质规律，只有这样借势，慢慢去利用规律，才可能会帮助自己更好的认识本来的发展方向，更好的借力打力</li><li></li></ol><h3 id="政治cr是什么意思"><a href="#政治cr是什么意思" class="headerlink" title="政治cr是什么意思"></a><strong>政治cr是什么意思</strong></h3><p><a href="https://zh.wikipedia.org/wiki/CR">CR - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p>极度濒危<br>极危<br>严重濒危<br>极度濒危物种</p><p><strong>政治cr是一种政治符号语言，CR是Community Relief（社区救济）的缩写，指政治上中左派团体对给弱势群体提供的各种救济措施的简称。这个术语是在网络上出现的，源自于社交媒体上用户对政治、文化、社会问题的讨论。这个术语主要出现在中国网络空间中，因为中国社交媒体的特殊环境，这个术语主要指代的是一种执政党在为人民办事的同时，也是在为自己、为党派、为官僚机构、为强势集团利益服务的政治现实。</strong><br><strong>政治CR的主要表现形式包括但不限于各种策划、活动、宣传、演讲、集会、网络言论、社区服务等。其中，社区服务在中左派政治圈子中被认为是最典型、最重要的CR方式。中左派倡导政治CR，不仅是为了弱势群体的合法权益，而且也是为了塑造中左派的良好形象和生存空间。当今中国的政治环境不容乐观，中左派圈子在应对复杂政治环境和外部压力时需要将社区服务和救济作为其政治理念和社区组织中的核心内容，以此来表明自己的政治态度和提高自己的公信力。</strong><br><strong>政治CR还有一层意义，它是在对传统CR概念的一个批判和拓展。传统CR是指在弱势群体受到自然灾害等不可抗因素影响时，社会团体或个人通过捐款、物资等方式向遭受不幸的群体提供救济的行为。这种救济行为受到了许多批评，人们认为它追求的仅仅是短期效应，而没有深入研究问题的根源。而政治CR则更注重于问题的根源研究，在提供救助的同时，也更注重于倡导相关的政治观点，从而更具有持续性和影响力。</strong><br><strong>总而言之，政治CR作为一种政治行动形式，在中国等一些国家有着广泛的意义。它是中左派的一种社会实践方式，在提供弱势群体救济的同时，也是在呼吁社会公正和推动社会进步。</strong></p><p>个人人生复盘</p><blockquote><p>个人角色</p><p>个人规划</p></blockquote><h1 id="润宇笔记"><a href="#润宇笔记" class="headerlink" title="润宇笔记"></a>润宇笔记</h1><p>拆解笔记，解读拆分   带货小时榜  咋没有知识付费或者教育类的呀  润宇老师<br>这个小时榜就代表了限时限刻的流行风<br>我今天也要调整我的带货顺序了[偷笑]<br>拆解他到底在买什么？  把每个直播间最撑着他直播销售的量的商品【100w中 有80w的商品】<br>10个商品 找出货盘，找出排名的前几个，哪些是主推的【人 货 场 】短视频的量？  投流来的量 还是转发来的</p><p>套路话术  看懂有什么过程  会逼单<br>如何卖？话术、时间循环、塑造价值、当下购买的理由<br>对哪些人   说那些话  卖什么货  产生了价值</p><p>先去看哪些有用  再去看他的逻辑【从消费者行为 去想为什么去买】<br>1、货盘、热卖的产品 2、引流品、信任品、利润品 3、流量是怎么来的：场观怎么来的<br>【ai 视频好 中华文化 疗愈  情绪价值 小红书【平台相关】  健康 】</p><p>普通人 ai 不是周鸿祎 则大可不必焦虑 </p><blockquote><p>ai只是辅助创作的手段，从来不觉得ai是风口</p></blockquote><p>对于刚刚起步的商业体   找机会的话，一定冲着一个目标去：离现金流一定要近</p><blockquote><p>离现金流近，就一定要离交易近【交易场景明确】</p></blockquote><p>一定是需求和供给已经贼明确或者自己可以发现的时候: 人 货 场 形成干柴烈火的状态，一定最近且一定会发生</p><p>卖 ai 课的人，对ai感到焦虑的需求，视频直播平台提供课程 卖ai课是三者清晰的</p><blockquote><p>技术开发者  消费者  应用者</p></blockquote><p>AI写作，产生内容呢?</p><p>李一舟的课程一环套一环的感觉</p><p>写视频文案</p><blockquote><blockquote><p>技术开发者，需要有先机，抢开发机会</p></blockquote><p>技术抢先机，会形成商业壁垒</p></blockquote><p>哈哈，我现在都用ai来接文案商单了</p><blockquote><p>ai消费者</p></blockquote><p>新能源汽车 </p><p>技术的应用者</p><blockquote><p> 比亚迪 dmi的电池技术  宁德时代的玻璃 和 电池</p></blockquote><p>好不好用，好不好看，是否有高性价比</p><blockquote><p>伺候好消费者 是所有消费者的义务</p></blockquote><p>消费者好用便宜，不关注技术</p><blockquote><p>最终的技术最后都会不断降低壁垒，是不用学的</p><p>最后都会推动到消费者</p></blockquote><p>好的东西是不用学的</p><blockquote><p>但是你提前学会了，就有信息差，也能够提高你的生产效率。</p></blockquote><p>应用者 光有信息差，只能卖课，也需要产生出其他的价值帮助别人</p><p>大部分想要赚钱的 或者是利用好产品赚钱的，是应用者</p><blockquote><p>光写出文案 ，没有流量。光有数字人替代直播，但是卖不出去货</p><p>光有生成的视频，但是不能有浏览量，也没什么用</p><p>商业的底层逻辑</p><p>光帮助了生成量产，但是不能扩宽边界，仍然</p></blockquote><p>极其理解用户的交易场景，制造了一个想像空间，让用户感受到他也能，他也行的想法<br>价格由供求关系来决定 不是你的数量来决定[东西稀缺才值钱]</p><blockquote><p>热辣滚烫  </p><p>用了一个很土的方法，100斤不稀缺，但是他在电影里真有的一个</p></blockquote><p>土是2024最大的稀缺<br>数字人没有情感与直播间的人不能产生共鸣。<br>手工写信，是因为你愿意花时间精力来干这样的事情，说明你很重要，被尊重，被重视，被需要<br>缺了真情实感<br>技术需要了解用户，靠应用+了解用户的需求才能产生money</p><p>核心竞争力，自己的优势到底是什么<br>应用者 利用信息差快速上位<br>了解客户，而不仅仅是了解技术；少去炫技，多去用感情+满足需求来挣钱<br>技术是应用者 利用信息差快速上位</p><p>应用者中赚到钱的一定是最理解用户的人，手里有客户 ，ai只是一个工具，所面对的用户仍然没有变过<br>铁打的用户，流水的技术</p><h3 id="孩子教育-是否要学ai"><a href="#孩子教育-是否要学ai" class="headerlink" title="孩子教育 是否要学ai"></a>孩子教育 是否要学ai</h3><p>为什么要学扑克？ 象棋 围棋  人还要跑步？而不是打车呢</p><p>会让使用和学习的门槛回归0</p><p>提升审美和能力</p><p>从音乐 ，商业 到编程 都会一点的东西</p><p>培养孩子的内心力量，他们真的需求是什么</p><p>孩子的创造力和想象力很珍贵，AI影响不了</p><p>训练孩子的思维</p><p>情绪力 和创造力 ，人天然是一个大模型，</p><p>人要跟生活 跟很多元认知来产生很多碰撞</p><p>锻炼思考能力、逻辑能力、创造力</p><p>==遇到人生巨大困惑，需要使用创造力来进行利用解决，知识自己一只忽略了他的价值==</p><h1 id="中国基层的基础框架"><a href="#中国基层的基础框架" class="headerlink" title="中国基层的基础框架"></a>中国基层的基础框架</h1><blockquote><p>政治经济学 组织经济学</p></blockquote><p>北上广深苏浙杭 VS 乡村 （90%人口）</p><p><img src="..\assets\image-20240222101953924.png" alt="image-20240222101953924"></p><p>知之深才能爱之切</p><p><img src="..\assets\image-20240222103121120.png" alt="image-20240222103121120"></p><blockquote><p>理解基层才能理解中国</p></blockquote><p><img src="..\assets\image-20240222103214019.png" alt="image-20240222103214019"></p><p>循序渐进，逐渐深入的关系</p><blockquote><p>主要研究政企关系，营商环境和制度经济学</p><p>三农问题和基层治理 并不强擅</p></blockquote><h3 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h3><p><img src="..\assets\image-20240222103441214.png" alt="image-20240222103441214"></p><blockquote><p>底层框架+冷冰冰的手术刀</p></blockquote><ol><li><p>构建思维框架，增强因果推断；</p></li><li><p>完成思维的培养和锻炼，在沟通中成长，在交流中进步</p></li></ol><p>==如切如磋如琢如磨==</p><h1 id="第一讲——理解中国的治理架构"><a href="#第一讲——理解中国的治理架构" class="headerlink" title="第一讲——理解中国的治理架构"></a>第一讲——理解中国的治理架构</h1><blockquote><p>治理架构也就是根本制度</p><p>掌握</p></blockquote><p><img src="..\assets\image-20240222103729013.png" alt="image-20240222103729013"></p><blockquote><p>元规则 支撑中国文明运行几千年的基本制度</p></blockquote><p>为什么要从制度或者底层治理框架上开始？</p><blockquote><p>只有先从制度角度理解制度背景，才能从宏观角度理解中国的基层治理，才能高屋建瓴的看透中国基层治理的现状、问题 和对策</p></blockquote><p>从制度角度看问题才能看的更透，更深 更远</p><p><img src="..\assets\image-20240222104937019.png" alt="image-20240222104937019"></p><p>不是就事论事 形成头痛医头 脚痛医脚的毛病</p><p>主要研究三个问题：</p><ol><li>为什么要演研究中国的治理架构？</li><li>什么是中国治理的基本架构</li><li>如何在中央—地方关系下，理解基层与上层的互动<ol><li>中央和地方之间到底是兄弟关系还是父子关系呢？</li></ol></li></ol><p><strong>主要目的是形成理解基层治理的底层框架和系统思维</strong></p><p><img src="..\assets\image-20240222105109455.png" alt="image-20240222105109455"></p><blockquote><p>万变不离其宗，掌握底层框架才算是掌握了知识的金钥匙，也就是武林秘籍中的 独孤九剑 </p><p>条块结合，以块为主的中央集权体制</p></blockquote><p><img src="..\assets\image-20240222105215896.png" alt="image-20240222105215896"></p><blockquote><p>纪委为什么成为强势单位？ 县委书记为什么不好当?</p><p>怎么就形成了上边千条线，下边一根针的基层治理困境</p><p> 大A  制度经济学</p></blockquote><p><img src="..\assets\image-20240222110039821.png" alt="image-20240222110039821"></p><p><img src="..\assets\image-20240222110129262.png" alt="image-20240222110129262"></p><blockquote><p>制度经济学 包括 政治制度 经济制度 法律 文化 以及政府政策</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>实时，需要有<strong>较快</strong>的推理速度（高优先级）</li><li>便捷，需要该模型便于部署，特别是部署到Unity平台</li><li>精确，至少要让用户觉得数字人的口型可以和实际口型对应</li><li>风格化，无需针对某个特定的音色/角色微调模型，即<strong>one model for all user</strong></li><li>口型、avatar面部表情、动作同步；其中口型、表情都是用blendershape驱动，动作暂时是循环播放固定动作</li></ol><h2 id="实验计划"><a href="#实验计划" class="headerlink" title="实验计划"></a>实验计划</h2><p>优先参考现有的代码：</p><p><a href="https://github.com/yunik1004/SAiD.git">https://github.com/yunik1004/SAiD.git</a></p><p><a href="https://github.com/huailiang/LipSync">https://github.com/huailiang/LipSync</a></p><p><a href="https://github.com/zhongshaoyy/Audio2Face">https://github.com/zhongshaoyy/Audio2Face</a></p><p><a href="https://github.com/leventt/surat.git">https://github.com/leventt/surat.git</a></p><p><a href="https://github.com/Rudrabha/Wav2Lip">https://github.com/Rudrabha/Wav2Lip</a></p><p><a href="https://github.com/Rtyper/LipSync-Pro">https://github.com/Rtyper/LipSync-Pro</a></p><p><a href="https://github.com/guanjz20/StyleSync">https://github.com/guanjz20/StyleSync</a></p><h2 id="后续需要补的知识"><a href="#后续需要补的知识" class="headerlink" title="后续需要补的知识"></a>后续需要补的知识</h2><p>@李润一</p><p>Unity开发、部署相关知识Sentis的使用：<a href="https://www.notion.so/AI-model-To-Unity-b232f2c2acaa49d59e0c0fa251c329c6?pvs=4">https://www.notion.so/AI-model-To-Unity-b232f2c2acaa49d59e0c0fa251c329c6?pvs=4</a></p><h2 id="Audio2Face-expression更新"><a href="#Audio2Face-expression更新" class="headerlink" title="Audio2Face+expression更新"></a>Audio2Face+expression更新</h2><p>可以参考下列工作：</p><p><a href="https://github.com/FACEGOOD/FACEGOOD-Audio2Face/">https://github.com/FACEGOOD/FACEGOOD-Audio2Face/</a></p><p>更新：FaceGood无法在linux平台上测试，只能在windows上运行</p><p>（其余工作未使用blendershape的输出，可在下<a href="https://github.com/FACEGOOD/FACEGOOD-Audio2Face/列链接中查看：）">https://github.com/FACEGOOD/FACEGOOD-Audio2Face/列链接中查看：）</a></p><p><a href="https://xie.infoq.cn/article/2f414deaa57ca29783d6f873f">语音驱动嘴型与面部动画生成的现状和趋势<em>算法</em>行者AI_InfoQ写作社区</a></p><p><a href="https://www.gameres.com/895985.html">语音生成口型与表情技术的演进与未来 - GameRes游资网</a></p><p><a href="https://github.com/nowickam/facial-animation/tree/production">nowickam/facial-animation: Audio-driven facial animation generator with BiLSTM used for transcribing the speech and web interface displaying the avatar and the animation (github.com)</a></p><p><a href="https://www.jianshu.com/p/fbc5743152f0">[Paper Reading] Audio-Driven Facial Animation by Joint End-to-End Learning of Pose and Emotion - 简书 (jianshu.com)</a>（这篇工作就是nvidia开发的omnivetrse audio2face的基础）</p><h1 id="个人选择"><a href="#个人选择" class="headerlink" title="个人选择"></a>个人选择</h1><p>相对竞争优势 &amp;&amp; 个人的兴趣爱好</p><blockquote><p>根据对应的时代特征，来进行选择</p><p>有一个选择4象限</p></blockquote><p><img src="..\assets\image-20240301094224506.png" alt="image-20240301094224506"></p><p><strong>政府部门进行招商引资</strong></p><p>PPT 造车  <a href="https://zhuanlan.zhihu.com/p/642907927">PPT造车鼻祖倒下？烧光174亿，九年也没憋出一辆车 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bing.com/ck/a?!&amp;&amp;p=f0f86f68578cf44fJmltdHM9MTcwOTE2NDgwMCZpZ3VpZD0xZjZkZWZkNy0zZTg5LTYyNmQtM2JiYS1mYmU2M2Y4MTYzNWYmaW5zaWQ9NTE4MQ&amp;ptn=3&amp;ver=2&amp;hsh=3&amp;fclid=1f6defd7-3e89-626d-3bba-fbe63f81635f&amp;psq=PPT%e9%80%a0%e8%bd%a6&amp;u=a1aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NDI5MDc5Mjc&amp;ntb=1">https://www.bing.com/ck/a?!&amp;&amp;p=f0f86f68578cf44fJmltdHM9MTcwOTE2NDgwMCZpZ3VpZD0xZjZkZWZkNy0zZTg5LTYyNmQtM2JiYS1mYmU2M2Y4MTYzNWYmaW5zaWQ9NTE4MQ&amp;ptn=3&amp;ver=2&amp;hsh=3&amp;fclid=1f6defd7-3e89-626d-3bba-fbe63f81635f&amp;psq=PPT%e9%80%a0%e8%bd%a6&amp;u=a1aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NDI5MDc5Mjc&amp;ntb=1</a></p><h2 id="工具ChatGPT"><a href="#工具ChatGPT" class="headerlink" title="工具ChatGPT"></a>工具ChatGPT</h2><p>ChatGPT4的归档功能</p><p><a href="https://www.landiannews.com/archives/101487.html">OPENAI宣布ChatGPT现在可以归档会话喽 不删除会话的同时保持简洁 - 蓝点网 (landiannews.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;社科人文认知突破&quot;&gt;&lt;a href=&quot;#社科人文认知突破&quot; class=&quot;headerlink&quot; title=&quot;社科人文认知突破&quot;&gt;&lt;/a&gt;社科人文认知突破&lt;/h2&gt;&lt;h2 id=&quot;社会科学入门&quot;&gt;&lt;a href=&quot;#社会科学入门&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.fomal.cc/posts/4a17b156.html"/>
    <id>https://www.fomal.cc/posts/4a17b156.html</id>
    <published>2024-09-06T13:11:52.768Z</published>
    <updated>2024-09-06T05:01:06.893Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>思考的原点1.1</title>
    <link href="https://www.fomal.cc/posts/6c9e281a.html"/>
    <id>https://www.fomal.cc/posts/6c9e281a.html</id>
    <published>2024-03-19T11:59:12.000Z</published>
    <updated>2024-09-06T01:04:24.695Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/image-20240319200003990.png" alt="image-20240319200003990"></p><p><img src="../assets/image-20240319200138262.png" alt="image-20240319200138262"></p><p>具体影响:</p><p><img src="../assets/image-20240319200442568.png" alt="image-20240319200442568"></p><blockquote><p>民国时期的张爱玲 胡适  不超过10% </p><p>国民党的留学博士  20%  高智商的人 但是不一定明白</p></blockquote><p><img src="../assets/image-20240319200959489.png" alt="image-20240319200959489"></p><p>思考框架背后 </p><p><img src="../assets/image-20240319222056735.png" alt="image-20240319222056735"></p><blockquote><p>哈耶克 说英美 两种经验主义？？</p><p><strong>14-15分钟左右 没听懂</strong></p></blockquote><p><img src="../assets/image-20240319223401990.png" alt="image-20240319223401990"></p><p><img src="../assets/image-20240319223752011.png" alt="image-20240319223752011"></p><p>  人类积累了上万年的常识智慧 我们需要借鉴吗？</p><p>哈耶克认为 英国自由的保守主义 包括解决一战 和法国大革命 是以经验主义演变来的，马老师定义为经验的共识？</p><p><img src="../assets/image-20240319223950464.png" alt="image-20240319223950464"></p><blockquote><p>不言而喻 的东西 + 假设 形成自然科学</p></blockquote><p>社会科学 基于很多公理 在进行理性推理+假设</p><blockquote><p>先聊基本常识有哪些【多年积淀】</p><p>在聊到良知【希特勒 ，斯大林的大清洗 法国资产阶级大革命    】</p></blockquote><p><img src="../assets/image-20240319225127785.png" alt="image-20240319225127785"></p><blockquote><p>人是目的还是工具？</p><p>与人相处的时候什么是平等和公平 </p><p>个人权利和公众权力</p><p>平等和自由的时候哪个更重要 本质是左派和右派</p><p>权力和道德的关系 良知和正义的关系</p></blockquote><p>读写是最好的自我投资</p><p>经济持续放缓（5年之内）悲观的2%的商铺不会盈利，疫情导致大家消费欲望变低</p><blockquote><p>最难的反而是28-40 的中层危机，持续危机</p></blockquote><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240409221345478.png" alt="image-20240409221345478"></p><blockquote><p>读书是</p></blockquote><p>35岁 经验为导向的职业，努力不在撬动发展，需要持续做对选择来撬动个人发展</p><blockquote><p>生存问题变成发展问题</p></blockquote><p>π型人才，</p><blockquote><p>所有的变化和需求都需要持续的阅读，来保证个人的读写能力</p></blockquote><p>每个人都最容易触及的，都可以获得的，收益最大的都是读写能力，</p><p>读写只是自己的一种阅读输入输出的方式</p><blockquote><p>读写 在信息时代把数据吃进去再用更好的方式把数据吐出来，就永远都不会饿死</p></blockquote><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240409221646881.png" alt="image-20240409221646881"></p><blockquote><p>消费型的阅读或者时间投入</p><p>仅仅是方便体验和知道了一些知道的</p></blockquote><p>投资型的阅读和输入</p><blockquote><p>咖啡豆的示例</p></blockquote><p><strong>自己的投资型和消费型的比例是怎样的呢？是否需要控制呢（包括视频和读书方面，甚至是任何各种输入自己眼中、头脑中的数据和信息）</strong></p><p>10分的话，消费占多少？投资占多少？  </p><p><strong>思想变得浅薄</strong></p><p><img src="D:\2023.6.2hexo\test\source\assets\image-20240409224042781.png" alt="image-20240409224042781"></p><p>底层思维的书  怎样应用呢？【】</p><blockquote><p>复用率 ？ 有短期收益或者长期收益？？？</p><p>遇到任何书的时候，都要去重新去思考，对症下药去分析</p></blockquote><p><img src="D:\2023.6.2hexo\test\source\assets\image-20240409224331895.png" alt="image-20240409224331895"></p><p>当你把自己价值能完整的输出的时候，就是一件非常有价值的东西</p><ol><li>你比别人想得深</li><li>你能够宣传，有品牌</li></ol><p>拍卖效应 + 手电思维？灯塔效应</p><blockquote><p>持续放光</p><p>德国人的灵魂？？丁元英  灵魂<br>开启一个一个的小镇</p></blockquote><p>穷人/普通人最好的投资、最好的职业规划、最好的学习方法 、是最便宜最舒适让内心能够更宁静的一种旅游小镇的方式</p><p><img src="..\assets\image-20240409224953036.png" alt="image-20240409224953036"></p><h2 id="写卡感触"><a href="#写卡感触" class="headerlink" title="写卡感触"></a>写卡感触</h2><p>我最有感悟的古典⽼师的⼀句话是：古典老师关于阅读读书时候的考量因素（如何选书或者评价书是否适合自己去阅读）+对于书复用率的不同分类（经典的底层逻辑的书  实现某种功能的书  畅销书 ）+古典老师如何论证阅读的效益的递进方式（先背景介绍-&gt;环境要求-&gt;个人发展需要(投资数据支持、职业规划)-&gt;心灵上读书是必要条件）+读写是一个持续的东西，很多公众号断更/没坚持到最后，只有持续的读+写，形成闭环才能够好的坚持走下去【读写是最好的个人投资，而不仅仅是只读/只写（写一篇没用，读一篇也没用）】</p><p>阅读不是要做的唯一一件事情，写作一样，并不是孤立的，而应该两者形成整体的一个系统，作为输入和输出，同时去构建他，维护他们，并作为长期主义，持续的做下去。</p><p>我过去踩的坑是：没坚持下来阅读+写卡（也有各种原因，也一直没有开始去做）;阅读读书没有将该原则应用，还是老套路选书；自己是第二次看这个视频，之前也看过这个视频好几遍，甚至都写过关于这个视频的卡（第一次参与共读会+选书开始写卡的时候，都是看的这个视频），但自己只是知道并没有做到，这两者中间真的差了一个巨大的鸿沟。</p><p>我以后可以更好的⽅式是：</p><ol><li><p>尽量减少完美主义的影响，有时候一想起要把事情做得很好会碰到一些苦难，所以就会害怕或者懒得去开启行动；尽可能快的开始，言出努力去行，用行动来进行反馈，尽量只要收获一点点东西就enough。</p></li><li><p>昨天听了师兄师姐的会议分享，感触颇多，要多跟大家去同频共振，减少自己对于现实世界中困难的想象，联机学习，一起进步</p></li></ol><h1 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h1><ol><li>整理时间安排</li></ol><h2 id="读书读不懂？记不住？用不上？"><a href="#读书读不懂？记不住？用不上？" class="headerlink" title="读书读不懂？记不住？用不上？"></a>读书读不懂？记不住？用不上？</h2><p>读不懂</p><ol><li>读深入 读透作为自己的读书指标</li><li>读书 缺少体验，<ol><li>听话vs阅读理解？ 人的大脑临时组件是不能对阅读理解来实现天生组件完成该功能的，所以需要将听觉、视觉、大脑打猎的部分临时组合来实现阅读理解</li><li>缺少人生经历和体验（任何的抽象概念都无法不通过具体的体验去理解）——没有见过圆的人永远想象不到圆有多完整（没见过趋近于直线的人无法想象到无限延长的直线）</li></ol></li></ol><p>记不住</p><p>存难取易（偷钱挨打这件事 一辈子记住（一辈子记住自己不要丢三落四））</p><p>大脑 easy come easy go 5</p><p>一天听4个小时 什么都记不住</p><blockquote><p>给别人讲一遍</p></blockquote><p>最好的记录员？？（跟他们做朋友）</p><p>利于记忆，但不利于提取</p><p>缺少必要的知识管理工具</p><blockquote><p>缺少实践【】</p><p>缺少系统【老板上课】</p></blockquote><h3 id="个人脑子里记录的东西"><a href="#个人脑子里记录的东西" class="headerlink" title="个人脑子里记录的东西"></a>个人脑子里记录的东西</h3><blockquote><p>思维导图—— 笔记整理软件——写卡片</p><p>白天听课，晚上写  </p><p>？？难度</p></blockquote><p>整体的系统框架？？</p><p>读写镜像，关于知识树的构建和拆分是利用读写来完成的</p><p>读的话 就是输入，将个人读的信息从一维提取主题后形成二维大纲，然后放入到大脑的知识网中</p><p>写的话，是输出，将大脑中的网状知识结构，先提取出一个主题形成大纲，然后大纲每一个主题往外写，形成一维输出</p><blockquote><p>既是一讲写作课，也是一讲阅读课</p></blockquote><p> 写卡营第二讲体悟分享</p><p>【内容来源】写卡营第二讲课程古典老师分享（下）</p><p>【本卡主题】关于建立体系以及写卡的四个重要知识点</p><p>【原文摘录】<br>SS卡的实现体系是从①选书开始 ② 关注理解体验 ③深刻记忆内容④付出行动实践（各种训练营 打卡营 读书营） ⑤坚持30天不断积累卡片 ⑥形成卡片体系 ⑦卡片成文营训练 ⑧文章/作品 大纲⑨创造价值，不断发展<br>SS卡的四个重要知识点：①存难取易②最小单元（卡片） ③乐高式写作（搭建） ④读写镜像（读写同构）</p><p>【概念转述】<br>————————————————————<br>选书——选的是底层的，比较基础的且复用率比较高的书<br>理解——转述出来之后，用自己的话说一遍辅助加深理解<br>体验——记录那一瞬间的感触/体验/思考，并不断积累汇总<br>行动——行动与体验并行，才能帮助更好的融会贯通<br>其他的点是在上边的基础上不断的践行+积累，慢慢创造价值</p><p>————————————————————<br>存难取易——既能帮助深入理解，方便快速提取体验卡，也能实现系统搭建<br>最小单元——借用卡片的方式，每天复习，学习+联系<br>乐高式写作——反对模板化的方式，以阅读输入为起点，存下每块乐高，最终搭建出体系<br>读写镜像——读写不分离，读书—写作应该是同步进行，并且是一个相互可逆的过程<br>————————————————————<br>【个人体验/思考】</p><ol><li>形成整个读写体系应该是战略性的设定，然后再按照整个流程详细的展开，按照古典老师讲述的过程，不断积累，一点点去主动阅读并写下体验，深刻体会后并用行动去加深理解，想起了之前阅读《七个习惯》好像是一样的思路</li></ol><p>2.在自己一个月从158变成142的过程中，深刻体会到自己实践——体验——继续付出努力增强信心的整个闭环过程，现在想来应该也是得益于系统的搭建</p><p>3.读写同构这一点，让自己印象深刻；在读书的时候，是从1维度获取零散的知识，然后在笔记中进行罗列整理，形成2维度大纲，最后在脑中形成3维度网状知识体系；<br>书写的时候，是利用脑中的3维度网络知识图，将信息提取后，在纸面上形成2维度大纲，最后按照每个要点详细展开细节也即1维度的内容加工。</p><p>【行动指南】<br>写卡先，首先认识到，到知道，再到做到，感谢老师给了一个可行性比较强的抓手——写卡</p><p><a href="https://doc.weixin.qq.com/doc/w3_AdgAaQawAMceNWSNgcxRSWAS0TYZ0?scode=AFgAiwfiAGI7oggms0AdgAaQawAMc">软件打包 (qq.com)</a></p><p><a href="https://www.zhihu.com/column/c_1245860717607686144">Nuitka-Python打包exe - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/erdengk">erdengk (尔等同学) · GitHub</a></p><p><a href="https://book.douban.com/subject/35050614/">我的二本学生 (豆瓣) (douban.com)</a></p><p><a href="https://avuucupcq6.feishu.cn/docx/EWYYdkYIeoL4XIxw97xcLqQnnRc">一册通.《锻炼》共读营 - Feishu Docs</a></p><p>请结合下边给出的5个Skeleton-based Action Recognition 介绍的内容，生成一个新的关于Skeleton-based Action Recognition的详细介绍，内容尽量新颖独特一点，用词合理且通顺，大概在500单词左右<br>1 Skeleton-based Action Recognition<br>With the huge advances of deep learning, recurrent neural net-<br>work (RNN)-based, convolutional neural network (CNN)-based,<br>graph convolutional network (GCN)-based, and transformer-based<br>methods are studied for skeleton-based action recognition. RNNs<br>have been widely used to model temporal dependencies and cap-<br>ture the motion features for skeleton-based action recognition. The<br>work in [9] uses RNN to tackle the skeleton as sequence data. Sub-<br>sequently, Song et al. [37, 38] proposed to utilize the attention<br>mechanism and multi-modal information to enhance the feature<br>representations. Some other works [15, 24] transform each skeleton<br>sequence into image-like representations and apply the CNN model<br>to extract spatial-temporal information. Recently, GCN-based meth-<br>ods have attracted more attention due to the natural topology struc-<br>ture of the human body. Many works [6, 35, 47] apply GCN to<br>the spatial and temporal dimension [47] and achieves remarkable<br>results in the supervised skeleton-based action recognition. Mean-<br>while, transformer models [29, 36] also show promising results,<br>owing to long-range temporal dependency learning by attention.</p><p>2 Skeleton-based action recognition<br>Generally, there are two ways to obtain skeleton data from<br>videos. Firstly, the position information of human joints is ob-<br>tained from RGB video frames by pose estimation methods, such<br>as Openpose [26]. Secondly, the 3D skeleton data of the human<br>body can be obtained directly through the depth sensor, e.g., Mi-<br>crosoft Kinect v.2. In this paper, the datasets we use includes two<br>forms, RGB videos and skeleton sequences. These two forms of<br>data are shown in Fig. 1.<br>Most early research on skeleton-based action recognition usu-<br>ally used handcrafted features to represent the human body.<br>Hussein et al. [10] used the covariance matrix for joint posi-<br>tions over time. In [11], rotations and translations were used to<br>model 3D geometric relationships between body parts. However,<br>these methods were complex in design processes and ignored the<br>correlations between specific human body parts.<br>With the further development of deep learning, CNN-based<br>and RNN-based methods were proposed to process the grid<br>data reconstructed from human skeleton data. CNN-based meth-<br>ods [27–29] convert the skeleton data into pseudo-images, then<br>attempt to learn action features. In [30], a skeleton-based trans-<br>former module was designed for action classification and recog-<br>nition. Kim et al. [31] proposed a 3D human action recognition<br>model named Temporal Convolutional Neural Networks. In [32],<br>an enhanced skeleton visualization method was presented to<br>deal with view variations and noisy data. Liu et al. [33] first<br>applied 3D convolution for the skeleton-based recognition task to<br>simultaneously capture motion correlations of spatial–temporal<br>dimensions. Huynh et al. [34] proposed a new encoding method,<br>Pose-Transition Feature to Image (PoT2I), which transforms high-<br>level features of skeleton data into color pixels. In recent works,<br>the skeleton-based data was formulated as sequences of grid-<br>shaped structures and then modeled with RNN-based methods [8,<br>35,36]. Shahroudy et al. [37] proposed an RNN-based structure<br>to model the long-term temporal correlation of motion features.<br>In [38], RNN was used to analyze the hidden sources of motion<br>relationships in both spatial and temporal dimensions. In [39],<br>an end-to-end spatial–temporal attention model was built with<br>Long Short-Term Memory (LSTM) to focus on discriminative<br>joints. In [40], a novel contrastive action learning paradigm called<br>AS-CAL with a momentum LSTM module was proposed to unsu-<br>pervised action recognition. However, the skeleton-based data are<br>embedded not in the form of vector sequences or 2D grids but<br>in the graph structure, so both RNNs and CNNs based methods<br>cannot represent the structure of skeleton-based data well.<br>GCN-based methods utilize graph convolution modules to ex-<br>tract motion dependencies from the graph structure of natural<br>human skeleton data, which has been demonstrated to be the<br>most expressive. Yan et al. [4] innovatively proposed the first<br>model with GCN, namely ST-GCN, to capture the balance between<br>spatial and temporal dependencies. In this model, the skeleton<br>is expanded into a graph structure, and the spatial–temporal<br>patterns are automatically extracted from skeleton-based graph<br>data. Subsequently, many studies [41–43] were proposed based<br>on ST-GCN. In [35], 2s-AGCN was presented with adaptive ad-<br>jacency matrices to capture the motion information from high-<br>order skeleton data. Liu et al. [44] proposed MS-G3D to conduct<br>multi-scale long-range modeling of spatial–temporal graphs. Sim-<br>ilarly, AS-GCN [21] inferred A-links from input data to capture<br>multi-scale actional relationships. Zhang et al. [45] investigated<br>high-level semantics information from skeleton-based data and<br>designed two modules to exploit the high-order correlation of<br>skeleton data.</p><p>3 Skeleton-based models: To find a more effective rep-<br>resentation of the dynamics of human actions, Johansson [24]<br>utilizes 3D skeleton sequences for action recognition, making<br>an obvious decrease of computational cost as well as a good<br>performance boost. Recently, with the rapid development of<br>deep learning techniques, skeleton-based action recognition<br>methods have attracted increasing attentions. Researchers have<br>proposed various models to improve the performance of action<br>recognition, which can be divided into three major categories.<br>The first category builds the models with convolutional net-<br>works. For example, Li et al. [16] propose a CNN-based<br>co-occurrence feature learning framework, which gradually<br>aggregates various levels of contextual information. Kim et<br>al. [15] build a temporal convolutional network to explicitly<br>learn readily interpretable spatio-temporal representations for<br>3D human action recognition.<br>Besides, for the second category, researchers concatenate all<br>joints in one frame into a single vector, then use sequential<br>models such as long short-term memory (LSTM) to explore<br>the temporal dynamics. Du et al. [25] design a hierarchical<br>bidirectional RNN to capture rich dependencies between dif-<br>ferent human body parts. The study in [9] employs a view<br>adaptive LSTM, which enables the network itself adaptive to<br>the most suitable observation viewpoints. Additionally, Song<br>et al. [26] firstly introduce attention modules into skeleton-<br>based action recognition.<br>Both CNN-based and RNN-based methods are still limited<br>to extract the spatial structure information among skeleton<br>joints, where the joints of different body parts are connected<br>as a skeleton graph. Instead, in the third category, graph-<br>based methods can be naturally utilized to deal with the<br>skeleton graph, which successfully captures the most infor-<br>mative features for various actions. Si et al. [13] use GNN to<br>model the relationships among five body parts. Yan et al. [10]<br>initially introduce GCN into skeleton-based action recognition,<br>and produce a baseline named ST-GCN for future research.<br>Based on the ST-GCN, many studies achieve continuous<br>improvements on skeleton-based action recognition [27], [28],<br>[29].<br>4Skeleton-based action recognition<br>The progress of deep learning [30–32] and the advancement of<br>human pose estimation algorithms have facilitated human action<br>research. Basically, skeleton-based action recognition deals with<br>temporal series, where the dynamics of human body poses over<br>time characterize human actions. Early methods generally used a<br>manual feature approach to capture human action [33–35] . How-<br>ever, this relies mainly on 3D rotations and translations between<br>joint points, so feature design is more complex and has average<br>performance.<br>Recently, deep learning methods have achieved favorable out-<br>comes in skeleton-based action recognition, which can be basi-<br>cally classified according to the network architecture: Convolu-<br>tional Neural Networks (CNNs), Recurrent Neural Networks (RNNs),<br>and Graph Convolutional Networks (GCNs). CNN-based methods<br>convert human skeleton sequences into pseudo-images, which are<br>trained and then classified. Structurally, CNNs are constructed by<br>stacking convolutional layers, pooling layers, and activation func-<br>tions, etc. The CNN achieves network optimization by adjusting the<br>number of convolutional and pooling layers, the size of convolu-<br>tional kernel, and the step size of convolution. Li et al. [36] pro-<br>posed an end-to-end convolutional co-occurrence feature learn-<br>ing framework. The co-occurrence features are learned using a hi-<br>erarchical method with different levels of contextual information<br>gradually aggregated. Kim and Reiter [37] proposed a new model<br>called Temporal Convolutional Neural Network (TCN) for 3D hu-<br>man action recognition, it used one-dimensional residual CNNs and<br>based on directly connected joint coordinates to identify skeleton<br>sequences. Liu et al. [38] proposed an enhanced skeleton visual-<br>ization method, which visualizes the skeleton as a series of color<br>images and then implicitly encodes the spatio-temporal informa-<br>tion of the skeleton joints. Since CNN can only process regular grid<br>data in non-Euclidean space, it is not as good as other networks in<br>skeleton-based action recognition.<br>RNN-based approaches typically model skeleton sequences as<br>a series of coordinate vectors along spatial and temporal dimen-<br>sions, where the vectors represent the body’s joint points. Liu et al.<br>[39] proposed a tree-structure-based traversal method that uses<br>an RNN-based approach to model the spatio-temporal domain and<br>introduces a new gating mechanism in LSTM to learn the relia-<br>bility of sequential input data. Liu et al. [40] designed a Global<br>Context-Aware Attention L STM (GCA-L STM), which is able to se-<br>lectively focus on information joints in action sequences with the<br>assistance of global contextual information. Zhang et al. [41] de-<br>signed an attentional mechanism, it embeds a recurrent attentional<br>network that can explore the spatiotemporal relationships between<br>different local regions to focus on important regions. Zhu et al.<br>[42] proposed an end-to-end fully connected deep LSTM network<br>that takes the skeleton as input at each time point and introduces<br>a new regularization method to learn the co-occurrence features of<br>skeleton joints.<br>However, both CNNs and RNNs have difficulty in capturing the<br>natural graph structure of skeleton topological features. To better<br>capture human action features [16,43] , recent work has utilized<br>GCNs [44,45] for spatial and temporal modeling of actions</p><p>5 Skeleton-Based Action Recognition<br>Skeleton-based action recognition is a fundamental yet<br>challenging field in computer vision research. Previous<br>skeleton-based motion recognition methods are usually re-<br>alized with the geometric relationship of skeleton joints [7,<br>36, 37]. The latest methods pay more attention to deep net-<br>works. Du et al. [6] applied a hierarchical RNN to process<br>body keypoints. Attention-based methods are proposed to<br>automatically select important skeleton joints [28–30, 47]<br>and video frames [29, 30] to learn more adaptively about<br>the simultaneous appearance of skeleton joints. However,<br>recurrent neural networks often suffer from gradient van-<br>ishing [11], which may cause optimization problems. Re-<br>cently, graph convolution networks attract more attention<br>for skeleton-based action recognition. To extract both the<br>spatial and temporal structural features from skeleton data,<br>Yan et al. [40] proposed spatial-temporal graph convolution<br>networks. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../assets/image-20240319200003990.png&quot; alt=&quot;image-20240319200003990&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../assets/image-20240319200138262.png&quot; a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>今日一心</title>
    <link href="https://www.fomal.cc/posts/3ccff96b.html"/>
    <id>https://www.fomal.cc/posts/3ccff96b.html</id>
    <published>2024-03-13T14:09:23.000Z</published>
    <updated>2024-09-06T01:04:24.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聂辉华番外课程1该不该走选调生"><a href="#聂辉华番外课程1该不该走选调生" class="headerlink" title="聂辉华番外课程1该不该走选调生"></a>聂辉华番外课程1该不该走选调生</h1><h2 id="细节展开1"><a href="#细节展开1" class="headerlink" title="细节展开1."></a>细节展开1.</h2><p><img src="../assets/image-20240315191357916.png" alt="image-20240315191357916"></p><p><img src="../assets/image-20240315191542319.png" alt="image-20240315191542319"></p><p><img src="../assets/image-20240315191701845.png" alt="image-20240315191701845"></p><p><img src="../assets/image-20240315191804417.png" alt="image-20240315191804417"></p><p><img src="../assets/image-20240315191829363.png" alt="image-20240315191829363"></p><p>区别</p><p><img src="../assets/image-20240315191931043.png" alt="image-20240315191931043"></p><p><img src="../assets/image-20240315192049444.png" alt="image-20240315192049444"></p><p><img src="../assets/image-20240315192057670.png" alt="image-20240315192057670"></p><p>选调生 vs 统考生</p><p><img src="../assets/image-20240315192337006.png" alt="image-20240315192337006"></p><p><img src="../assets/image-20240315192406696.png" alt="image-20240315192406696"></p><h2 id="选调生、国考、省考"><a href="#选调生、国考、省考" class="headerlink" title="选调生、国考、省考"></a>选调生、国考、省考</h2><blockquote><p>资料汇总</p><p><a href="http://www.sdgwy.org/html/kszc/202403/2_81743.html">2025年山东公务员考试报名信息「提前收藏」 - 山东公务员考试最新消息 (sdgwy.org)</a></p><p><a href="http://www.sdgwy.org/">山东公务员考试最新消息 -2024年山东公务员考试网上报名时间、考试大纲、历年真题 (sdgwy.org)</a></p><p><a href="http://www.sdgwy.org/html/zkgg/xds/index.html">招考公告/选调生 - 山东公务员考试最新消息 (sdgwy.org)</a></p><p><img src="../assets/image-20240324125043891.png" alt="image-20240324125043891"></p><p>时政学习</p><p><a href="https://www.chinagwy.org/html/ggjczs/mszt/202401/52_615293.html">公务员考试备考必看：2024年时事政治合集「持续更新」 - 国家公务员考试最新消息 (chinagwy.org)</a></p></blockquote><h3 id="选调生"><a href="#选调生" class="headerlink" title="选调生"></a>选调生</h3><p>23年毕业生有一个青岛的选调  但是24年毕业生没有，只面向了东南大学</p><p><strong>25年未知</strong></p><p><a href="http://www.sdgwy.org/html/gdzk/qd/202211/67_73792.html">2023年青岛市“青选计划”选调公告（山东师范大学） - 山东公务员考试最新消息 (sdgwy.org)</a></p><p>都是只能报考一个单位或者岗位。</p><blockquote><p>需要选调生的历年数据  </p><p><a href="https://zhuanlan.zhihu.com/p/645424990">山东定向&amp;常规选调最全报录比数据（2023年最新） - 知乎 (zhihu.com)</a></p><p> 详细政策和选择分析</p><p><a href="https://zhuanlan.zhihu.com/p/601525199">2023山东定向选调第一批——山东专额选调全面解读（附岗位指导） - 知乎 (zhihu.com)</a></p><p>专额选调 是指的第一批选调</p><p><a href="https://ah.huatu.com/zt/sdxdszwb/">2024年山东招录选调生考试职位表下载_岗位查询-山东公务员考试网 (huatu.com)</a> x</p><p>选调岗位  【下载下来的是22年的】</p><p>在济南或者说山东 是普通选调的县直 或者是乡镇</p></blockquote><h3 id="证监会-VS-金管局"><a href="#证监会-VS-金管局" class="headerlink" title="证监会 VS 金管局"></a>证监会 VS 金管局</h3><p><a href="https://mp.weixin.qq.com/s/_XW4D0jRiy-g0Q6ldQWGVA">获取国考证监会历年真题资料方式 (qq.com)</a></p><h1 id="载脑体-爱情第一讲"><a href="#载脑体-爱情第一讲" class="headerlink" title="载脑体 爱情第一讲"></a>载脑体 爱情第一讲</h1><blockquote><p>系统性，本源性 去剖析男女关系的本质</p><p>从可实践的角度分析如何遇到一个对的人</p></blockquote><h2 id="摆正观念"><a href="#摆正观念" class="headerlink" title="摆正观念"></a>摆正观念</h2><p>对于大多数人而言，人生中最重要的决定是跟什么样的人相伴一生</p><p><img src="../assets/image-20240320155836104.png" alt="image-20240320155836104"></p><p>其次才是选择行业，再差的行业都会给与自己一个安身立命之所，职业的周期性会贯穿个人的前半生，但在未来的AI时代，自己可能无法保证未来行业的连续性，且很多时候决定行业的趋势的往往是风口和周期率，而非自身所能左右</p><blockquote><p>选对一个好的伴侣不仅仅影响自己的金钱、时间，也会影响自己人生漫漫长路的质量，也是自己为数不多的能够抵抗世界周期率和波动的抉择之一</p></blockquote><p>好男儿不在乎儿女情长，但对于大多数人，尤其是男生，除了谋生赚钱的知识以及专业技能基础课之外，优先掌握如下知识：</p><p><img src="../assets/image-20240320160615680.png" alt="image-20240320160615680"></p><blockquote><p>每一条都事关个人一生真正的幸福</p></blockquote><p>其他事情可以感兴趣，但不能对于以上事情无知的情况下，去琢磨其他事情</p><h3 id="摆正对于婚姻的理解"><a href="#摆正对于婚姻的理解" class="headerlink" title="摆正对于婚姻的理解"></a>摆正对于婚姻的理解</h3><blockquote><p>职场雇佣关系，朋友关系，商业上的价值互换关系</p></blockquote><p><img src="../assets/image-20240320160800430.png" alt="image-20240320160800430"></p><p>婚姻的本质 是找一个战场上的一个战友关系，是一个相互爱慕的战友</p><p>首先是同目标，共进退。不抛弃，不放弃；</p><p>其次才是对方的技能有多强</p><p>==慕强的本质关系==</p><h3 id="亲密关系的无知"><a href="#亲密关系的无知" class="headerlink" title="亲密关系的无知"></a>亲密关系的无知</h3><p>大学教育里边却没有教育，自己家庭里边的空白，大多数事情里边都有一个专业，</p><p>而对于两性关系方面，大多数人是面对的确是自己没有自知之明的无知</p><h2 id="先进行自身建设"><a href="#先进行自身建设" class="headerlink" title="先进行自身建设"></a>先进行自身建设</h2><blockquote><p>爱人之前，先爱自己</p></blockquote><p><img src="../assets/image-20240320161516105.png" alt="image-20240320161516105"></p><p>==沉默成本解释外，更深层的理解==</p><blockquote><p>自我认可度不高的人，很容易会把恋爱中的甜蜜时刻，理解为对方是命运给与自己的恩惠和赏赐，从而会给对方添加滤镜。即使往往对方对自己并不好，也很难结束一段有毒的关系。</p><blockquote><p>能做到这一步很难，很多人要用一生来去治愈童年</p></blockquote><p>自我认可度不高的人很容易为了人与人之间当下的短暂快乐，而自愿去做明知没有结果的事情，去维持明知没有结果的关系，甚至会让自己主动去付出巨额代价。</p><p>会遇到人渣并让自己在一段感情中自我献祭</p></blockquote><p><img src="../assets/image-20240320161612688.png" alt="image-20240320161612688"></p><blockquote><p>异地女朋友 单独和男生吃饭后才主动告知，下次买票钱我来出？？</p></blockquote><h3 id="如何把握严于律己，宽以待人的分寸？"><a href="#如何把握严于律己，宽以待人的分寸？" class="headerlink" title="如何把握严于律己，宽以待人的分寸？"></a><strong>如何把握严于律己，宽以待人的分寸？</strong></h3><p>严于律己，宽于待人 要当做适用于对待特殊情况下的策略，而不是适用于任何情况下的美德</p><p>对方和你没有任何的利益关系，且对方的行为在长远期看，不会损伤你的个人利益</p><p>朋友关系，朋友圈点赞关系，甚至某些情况下 要采用“宽于律己，宽以待人”的策略</p><p><img src="../assets/image-20240320163117338.png" alt="image-20240320163117338"></p><p>对于对方如果跟你有直接利益关系，并且它的行为会长远期看，会影响你自己的个人利益的情况下，==尤其是涉及到人品这个特殊变量的情况下==那么就要去采取“严于律己，同以待人”的策略</p><p><img src="../assets/image-20240320163603054.png" alt="image-20240320163603054"></p><p>学会善用反问句，要让那些让你自己不舒服的人同样难看</p><p><img src="../assets/image-20240321102350839.png" alt="image-20240321102350839"></p><blockquote><p>不管是亲密关系，还是社交关系，要清楚别人时刻是在筛选自己而自己也要时刻学会去主动筛选别人</p></blockquote><p><img src="../assets/image-20240320163636818.png" alt="image-20240320163636818"></p><blockquote><p>不是所有人都会与你同行，在一段亲密关系里边，在你为对方去付出并且对方很享受在你这里的获得时候，对方也应该为你而建立一份契约，你自己也有筛选别人的资格，而非被筛选的资格。</p><p>等你学会如何不惧直面冲突，再去学习如何高情商。</p></blockquote><p><img src="../assets/image-20240320164821898.png" alt="image-20240320164821898"></p><blockquote><p>宜人和温和是强者能量溢出的特权，再身弱之人那里，只会演变成懦弱和委曲求全而不自知，并最终反向筛选出一批人渣主动留在自己的身边。</p><p>要做到以上，内核是自尊自爱；而不管自己有没有做成一些事情，现在自己要做的就是在所有的关系中，去无条件的提高自我认可度。</p><p>重要的不是对自己高看或者低看，而重要的是在爱人之前，先让自己变得足够强</p></blockquote><h3 id="爱人之前先变强的两个心法"><a href="#爱人之前先变强的两个心法" class="headerlink" title="爱人之前先变强的两个心法"></a>爱人之前先变强的两个心法</h3><ol><li><p>改变自己的关键是创造价值 </p><ol><li>学会用价值规律看问题，让自己变成一个有价值的人</li><li>改变自己的关键是发掘自己并不断的创造价值（创造视频，写文案）<ol><li>帮助别人的同时不断的成就自己</li><li>创造的价值必须是长久的</li></ol></li></ol><blockquote><p>价值够长久，才能够价值够大。同时价值足够大时候，才能够在任何关系中得到对等的回馈</p><p>当把视角“我想要”变成“我能给”的时候，很多浮躁妄念，就会马上消失。</p></blockquote></li></ol><ol><li>建立自己的”身份感”,不是指的是社会世俗意义上的身份，而是从心底建设开始，<strong>弄清楚自己我要成为一个怎样的人</strong></li></ol><p>无论想要成为什么样的人，都要建立自己的身份感，是一种从上到下的全方面塑造，远比以结果为导向从下至上的塑造更具力量。</p><p>如果认为自己强大，那就要有自己发自内心的驱动力，让自己去承受相应的痛苦和困难，不断蜕变。</p><blockquote><p><strong>男性在两性关系中必须接受的事实</strong></p><p>男女而言，通用的是对一个人有没有情欲是爱情能不能发生的一个大前提，而体面感是情欲重要的催化剂。表面上是爱情，其实真正在乎的是体面感。</p><p>体面表面上的表现形式是外貌，财富，而==真正的体面感会在后边展现==</p><blockquote><p>生物进化领域的常识： </p><ol><li>长得太丑的男性，几乎不会获得女性来自情欲所产生的爱情；但当长得丑的男性，如果获得良好的供养能力的时候，比如有钱、有地位，女性会不介意去和其发展长期关系；<strong>但</strong>依旧很难因为情欲而产生爱情。同时这个阶段如果出现一个长得帅的男性来追求这个女生，即便是这个男生没有钱，也没有社会地位，多数女生也不会抗拒和其发展短期关系</li><li>男性在生物学上也并不是多高尚，让人舒服的话，如果说的太多就会让人丧失接收真相的能力</li><li>剔除掉男女两性中很善良的人，也剔除掉很坏的人，剩下的广大7成男女中就基本都是这样子</li><li>进化心理学的观点也就是对于大多数人的进行一个特征的描述</li></ol></blockquote><ol><li><p>财富在两性关系中很重要,但是不要过于高估</p><ol><li>有钱则低调，没钱尽量找一个没钱时爱你的女人，比如爱你的性格，爱你的才学等等、</li></ol></li><li><p>平时保持一个基本的整洁也算是一个必须要做的事情，保持一个基本的精气神（长得好看（生气时候看到就不会生气）vs精神干净，男性好看的包容性）</p></li><li><p>遇到人的“运气和概率”</p><p>烟花0.5s的幸运，会让20多年的努力显得渺小。</p><p>每个人的人生的关键节点，都充满着这0.5s幸运的随机性。如果你碰到的人足够好，不一定是你自己有多么的优秀，而是因为你自己遇到了这0.5妙的随机性，<strong>0.5妙的概率幸运，让自己的所有的人品，包括20多年的努力都会显得相形见绌</strong></p></li></ol></blockquote><h4 id="人唯一能做的"><a href="#人唯一能做的" class="headerlink" title="人唯一能做的"></a>人唯一能做的</h4><p><img src="../assets/image-20240320170004561.png" alt="image-20240320170004561"></p><blockquote><p>而不是遇到对的人和爱自己的人时候，发现不了，识别不了，甚至将别人对自己的爱轻视甚至浪费掉，这样的人注定不会承接住好东西。</p></blockquote><p>提高自己在亲密关系里识别和抓住好东西能力重点在于<strong>祛魅</strong> ==第二节重点讲祛魅==</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../assets/image-20240321102137401.png" alt="image-20240321102137401"></p><p><img src="../assets/image-20240321102225633.png" alt="image-20240321102225633"></p><blockquote><p>唯有自知，方有自爱；唯有自爱，方有人爱。</p></blockquote><p><img src="../assets/image-20240321105014986.png" alt="image-20240321105014986"></p><p><strong>一切从认识自我开始</strong></p><blockquote><p>关于幸运的思考:  自己高考 524  差最后一名 ；大学里边成绩搞得挺好，但是能够让自己去兼职+成功大二；考研扩招+读研</p><p>中文互联网越来越趋向于封闭，获取有效信息的成本越来越大；想要看到真正有价值的思考，或者“隐学”正变得越来越难，很多真正的好回答将再次变成“家学”。</p><p>不再花费时间去回答很多热点内容，摒弃掉所有没有长期价值的内容，执着于长期价值的回答和做事（未来两三年或者长期十几年后的仍然有用的东西），力求每一件事情都能够解决实际问题或者改变一个观念，消除一切浮躁的动机。</p></blockquote><p>推荐电影《背靠背 脸对脸》，B站就有很多介绍</p><p><img src="../assets/image-20240322204210917.png" alt="image-20240322204210917"></p><p><img src="../assets/image-20240322211957586.png" alt="image-20240322211957586"></p><blockquote><p>纪律 服从 权威<br>1.恰当微笑。不得罪人，给人留下好印象，仪容仪表，把领导同事当客户，端庄微笑，和蔼可亲<br>2.夸别人。忌讳说别人坏话，夸领导表示服从，夸自己，夸同事打下群众基础<br>3.为领导分担。错事错办，但不能不办<br>4.忍。忍批评，受委屈，吃小亏<br>5.谨慎。慎之又慎，不背后说人坏话，不犯原则性错误；事无巨细，谨小慎微，反复检查<br>6.混。不鼓励个人英雄主义，强调集体主义，和光同尘。<br>7.熬。延迟满足，曲折前进，自制力强。熬资历，熬时间（人生低潮时期），熬领导。你年轻，时间站在你这边，终究会熬出头的</p></blockquote><p><a href="https://mp.weixin.qq.com/s/B2eBdYGzXEJkq0woTGWKAQ">冯军旗：如何制定好的政策 ——基于《不变的是原则，万变的是方法》的实证研究 (qq.com)</a></p><h1 id="冯军旗：如何制定好的政策-——基于《不变的是原则，万变的是方法》的实证研究"><a href="#冯军旗：如何制定好的政策-——基于《不变的是原则，万变的是方法》的实证研究" class="headerlink" title="冯军旗：如何制定好的政策 ——基于《不变的是原则，万变的是方法》的实证研究"></a>冯军旗：如何制定好的政策 ——基于《不变的是原则，万变的是方法》的实证研究</h1><h1 id="善思会写更快乐219"><a href="#善思会写更快乐219" class="headerlink" title="善思会写更快乐219"></a>善思会写更快乐219</h1><p>节后复工第一天，感觉怎么样？</p><p>有一种说法我很喜欢，职业就像游戏打怪通关，倦怠意味着你在这一关地图都展开了，打到头了，而新一关的钥匙，就在某个你曾经视而不见的熟悉地方。</p><p>而古典老师说过的这4条职场认知，我觉得帮助很大，也分享给你。</p><p>1️⃣结果思维，过程不重要，结果才重要。</p><p>2️⃣贡献思维，怀才不遇是个伪命题。<br>现在的社会分工很细，就像一条流水线拆出来的内容。所以，专业人士有义务告诉上游和下游，你能干什么。换言之，有义务把自己的才华“卖出去”，变成“贡献”。</p><p>3️⃣得失思维，职场不谈对错，谈得失。</p><p>4️⃣灰度思维，所有的职业环境，都是多元视角妥协而成的产物。在职业世界中，不是非黑即白，任何事情都是灰色的、混色的。</p><p>以上这4点，你想清楚了，职业世界的事，无往而不胜。工作即道场，记得要升级哦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;聂辉华番外课程1该不该走选调生&quot;&gt;&lt;a href=&quot;#聂辉华番外课程1该不该走选调生&quot; class=&quot;headerlink&quot; title=&quot;聂辉华番外课程1该不该走选调生&quot;&gt;&lt;/a&gt;聂辉华番外课程1该不该走选调生&lt;/h1&gt;&lt;h2 id=&quot;细节展开1&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LLm_learn</title>
    <link href="https://www.fomal.cc/posts/1908cf59.html"/>
    <id>https://www.fomal.cc/posts/1908cf59.html</id>
    <published>2024-02-16T10:48:56.000Z</published>
    <updated>2024-03-01T09:58:27.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fine-Tuning-or-Retrieval-Comparing-Knowledge-Injection-in-LLMs？"><a href="#Fine-Tuning-or-Retrieval-Comparing-Knowledge-Injection-in-LLMs？" class="headerlink" title="Fine-Tuning or Retrieval Comparing Knowledge Injection in LLMs？"></a>Fine-Tuning or Retrieval Comparing Knowledge Injection in LLMs？</h1><blockquote><p>相比于封装好的相关的事实知识信息，利用外部数据能够扩展大模型的性能，并减少其对于训练数据依赖性；</p><blockquote><p>如何更好的使用外部数据集来合并新信息，或根据之前看到的信息改进llm的功能，是一个重大的挑战</p></blockquote></blockquote><p>比较了两种常见的扩展方法:<strong>无监督微调</strong>和<strong>检索增强生成(RAG)（retrieval-augmented generation (RAG)）</strong>。我们在不同主题的知识密集型任务上评估这两种方法。我们的发现表明，==尽管无监督的微调提供了一些改进，但RAG的性能始终优于它==，无论是在训练中遇到的现有知识还是全新的知识。此外，我们发现，llm很难通过无监督的微调来学习新的事实信息，而在训练期间让他们接触同一事实的众多变体可以缓解这个问题。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><ol><li>大型语言模型（LLMs）能够捕获大量的事实信息（Petroni等，2019年；Cohen等，2023年；Hu等，2023年）。由于它们庞大的预训练数据集，LLMs在各个领域展示出了显著的知识水平。然而，这种知识存在两个显著的局限性。<strong>首先，它是静态的，不随时间更新。其次，它不具体，因此可能在特定领域缺乏细致的专业知识。虽然这是两个不同的问题，但它们深深相关，因为它们的解决方案是相同的：增强模型的知识。</strong></li><li>最近，将LLMs适应特定领域并更新其知识的想法变得越来越普遍（Yu等，2022年）。已经提出了各种模型来改进不同领域的事实知识和能力，例如医疗保健（Singhal等，2023a;b；Wu等，2023a）、金融（Wu等，2023b；Yang等，2023）和法律（Huang等，2023年；Nguyen，2023年）。</li><li>在这项工作中，我们<strong>专注于评估模型的知识及其记忆、理解和检索事实数据的能力。</strong>我们的目标是理解知识注入的概念（Wang等，2020年；Chen等，2022年；Liu等，2020年；Lauscher等，2020年）。<strong>在给定文本语料库形式相关某些知识库的情况下，找到如何教一个预训练模型这些知识的最佳方法</strong></li><li>向预训练模型添加知识的一种方法是通过微调。通过微调，我们继续模型的训练过程，并使用特定于任务的数据进行适应。通过让模型接触特定的知识库，我们期望模型的权重相应地适应。这个过程旨在优化模型以用于目标应用，提高其在专业领域的性能和上下文相关性。</li><li>另一种增强模型知识库的方法是通过使用上下文学习（ICL）（Chen等，2021年；Radford等，2019年；Min等，2021年；Lampinen等，2022年）。ICL背后的主要思想是通过修改模型的输入query而不直接改变模型的权重来提高预训练LLMs在新任务上的性能。<strong>ICL的一种形式是检索增强生成（RAG）</strong>（Lewis等，2020年；Neelakantan等，2022年）。<strong>RAG利用信息检索技术使LLMs能够从知识源中获取相关信息并将其合并到生成的文本中。</strong></li><li>本研究旨在通过比较微调和RAG评估LLMs的知识注入能力。为了说明原理，让我们使用一个类比。考虑三名大学生在特定主题的考试上。所有人都可以获取课堂材料，但事先不知道主题。第一名学生只在考试时有教材，第二名学生在考试之前有准备，并学习了，而第三名学生在考试通知发布后失去了准备时间。谁可能表现得更好？</li></ol><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h2><ol><li>背景：为了评估知识注入，我们必须首先了解对于LLMs而言知识意味着什么。知识和语言模型：定义知识是一个复杂的哲学任务，远远超出了本研究的范围。然而，我们可以考察在语言模型的背景下事实知识意味着什么。如果一个模型知道一个事实，它可以准确而一致地回答与之相关的问题。此外，它可以可靠地区分与该事实相关的真假陈述。然后，我们可以将这个定义扩展到整个知识库，而不仅仅是单个事实。数学上，设Q = {qn}N为N个多项选择事实问题的集合，其中每个问题有L个可能的答案和一个正确答案。设A = {(a1n，…，aLn)}N为相应的可能答案集合，C = {cn}N为正确的答案。设M是一个语言模型。我们用M(qn) ∈ {a1n, …，aLn}表示模型对第n个问题的预测答案。我们定义M关于Q的知识分数L为标准的准确度分数：LM,Q := #{qn| M(qn) = cn} / N。如果以下条件成立，我们说模型M在Q集合方面拥有任何知识：LM,Q &gt; 1 / L。简单地说，模型可以一致地给出正确答案，超过简单的随机猜测基线。自然地，如果模型M相对于另一个模型的知识得分LM,Q更高，那么我们断言前者相对于后者在Q方面更有知识。</li><li>先前见过的知识：一个重要的区分是模型在预训练期间曾接触过的知识与全新事实之间的区别。考虑到现代LLM训练集的规模，它们涵盖了通过网络文本获得的大量信息。因此，即使在利基领域，知识注入的目标不一定是教会模型全新的事实，而是通过向特定领域施加偏好来“刷新”其记忆。</li><li>知识和推理：我们强调，LLMs的这种知识评估框架是不完美的。重要的是，它并没有解决影响模型响应的其他质量指标。创建一个纯粹以知识为基础的数据集而不涉及某种程度的推理是具有挑战性的。因此，具有强大推理能力的模型可能通过在多项选择考试中进行“有根据的猜测”而在陌生的知识密集型任务上表现出色。因此，对LLMs中的知识的任何评估都应考虑到这一点，并将结果视为推理（Sakaguchi等，2021年）、阅读理解（Dua等，2019年）和一般语言能力（Srivastava等，2022年）的更广泛基准的一部分。然而，这个评估框架仍然强调事实信息高于其他一切。</li><li>事实错误的原因：模型无法准确回答事实问题有很多可能的原因。在Wang等人的研究中，Wang等人介绍了五个主要的模型级错误原因的分类：<ul><li>领域知识不足：语言模型可能在特定领域缺乏全面的专业知识，因为它没有接触过这个领域。例如，一个只在威廉·莎士比亚的文本上训练的模型在被问及马克·吐温的作品时表现会很差。</li><li>过时信息：LLMs的截止日期由它们的训练数据集确定。因此，任何在最后一次训练更新之后发生的事件、发现或变化，如果没有外部来源的访问，将不会在模型的知识范围内。</li><li>遗忘：有时，模型在训练过程中接触到知识，但没有保留下来。对于在训练数据集中很少出现的罕见事实，这一点尤为真实。</li><li>遗忘：语言模型在预训练阶段之后通常会进行额外的训练（微调）。在某些情况下，这可能会导致一种被称为灾难性遗忘的现象，其中模型会失去在微调过程之前具有的一些知识。</li><li>推理失败：在某些情况下，语言模型可能具有与事实相关的相关知识，但未能正确利用它。这在复杂的多步推理任务（Tan等，2023年）或当对同一事实提出不同问题时特别明显，导致不同的结果。</li></ul></li></ol><h2 id="3-Injecting-Knowledge-to-Language-Models"><a href="#3-Injecting-Knowledge-to-Language-Models" class="headerlink" title="3. Injecting Knowledge to Language Models"></a>3. Injecting Knowledge to Language Models</h2><p>根据第2节中给出的背景，很明显，对于许多知识密集型任务来说，一般的预先培训是不够的。为了解决这个问题，额外的后处理步骤对于增强预训练模型的知识至关重要。这一步通常被称为知识注入（Wang et al.，2020年; Chen等人，2022; Liu等人，2020; Lauscher等人，2020年）。<strong>在本节中，我们将研究两种广泛使用的知识注入框架：微调（FT）和检索增强生成（RAG）。我们开始制定知识注入问题，旨在解释这两种方法使用一致的术语。</strong></p><p>现在使用相同的术语将这个公式扩展到知识注入的问题。给定一组事实问题，存在一些包含与这些问题相关的信息的文本语料库。<strong>知识注入的核心假设是，如果能够完全访问该语料库，它可以作为辅助知识库，并提高模型在这组问题上的性能。</strong>在数学上，假设M是一个预先训练好的模型，Q是一组事实问题。现在，假设我们有一个相关的辅助知识库BQ。我们的目标是发现一个变换，记为F，当应用时，将增强关于Q：M′：= F（M，BQ）s. t的知识。LM′，Q &gt; LM，Q.(3)</p><h3 id="3-2-微调"><a href="#3-2-微调" class="headerlink" title="3.2. 微调"></a>3.2. 微调</h3><p>3.2. 微调：微调是调整预训练模型以增强其在特定、通常更狭窄的数据集或任务上性能的过程。在这里，重要的是要区分不同类型的微调。FT技术通常被分类为监督、无监督和<strong>基于强化学习（RL）的方法</strong>。我们接下来简要回顾这些方法及其与知识注入问题的关系。</p><ul><li>监督微调：监督微调（SFT）需要标记的输入-输出对。其中一种最常见的SFT方法是指导微调，它已成为提高模型性能的最强大方法之一。使用指导微调，输入是自然语言任务描述，输出是所需行为的示例。许多当前最先进的LLMs在预训练阶段之后经历了指导微调。</li><li>强化学习：FT的另一种形式依赖于RL或<strong>RL启发的优化策略来更好地调整模型</strong>。其中一些突出的例子是来自人类反馈的强化学习（RLHF）、直接偏好优化（DPO）和近端策略优化（PPO）。这些技术已被证明在与指导微调结合使用时非常有用。然而，与指导微调类似，这些方法<strong>侧重于响应的整体质量和其预期行为，而不一定关注其知识的广度。</strong></li><li>无监督微调：我们讨论的最后一种FT策略是无监督的，这意味着模型没有可用的标签可供学习。一个常见的无监督FT技术通常被称为持续预训练或非结构化FT。在这种方法中，FT过程被视为预训练阶段的直接延续。</li></ul><blockquote><p>启发式离散数据微调【基于强化学习的方法】</p></blockquote><h3 id="3-3-检索增强生成："><a href="#3-3-检索增强生成：" class="headerlink" title="3.3. 检索增强生成："></a>3.3. 检索增强生成：</h3><p>3.3. 检索增强生成：检索增强生成（RAG）<strong>是一种通过使用外部知识源扩展LLMs能力的技术，尤其是在知识密集型任务中。</strong>原始的制定涉及每个任务的额外训练，但已经证明，<strong>一个预训练的嵌入模型可以在没有额外训练的情况下获得改进的性能。</strong>该想法是在给定一个辅助知识库和一个输入查询的情况下，使用RAG架构找到与输入查询相似的文档。这些文档随后被添加到输入查询中，从而使模型对查询的主题有进一步的上下文理解。实践中，实现建议的架构相当简单：<strong>给定一个辅助知识库BQ和一个预训练的嵌入模型Me，我们为每个文档b ∈ BQ创建一个密集向量表示（嵌入），并将这些存储在向量存储器中。收到新查询q后，我们使用其嵌入Me(q)来检索与q的前K个最近邻，bq = {bk}K1，根据点积排名。然后，我们更新q为˜q = bq∥q，其中∥表示字符串连接。最后，我们返回M(˜q)作为模型的输出。</strong></p><h2 id="4-Knowledge-Base-Creation"><a href="#4-Knowledge-Base-Creation" class="headerlink" title="4. Knowledge Base Creation"></a>4. Knowledge Base Creation</h2><h3 id="4-1-任务选择和原理"><a href="#4-1-任务选择和原理" class="headerlink" title="4.1. 任务选择和原理"></a>4.1. 任务选择和原理</h3><p>MMLU基准：为了正确评估LLMs在知识密集型任务上的能力，我们从大规模多语言语言理解评估（MMLU）基准中选择了四个不同的任务，涵盖解剖学、天文学、大学生物学、大学化学和史前等主题。所选任务是基于它们对事实知识的重视以及对推理的最小依赖而选择的。作为<strong>一种启发式方法</strong>，我们<strong>选择了问题简短且不涉及上下文的任务</strong>。在实践中，我们选择了四个STEM学科以及一个人文学科，以确保评估不局限于某些领域。值得注意的是，史前涉及涵盖所有非现代历史的问题。这种方法旨在使我们能够测试LLM在理解和操纵信息方面的熟练程度，与其推理过程隔离开来。</p><p>时事任务：为了进一步孤立LLM学习新知识的能力，我们<strong>创建了一个包含关于当前事件的多项选择题的任务</strong>。该任务包括关于发生在各种模型训练数据截止日期之后的事件的多项选择题。具体来说，我们侧重于美国的“当前事件”，时间跨度为2023年8月至11月，这些事件包含在相关的维基百科索引中。这种方法使我们几乎可以保证模型没有接触过这些事实，因此能够直接测试知识注入的能力。</p><p>总结：在本节中，作者选择了四个来自MMLU基准的不同任务，涵盖了解剖学、天文学、大学生物学、大学化学和史前等主题，以评估LLMs在知识密集型任务上的能力。此外，为了测试LLM学习新知识的能力，还创建了一个关于当前事件的任务。这些任务的选择旨在确保测试能够涵盖各种领域，并在不同背景下评估LLM的能力。</p><h3 id="4-2-数据收集与预处理"><a href="#4-2-数据收集与预处理" class="headerlink" title="4.2. 数据收集与预处理"></a>4.2. 数据收集与预处理</h3><p>4.2. 数据收集与预处理 为了有效评估LLMs在这些知识密集型任务上的表现，通过从维基百科中针对每个主题抓取相关文章，收集了一个全面的辅助数据集。选择维基百科作为主要知识来源的原因是它对相关主题的广泛覆盖以及作为群众验证知识库的可靠性。通过识别每个主题的相关中心页面，通过官方维基百科API检索了所有与任务相关的文章。 随后，采用了严格的清理过程将数据从原始子部分转换为干净的块。此步骤使用了“wikiextractor”工具（Attardi，2015）。将数据分成小的、干净的块（例如，删除HTML、URL等）旨在增强LLMs在各种知识领域的理解，并帮助LLMs进行微调过程。</p><h3 id="4-3-当前事件任务创建"><a href="#4-3-当前事件任务创建" class="headerlink" title="4.3. 当前事件任务创建"></a>4.3. 当前事件任务创建</h3><p>4.3. 当前事件任务创建 在从维基百科收集到相关块之后，我们借助GPT-4（OpenAI，2023）创建了一个新的多项选择数据集。首先，我们移除了任何小块。对于语料库中的每个剩余块，要求GPT-4创建四个高度具体、高质量的只有一个正确答案的多项选择题。所谓具体，是指问题可以在不了解问题所指的上下文的情况下回答，并且具有最小的歧义性。接下来，要求GPT-4选择其中最具体的两个。然后进行手动评估和验证步骤。总共，这产生了910个新问题。</p><h3 id="4-4-释义生成"><a href="#4-4-释义生成" class="headerlink" title="4.4. 释义生成"></a>4.4. 释义生成</h3><p>4.4. 释义生成 在创建数据集之后，我们利用GPT-4生成数据集的增强版本。我们要求GPT-4提供输入数据的释义版本，这些版本完全保留信息但用不同措辞。为了确保多样性，每次释义迭代都使用不同的种子。我们随机选择了每个任务的240个块，并为每个块创建两个释义。这些被保留用于用于超参数调整的验证集。对于描述在第6节中的微调过程中使用的当前事件数据集，我们为每个块创建了十个释义。</p><h2 id="5-实验和结果"><a href="#5-实验和结果" class="headerlink" title="5.实验和结果"></a>5.实验和结果</h2><p>实验框架 我们使用了流行的LM-Evaluation-Harness（Gao等人，2021）存储库来评估LLMs在所选知识密集型任务上的性能。LM-Evaluation-Harness是一个强大的基准测试工具，目前是模型评估的行业标准，并且是HuggingFace排行榜的基础。利用这个平台确保了标准化的评估框架，并允许跨模型、方法和数据集进行一致的比较。更重要的是，通过使用行业标准进行评估，我们可以避免由提示工程和格式问题引起的任何差异，并复制每个模型的报告基准结果。</p><p>模型选择 我们选择了三个模型进行推理评估：Llama2-7B（Touvron等人，2023）、Mistral-7B（Jiang等人，2023）和Orca2-7B（Mitra等人，2023）。选择这些模型旨在代表最流行的开源基础模型和跨各种基线能力的经过指令调整的模型。此外，我们选择了bge-large-en（Xiao等人，2023）作为RAG组件的嵌入模型，并使用FAISS（Johnson等人，2019）作为其向量存储。根据HuggingFace MTEB排行榜，这个嵌入模型目前是开源嵌入模型的SOTA。</p><p>配置变化 我们的评估包括多个配置，并对它们进行了网格搜索，以便进行更全面的基准测试。首先，我们比较了基线和微调模型以及它们与RAG组件的性能。其次，我们探索了在RAG中添加到上下文中的文本块的最佳数量。具体来说，采用了不同的K值 ∈ {0, . . . , 5}来分析对模型性能的影响。最后，我们探讨了5-shot性能与0-shot性能之间的比较。</p><p>训练设置 我们使用了第3.2节中描述的无监督训练过程对所有模型进行训练。对于每个数据集，我们将辅助知识库分成大小为256的相等块，通过连接或分割原始块来实现。我们还添加了两个特殊标记，<BOS>和<EOS>，来标记原始块的开头和结尾，以保留文档的结构。模型的训练使用了介于1 × 10^−6和5 × 10^−5之间的学习率，这是通过超参数搜索找到的。所有模型都在4个NVIDIA A-100 GPU上进行了最多5个时期的训练，并且批量大小为64。</p><p>评估方法 所有评估都是通过将每个多项选择选项附加到问题后，然后通过模型传递连接以获得每个选项的对数概率分数来完成的。最高分被解释为模型的选择，并用于准确性计算。更正式地说，在方程（1）中，我们说如果M(qn) = cn： cn = arg max l {M(qn∥a1 n), . . . ,M(qn∥aL n)}, 其中M(qn∥al n) = log PM(qn∥al n)。</p><p>MMLU结果 对于每个任务和模型，我们比较了四种方法：仅使用基本模型、RAG、FT以及通过使用微调模型作为生成器来合并FT和RAG。此外，我们使用了0-shot和5-shot场景来测试MMLU任务。完整的结果显示在表1中。相对准确性增益的聚合，即 (LM′,Q − LM,Q)/LM,Q， 其中M是基本模型，M′是注入知识的模型，显示在图2中。在所有情况下，RAG的表现明显优于基本模型。此外，将RAG与基本模型作为生成器一起使用一直比仅进行微调更好。在某些情况下，将微调模型而不是基本模型用作RAG管道中的生成器进一步提高了结果。然而，这并不一致，因此显示了微调的固有不稳定性。此外，我们发现5-shot方法在大多数情况下都略微提高了结果，在所有不同方法中观察到了类似的趋势。</p><p>当前事件结果 当前事件任务的评估显示在表2中。由于问题和辅助数据集之间的一对一对应（请参阅第4.3节），RAG证明了其特别有效性。微调与RAG相比不具竞争力。然而，微调与多个释义仍然比基线提供了显著的改进。我们注意到，与仅使用RAG相比，将RAG与微调相结合的性能较差。</p><p>值得注意的是，虽然问题是基于模型在训练过程中未接触到的信息，但基本模型的结果超过了1/L = 0.25。这部分可以通过模型在回答不独立于过去信息的问题时使用推理和/或现有知识来解释。一些这方面的例子可以在附录C中找到。</p><p>微调与RAG： <strong>在MMLU和当前事件任务的结果中，RAG相对于微调的显着优势是明显的。</strong>虽然微调在大多数情况下改善了结果，但与RAG方法相比并不具有竞争力。可能有几个因素会导致这种行为。首先，<strong>RAG不仅向模型添加知识，还包含与问题相关的上下文，这是微调所缺乏的功能。</strong>此外，<strong>微调可能会影响模型的其他功能，因为微调程度可能导致灾难性遗忘。</strong>最后，未监督微调模型可能会通过监督或基于RL的微调进一步对齐，正如Orca2相对于基本的Llama2的性能大大提高所示。</p><h2 id="6-重复的重要性"><a href="#6-重复的重要性" class="headerlink" title="6.重复的重要性"></a>6.重复的重要性</h2><p>与其他任务不同，在其他任务中，模型已经在预训练期间暴露于与主题相关的方面，当前事件包括新信息。在这种情况下，标准的常规微调不仅没有提高Llama2的性能，而且还显着降低了它。为了改善微调结果，我们探索了使用释义的数据增强。</p><h2 id="7-结论和未来的工作"><a href="#7-结论和未来的工作" class="headerlink" title="7.结论和未来的工作"></a>7.结论和未来的工作</h2><p>大型语言模型拥有各种主题的大量知识。在这项工作中，我们测试了他们适应新知识的能力：包括专业知识和完全看不见的知识。这是第一个研究比较两个突出的方法在这一领域，即微调和检索增强生成。虽然微调对许多用例都很有用，但我们发现RAG是知识注入的更可靠选择。这项工作的某些方面仍需要进一步研究。例如，我们专注于无监督训练作为我们的主要微调方法，而不是预防性调整或基于RL的方法。研究各种技术与各种辅助知识库的组合可能会产生更好的结果。这种方法，结合我们在第6节中的假设，可以进一步增强我们对通过FT进行知识注入的理解。虽然我们相信这项工作进一步提高了我们对LLM知识的理解，但在这一领域还有很多工作要做。具体而言，需要更多的研究，特别是从理论的角度来看，关于在LLM知识表示的问题。最后，需要进一步努力衡量法学硕士的知识。虽然我们采用了公式（2）中描述的经验方法，但探索其他关于知识的定义和观点并扩展这项工作也很重要。</p><h2 id="8-Limitations"><a href="#8-Limitations" class="headerlink" title="8. Limitations"></a>8. Limitations</h2><p>在所有机器学习应用中，超参数的选择会显著影响结果。因此，我们强烈建议针对特定情况优化所有相关的超参数。我们通过在三个不同的模型上进行实验来支持我们的主张。然而，对其他LLM的推广应该彻底测试。例如，GPT-4对于某些MMLU任务实现了近乎完美的准确性（Nori等人，2023），因此不适用进一步的改进。最后，当我们为知识库选择各种主题时，我们所有的来源都来自维基百科。其他数据集可能会产生不同的结果，必须仔细评估。</p><blockquote><p>Knowledge Base Creation   创建启发式方法</p></blockquote><p>优化prompt </p><blockquote><p>基于公开的数据库 大家去做测试 </p><p>能不能做两个 一个获取更好的数据，另一个去做</p><p>带着地理信息 图片信息 怎样放到prompt 中</p></blockquote><h1 id="RLPROMPT-Optimizing-Discrete-Text-Prompts-with-Reinforcement-Learning"><a href="#RLPROMPT-Optimizing-Discrete-Text-Prompts-with-Reinforcement-Learning" class="headerlink" title="RLPROMPT: Optimizing Discrete Text Prompts with Reinforcement Learning"></a>RLPROMPT: Optimizing Discrete Text Prompts with Reinforcement Learning</h1><blockquote><p>强化学习+模型微调</p><p>自动为每个任务找到最佳prompt</p></blockquote><p>==<strong>现状</strong>==</p><p>现有的大多数工作都依赖于调优<strong>软提示</strong>(例如，嵌入式提示)，这些<strong>提示缺乏可解释性</strong>、跨模型之间的的可重用性以及当梯度不可访问时的适用性。另一方面，离散提示很难优化，通常是通过“枚举(例如，解释)-选择”启发式创建的，这种<strong>启发式不会系统地探索提示空间</strong>。</p><p>==提出了一种<strong>基于强化学习的离散提示优化方法RLPROMPT</strong>。RLPROMPT构建了一个参数高效的策略网络，在奖励训练后生成优化的离散提示。==  为了利用来自大LM环境的复杂和随机奖励信号，我们结合了有效的稳定奖励，大大提高了训练效率。RLPROMPT可以灵活地应用于不同类型的大模型，如mask(如BERT)和left-to-right模型(如GPTs)，用于分类和生成任务。在少镜头分类和无监督文本样式转换上的实验表明，在现有的各种微调或提示方法中，该方法具有优越的性能。有趣的是<strong>，优化后的提示往往是不合语法的乱码;令人惊讶的是，这些胡言乱语提示在不同的LM之间是可转移的，以保持显著的性能，这表明LM提示可能不遵循人类的语言模式。</strong></p><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>Prompting已经成为使用大型预训练语言模型（LMs）解决各种NLP问题的一种有前途的方法，包括从左到右的模型（例如GPTs）（Radford等人，2019年；Brown等人，2020年）和掩码LMs（例如BERT）（Devlin等人，2019年）、RoBERTa（Liu等人，2019年）等。与昂贵地为每个下游任务更新大量LM参数的传统微调相比，<strong>Prompting在输入中连接附加文本，指导LM生成所需的输出，从而降低了成本</strong>。Prompting的一个关键问题是如何找到最佳提示来提高LM在各种任务上的性能，通常只有很少的训练样本。</p><ul><li>Prompting是使用大型预训练语言模型（LMs）解决各种NLP问题的一种有前途的方法，与传统的微调相比，它在输入中连接额外的文本以指导LM生成所需的输出，从而降低了成本。</li><li>关于Prompting的一个关键问题是如何找到最佳提示以提高LM在各种任务上的性能，通常只有很少的训练样本。</li></ul><p>其中，最流行的方案之一是调整软提示（即连续嵌入向量），因为它们易于梯度下降。然而，由于其本质上来说，由于人类难以理解且无法与其他LMs一起使用，生成的提示对人类来说很难理解，并且不兼容。此外，LM内部梯度通常难以计算，或者仅对仅具有推理API（例如GPT-3）的LMs不可用。因此，<strong>使用由词汇表中的具体标记组成的离散提示通常是可取的</strong>。然而，它们的离散性质使优化变得非常困难。以往的研究通常依赖于手动工程或从多个释义/生成的提示中进行选择。AutoPrompt使用梯度信息编辑提示标记，但受到训练不稳定性和与基于梯度的软提示相同的适用性问题的影响，在实践中的效果有限。</p><ul><li>一个流行的方案是调整软提示，因为它们易于梯度下降，但生成的提示难以理解，而且不兼容其他LMs。</li><li>离散提示通常由具体标记组成，但它们的离散性质使得优化变得非常困难。</li><li>以往的研究通常依赖于手动工程或从多个释义/生成的提示中进行选择，但这些方法在实践中的效果有限。</li></ul><p>本文提出了一种新的基于强化学习（RL）的离散提示优化方法RLPROMPT，该方法汇集了在不同任务和LMs上高效使用的广泛理想属性。与直接编辑离散标记不同，<strong>RLPROMPT训练一个生成所需提示的策略网络</strong>。离散提示优化实际上就是学习少量策略参数，我们将其设置为<strong>插入到冻结的紧凑模型中的MLP层</strong>，例如distilGPT-2。该公式还使我们能够<strong>使用现成的RL算法</strong>，这些算法<strong>可以使用任意奖励函数来学习策略，无论是使用可用数据（例如在少样本分类中）定义的还是在没有监督数据可用时（例如在可控文本生成中）使用的其他弱信号。</strong></p><ul><li>RLPROMPT是一种新的基于强化学习（RL）的离散提示优化方法，它训练一个生成所需提示的策略网络，并在不同任务和LMs上高效使用。</li><li>与直接编辑离散标记不同，RLPROMPT训练一个生成所需提示的策略网络，这使得离散提示的优化更加高效。</li></ul><p>然而，RL用于提示优化对学习效率提出了新的挑战：大型黑箱LM呈现出高度复杂的环境，给定提示（即操作）后，经过一系列复杂的转换（例如读取输入和推断输出）才能计算奖励。这使得奖励信号非常不稳定，很难学习。为了克服这一困难，我们提出了两种简单但令人惊讶地有效的方法来稳定奖励并提高优化效率。</p><ul><li>RL用于提示优化对学习效率提出了新的挑战，因为大型黑箱LM呈现出高度复杂的环境，奖励信号非常不稳定且难以学习。</li><li>为了克服这一困难，我们提出了两种简单但令人惊讶地有效的方法来稳定奖励并提高优化效率。</li></ul><p>在少样本分类和无监督文本风格转换的实验中，我们的方法在各种微调和提示方法（例如表1中描述的方法）上都有所改进，并且对不同的建模选择（例如分类中的verbalizers）都具有鲁棒性。所得到的离散提示还有助于进行丰富的解释和分析，以便深入了解LM提示的新见解。尤其是，尽管优化后的提示能够引起强大的任务性能，但倾向于是没有明确人类可理解含义的无意义文本，与最近的研究相呼应，即利用提示的LMs并不一定遵循人类语言模式。也许令人惊讶的是，学习了一个LM的那些无意义提示可以在其他LM中显著提高性能，这表明不同的预训练LM已经掌握了用于提示的共享结构。</p><ul><li>在少样本分类和无监督文本风格转换的实验中，我们的方法在各种微调和提示方法上都有所改进，并且对不同的建模选择都具有鲁棒性。</li><li>离散提示还有助于进行丰富的解释和分析，以便深入了解LM提示的新见解。</li><li>学习了一个LM的那些无意义提示可以在其他LM中显著提高性能，这表明不同的预训练LM已经掌握了用于提示的共享结构。</li></ul><p><strong>我们将给出离散prompt optimization的RL公式(§2.1-2.2)。然后我们讨论我们的策略网络的设计(§2.3)。最后，我们描述了我们的奖励工程技术来提高RL培训(§2.4)。</strong></p><blockquote><p>第一篇文章的knowledge base 搭建 </p><p>学习了初步的在大模型上以及大模型之间的应用的微调策略以及增强式生成策略，并对比了相应方法的不同</p><p>第二篇文章 是对应与微调策略里边的强化学习提示网路模型，生成对应的网络提示</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fine-Tuning-or-Retrieval-Comparing-Knowledge-Injection-in-LLMs？&quot;&gt;&lt;a href=&quot;#Fine-Tuning-or-Retrieval-Comparing-Knowledge-Injection-in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>参与开源社区</title>
    <link href="https://www.fomal.cc/posts/48379df9.html"/>
    <id>https://www.fomal.cc/posts/48379df9.html</id>
    <published>2024-01-24T10:27:14.000Z</published>
    <updated>2024-03-01T09:58:27.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试参与开源活动，整理一下自己的github主页</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试参与开源活动，整理一下自己的github主页&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
